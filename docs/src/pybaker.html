<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.5">
<title>src.pybaker API documentation</title>
<meta name="description" content="A program to change the metadata of a PyPlate project and create a dist â€¦">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.pybaker</code></h1>
</header>
<section id="section-intro">
<p>A program to change the metadata of a PyPlate project and create a dist</p>
<p>This module sets the project metadata in each of the files, according to the
data present in the conf files. It then sets up the dist folder with all
necessary files to create a complete distribution of the project.</p>
<p>Run pybaker -h for more options.</p>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.pybaker.PyBaker"><code class="flex name class">
<span>class <span class="ident">PyBaker</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PyBaker:
    &#34;&#34;&#34;
    The main class, responsible for the operation of the program

    Public methods:
        main: The main method of the program

    This class implements all the needed functionality of PyBaker, to create a
    distribution of a project from a settings file.
    &#34;&#34;&#34;

    # ------------------------------------------------------------------------------
    # Class constants
    # ------------------------------------------------------------------------------

    # ------------------------------------------------------------------------------
    # this is our metadata bootstrap
    # NB: these should be the only strings in this file, as they should NOT be
    # changed by dev

    # find path to prj
    P_DIR_PRJ = Path(__file__).parents[1].resolve()

    # name and desc for cmd line help
    S_PP_NAME_BIG = &#34;PyBaker&#34;
    S_PP_NAME_SMALL = &#34;pybaker&#34;
    S_PP_VERSION = &#34;0.0.1&#34;
    S_PP_SHORT_DESC = (
        &#34;A program to set the metadata of a PyPlate project and create a dist&#34;
    )

    # formatted version
    # NB: done in two steps to avoid linter errors
    S_VER_FMT = &#34;Version {}&#34;
    S_VER_OUT = S_VER_FMT.format(S_PP_VERSION)

    # help str
    S_PP_HELP = &#34;Use pybaker -h for more info&#34;

    # about string
    S_PP_ABOUT = (
        f&#34;{S_PP_NAME_BIG}\n&#34;
        f&#34;{S_PP_SHORT_DESC}\n&#34;
        f&#34;{S_VER_OUT}\n&#34;
        f&#34;https://www.github.com/cyclopticnerve/PyPlate\n&#34;
        f&#34;{S_PP_HELP}\n&#34;
    )

    # instructions string
    S_PP_EPILOG = (
        &#34;Run this program from the parent directory of the project you want &#34;
        &#34;to build.&#34;
    )

    # our venv name
    S_PP_VENV = &#34;.venv-pyplate&#34;

    # debug option strings
    S_DBG_OPTION = &#34;-d&#34;
    S_DBG_ACTION = &#34;store_true&#34;
    S_DBG_DEST = &#34;DBG_DEST&#34;
    S_DBG_HELP = &#34;enable debugging option&#34;

    # ide option strings
    S_IDE_OPTION = &#34;-i&#34;
    S_IDE_ACTION = &#34;store_true&#34;
    S_IDE_DEST = &#34;IDE_DEST&#34;
    S_IDE_HELP = &#34;ask for project folder when running in IDE&#34;

    # --------------------------------------------------------------------------
    # Class methods
    # --------------------------------------------------------------------------

    # --------------------------------------------------------------------------
    # Initialize the new object
    # --------------------------------------------------------------------------
    def __init__(self):
        &#34;&#34;&#34;
        Initialize the new object

        Initializes a new instance of the class, setting the default values
        of its properties, and any other code that needs to run to create a
        new object.
        &#34;&#34;&#34;

        # command line options
        self._debug = False
        self._ide = False

        # internal props
        self._dict_rep = {}
        self._dict_sw_block = {}
        self._dict_sw_line = {}
        self._dict_type_rep = {}
        self._dir_prj = Path()

        # private.json dicts
        self._dict_prv = {}
        self._dict_prv_all = {}
        self._dict_prv_prj = {}

        # project.json dicts
        self._dict_pub = {}
        self._dict_pub_bl = {}
        self._dict_pub_dist = {}
        self._dict_pub_i18n = {}
        self._dict_pub_meta = {}

    # --------------------------------------------------------------------------
    # Public methods
    # --------------------------------------------------------------------------

    # --------------------------------------------------------------------------
    # The main method of the program
    # --------------------------------------------------------------------------
    def main(self, debug=False, ide=False):
        &#34;&#34;&#34;
        The main method of the program

        Args:
            debug: Whether to run in debug mode (default: False)
            ide: Whether we are running in the ide, i.e. vscode launch.json
            (default: False)

        This method is the main entry point for the program, initializing the
        program, and performing its steps.
        &#34;&#34;&#34;

        # set properties
        self._debug = debug
        self._ide = ide

        # ----------------------------------------------------------------------
        #  do the work

        # call boilerplate code
        self._setup()

        # load current metadata from conf or user input
        self._get_project_info()

        # do any fixing up of dicts (like meta keywords, etc)
        self._do_before_fix()

        # fix metadata in files
        self._do_fix()

        # do extra stuff to final dir after fix
        self._do_after_fix()

        # copy project files into dist folder
        self._do_dist()

    # --------------------------------------------------------------------------
    # Private methods
    # --------------------------------------------------------------------------

    # NB: these are the main steps, called in order from main

    # --------------------------------------------------------------------------
    # Boilerplate to use at the start of main
    # --------------------------------------------------------------------------
    def _setup(self):
        &#34;&#34;&#34;
        Boilerplate to use at the start of main

        Perform some mundane stuff like setting properties.
        &#34;&#34;&#34;

        # print about info
        print(self.S_PP_ABOUT)

        # set global prop in conf
        PP.B_DEBUG = self._debug

        # assume we are running in the project dir
        # this is used in a lot of places, so just shorthand it
        self._dir_prj = Path.cwd()

        # check if we are running in ide
        # if yes, ask for prj name
        if self._ide:
            while True:
                prj_name = &#34;&#34;
                while prj_name == &#34;&#34;:
                    prj_name = input(PP.S_ASK_NAME)

                # if running in ide, cwd is pyplate prj dir, so move up and down
                self._dir_prj = Path(self.P_DIR_PRJ / &#34;..&#34; / prj_name)
                if self._dir_prj.exists():
                    break

        # get abs path either way
        self._dir_prj = self._dir_prj.resolve()

        # do not run pybaker on pyplate (we are not that meta YET...)
        if self._dir_prj.is_relative_to(self.P_DIR_PRJ):
            print(PP.S_ERR_PRJ_DIR_IS_PP)
            sys.exit()

        # check if dir_prj has pyplate folder for a valid prj
        path_pyplate = self._dir_prj / PP.S_PRJ_PP_DIR
        if not path_pyplate.exists():
            print(PP.S_ERR_NOT_PRJ)
            sys.exit()

        # debug turns off some _do_after_fix features
        if self._debug:
            PP.B_CMD_DOCS = False
            PP.B_CMD_GIT = False
            PP.B_CMD_INST = False
            PP.B_CMD_I18N = False
            PP.B_CMD_TREE = False
            PP.B_CMD_VENV = False

        # set switch dicts to defaults
        self._dict_sw_block = dict(PP.D_SW_BLOCK_DEF)
        self._dict_sw_line = dict(PP.D_SW_LINE_DEF)

        # get global and calculated settings dict in private.json
        path_prv = self._dir_prj / PP.S_PRJ_PRV_CFG
        self._dict_prv = F.load_dicts([path_prv], {})
        self._dict_prv_all = self._dict_prv[PP.S_KEY_PRV_ALL]
        self._dict_prv_prj = self._dict_prv[PP.S_KEY_PRV_PRJ]

        # get individual dicts in the public file
        path_pub = self._dir_prj / PP.S_PRJ_PUB_CFG
        self._dict_pub = F.load_dicts([path_pub], {})
        self._dict_pub_meta = self._dict_pub[PP.S_KEY_PUB_META]
        self._dict_pub_bl = self._dict_pub[PP.S_KEY_PUB_BL]
        self._dict_pub_i18n = self._dict_pub[PP.S_KEY_PUB_I18N]
        self._dict_pub_dist = self._dict_pub[PP.S_KEY_PUB_DIST]

    # --------------------------------------------------------------------------
    # Get project info
    # --------------------------------------------------------------------------
    def _get_project_info(self):
        &#34;&#34;&#34;
        Get project info

        Here we just make sure the user has edited the appropriate config
        files.
        &#34;&#34;&#34;

        # ask questions
        # ask_in = input(PP.S_ASK_PROPS)
        # if ask_in.lower().startswith(PP.S_ASK_PROPS_DEF) or ask_in == &#34;&#34;:
        #     print()
        #     return

        # # if answer is anything but default or blank, we bail
        # print(PP.S_ASK_PROPS_ABORT)
        # sys.exit()

    # --------------------------------------------------------------------------
    # A function to do stuff before fix
    # --------------------------------------------------------------------------
    def _do_before_fix(self):
        &#34;&#34;&#34;
        A function to do stuff before fix

        This function does some more changes before the actual fix. Mostly it
        is used to call the do_before_fix method in pyplate.py.
        &#34;&#34;&#34;

        print(PP.S_ACTION_BEFORE, end=&#34;&#34;, flush=True)

        # call function to update kw/readme deps
        PP.do_before_fix(self._dir_prj, self._dict_prv, self._dict_pub)

        print(PP.S_ACTION_DONE)

    # --------------------------------------------------------------------------
    # Scan dirs/files in the project for replacing text
    # --------------------------------------------------------------------------
    def _do_fix(self):
        &#34;&#34;&#34;
        Scan dirs/files in the project for replacing text

        Scans for dirs/files under the project&#39;s location. For each dir/file it
        encounters, it passes the path to a filter to determine if the file
        needs fixing based on its appearance in the blacklist.
        &#34;&#34;&#34;

        print(PP.S_ACTION_FIX, end=&#34;&#34;, flush=True)

        # combine dicts for string replacement
        F.combine_dicts(
            [
                self._dict_prv_all,
                self._dict_prv_prj,
                self._dict_pub_meta,
            ],
            self._dict_rep,
        )

        # fix up blacklist and convert relative or glob paths to absolute Path
        # objects
        dict_paths = self._fix_blacklist_paths()

        # just shorten the names
        skip_all = dict_paths[PP.S_KEY_SKIP_ALL]
        skip_contents = dict_paths[PP.S_KEY_SKIP_CONTENTS]
        skip_header = dict_paths[PP.S_KEY_SKIP_HEADER]
        skip_code = dict_paths[PP.S_KEY_SKIP_CODE]
        skip_path = dict_paths[PP.S_KEY_SKIP_PATH]

        # ----------------------------------------------------------------------
        # do the fixes
        # NB: root is a full path, dirs and files are relative to root
        for root, root_dirs, root_files in self._dir_prj.walk():

            # skip dir if in skip_all
            if root in skip_all:
                # NB: don&#39;t recurse into subfolders
                root_dirs.clear()
                continue

            # convert files into Paths
            files = [root / f for f in root_files]

            # for each file item
            for item in files:

                # skip file if in skip_all
                if item in skip_all:
                    continue

                # if we shouldn&#39;t skip contents
                if root not in skip_contents and item not in skip_contents:

                    # for each new file, reset block and line switches to def
                    self._dict_sw_block = dict(PP.D_SW_BLOCK_DEF)
                    self._dict_sw_line = dict(PP.D_SW_LINE_DEF)

                    # check for header bl
                    bl_hdr = True
                    if root not in skip_header and item not in skip_header:
                        bl_hdr = False

                    # check for code blacklist
                    bl_code = True
                    if root not in skip_code and item not in skip_code:
                        bl_code = False

                    # do md/html/xml separately (needs special handling)
                    self._dict_type_rep = PP.D_PY_REPL
                    suffix = (
                        f&#34;.{item.suffix}&#34;
                        if not item.suffix.startswith(&#34;.&#34;)
                        else item.suffix
                    )
                    if suffix in PP.L_EXT_MARKUP:
                        self._dict_type_rep = PP.D_MU_REPL

                    # fix content with appropriate dict
                    self._fix_content(item, bl_hdr, bl_code)

        # ----------------------------------------------------------------------
        # fix path
        # NB: top_down=False is required for the renaming, as we don&#39;t want to
        # rename (and thus clobber) a directory name before we rename all its
        # child dirs/files
        for root, root_dirs, root_files in self._dir_prj.walk(top_down=False):

            # skip dir if in skip_all
            if root in skip_all:
                # NB: do not recurse
                root_dirs.clear()
                continue

            # convert files into Paths
            files = [root / f for f in root_files]

            # for each file item
            for item in files:

                # skip file if in skip_all
                if item in skip_all:
                    continue

                # fix path
                if root not in skip_path and item not in skip_path:
                    self._fix_path(item)

            # fix current dir path
            if root not in skip_path:
                self._fix_path(root)

        # ----------------------------------------------------------------------
        # fix install.json version

        # get version from project.json
        version = self._dict_pub_meta[&#34;__PP_VERSION__&#34;]

        # get install cfg
        a_file = self._dir_prj / PP.S_PATH_INST_CFG
        if a_file.exists():

            # load/change/save
            a_dict = F.load_dicts([a_file])
            a_dict[CNInstall.S_KEY_VERSION] = version
            F.save_dict(a_dict, [a_file])

        # get uninstall cfg
        a_file = self._dir_prj / PP.S_PATH_UNINST_CFG
        if a_file.exists():

            # load/change/save
            a_dict = F.load_dicts([a_file])
            a_dict[CNInstall.S_KEY_VERSION] = version
            F.save_dict(a_dict, [a_file])

        # ----------------------------------------------------------------------
        # save project settings

        # save fixed settings
        dict_prv = {
            PP.S_KEY_PRV_ALL: self._dict_prv_all,
            PP.S_KEY_PRV_PRJ: self._dict_prv_prj,
        }
        path_prv = self._dir_prj / PP.S_PRJ_PRV_CFG
        F.save_dict(dict_prv, [path_prv])

        # save editable settings (blacklist/i18n etc.)
        dict_pub = {
            PP.S_KEY_PUB_BL: self._dict_pub_bl,
            PP.S_KEY_PUB_I18N: self._dict_pub_i18n,
            PP.S_KEY_PUB_DIST: self._dict_pub_dist,
        }
        path_pub = self._dir_prj / PP.S_PRJ_PUB_CFG
        F.save_dict(dict_pub, [path_pub])

        # ----------------------------------------------------------------------
        # fix dunders in bl/i18n
        self._fix_content(path_pub)

        # reload dict from fixed file
        dict_pub = F.load_dicts([path_pub])

        # ----------------------------------------------------------------------
        # save meta

        # put in metadata and save back to file
        dict_pub[PP.S_KEY_PUB_META] = self._dict_pub_meta
        F.save_dict(dict_pub, [path_pub])

        print(PP.S_ACTION_DONE)

    # --------------------------------------------------------------------------
    # Make any necessary changes after all fixes have been done
    # --------------------------------------------------------------------------
    def _do_after_fix(self):
        &#34;&#34;&#34;
        Make any necessary changes after all fixes have been done

        This method is called after all fixes have been completed. There should
        be no dunders in the file or path names. Do any further project
        modification here.
        &#34;&#34;&#34;

        # ----------------------------------------------------------------------
        # call conf after fix

        print(PP.S_ACTION_AFTER, end=&#34;&#34;, flush=True)
        PP.do_after_fix(self._dir_prj, self._dict_prv, self._dict_pub)
        print(PP.S_ACTION_DONE)

        # ----------------------------------------------------------------------
        # freeze requirements
        if PP.B_CMD_VENV:

            print(PP.S_ACTION_VENV, end=&#34;&#34;, flush=True)

            # get name ov venv folder and reqs file
            dir_venv = self._dict_prv_prj[&#34;__PP_NAME_VENV__&#34;]
            file_reqs = PP.S_FILE_REQS

            # do the thing with the thing
            cv = CNVenv(self._dir_prj, dir_venv)
            try:
                cv.freeze(file_reqs)
                print(PP.S_ACTION_DONE)
            except F.CNShellError as e:
                print(PP.S_ACTION_FAIL)
                print(e.message)

        # ----------------------------------------------------------------------
        # i18n

        # path to template
        path_dsk_tmp = self._dir_prj / PP.S_FILE_DSK_TMP
        # path to output
        path_dsk_out = self._dir_prj / self._dict_prv_prj[&#34;__PP_FILE_DESK__&#34;]

        # if i18n flag is set
        if PP.B_CMD_I18N:

            print(PP.S_ACTION_I18N, end=&#34;&#34;, flush=True)

            # create CNPotPy object
            potpy = CNPotPy(
                # header
                str_appname=self._dict_prv_prj[&#34;__PP_NAME_PRJ_BIG__&#34;],
                str_version=self._dict_pub_meta[&#34;__PP_VERSION__&#34;],
                str_author=self._dict_prv_all[&#34;__PP_AUTHOR__&#34;],
                str_email=self._dict_prv_all[&#34;__PP_EMAIL__&#34;],
                # out
                dir_pot=self._dir_prj / PP.S_DIR_I18N,
                # in
                dir_prj=self._dir_prj,
                dir_src=Path(self._dict_prv_all[&#34;__PP_DIR_SRC__&#34;]),
                # optional out
                dir_locale=self._dir_prj / PP.S_PATH_LOCALE,
                dir_po=self._dir_prj / PP.S_PATH_PO,
                str_domain=self._dict_prv_prj[&#34;__PP_NAME_PRJ_SMALL__&#34;],
                # optional in
                str_tag=PP.S_I18N_TAG,
                # NB: use dict_pub here b/c dunders have been fixed
                dict_clangs=self._dict_pub_i18n[PP.S_KEY_CLANGS],
                dict_no_ext=self._dict_pub_i18n[PP.S_KEY_NO_EXT],
                list_wlangs=self._dict_pub_i18n[PP.S_KEY_WLANGS],
                charset=self._dict_pub_i18n[PP.S_KEY_CHARSET],
            )

            # make .pot, .po, and .mo files
            potpy.main()

            # i18n-ify .desktop file
            if path_dsk_tmp.exists():
                potpy.make_desktop(path_dsk_tmp, path_dsk_out)

            # we are done
            print(PP.S_ACTION_DONE)

        # if no i18n, copy .desktop
        else:
            if path_dsk_tmp.exists():
                shutil.copy(path_dsk_tmp, path_dsk_out)

        # ----------------------------------------------------------------------
        # update docs

        # if docs flag is set
        if PP.B_CMD_DOCS:

            print(PP.S_ACTION_DOCS, end=&#34;&#34;, flush=True)

            # get template and output dirs
            dir_docs_tmp = self._dir_prj / PP.S_DIR_DOCS_TMP
            dir_docs_out = self._dir_prj / PP.S_DIR_DOCS

            # nuke old docs
            if dir_docs_out.exists():
                shutil.rmtree(dir_docs_out)
                Path.mkdir(dir_docs_out, parents=True)

            # format cmd using abs prj docs dir (output) and abs prj dir (input)
            cmd_docs = PP.S_CMD_DOC.format(
                dir_docs_tmp, dir_docs_out, self._dir_prj / PP.S_DIR_SRC
            )

            # the command to run pdoc
            cmd = f&#34;{cmd_docs}&#34;
            try:
                F.sh(cmd, shell=True)
                print(PP.S_ACTION_DONE)
            except F.CNShellError as e:
                print(PP.S_ACTION_FAIL)
                raise e

        # ----------------------------------------------------------------------
        # tree
        # NB: run last so it includes .git and .venv folders
        # NB: this will wipe out all previous checks (maybe good?)

        # if tree flag is set
        if PP.B_CMD_TREE:

            print(PP.S_ACTION_TREE, end=&#34;&#34;, flush=True)

            # get path to tree
            file_tree = self._dir_prj / PP.S_TREE_FILE

            # create the file so it includes itself
            with open(file_tree, &#34;w&#34;, encoding=PP.S_ENCODING) as a_file:
                a_file.write(&#34;&#34;)

            # create tree object and call
            tree_obj = CNTree()
            tree_str = tree_obj.build_tree(
                str(self._dir_prj),
                filter_list=self._dict_pub_bl[PP.S_KEY_SKIP_TREE],
                dir_format=PP.S_TREE_DIR_FORMAT,
                file_format=PP.S_TREE_FILE_FORMAT,
            )

            # write to file
            with open(file_tree, &#34;w&#34;, encoding=PP.S_ENCODING) as a_file:
                a_file.write(tree_str)

            print(PP.S_ACTION_DONE)

        # ----------------------------------------------------------------------
        # fix dunders in install/uninstall

        # if install flag is set
        if PP.B_CMD_INST:
            a_path = self._dir_prj / PP.S_FILE_INST_CFG
            if a_path.exists():
                self._fix_content(a_path)
            a_path = self._dir_prj / PP.S_FILE_UNINST_CFG
            if a_path.exists():
                self._fix_content(a_path)

    # --------------------------------------------------------------------------
    # Copy fixed files to final location
    # --------------------------------------------------------------------------
    def _do_dist(self):
        &#34;&#34;&#34;
        Copy fixed files to final location

        Gets dirs/files from project and copies them to the dist/assets dir.
        &#34;&#34;&#34;

        print(PP.S_ACTION_DIST, end=&#34;&#34;, flush=True)

        # call conf before dist
        PP.do_before_dist(self._dir_prj, self._dict_prv, self._dict_pub)

        # # get small name and format w/ version
        # name_small = self._dict_prv_prj[&#34;__PP_NAME_PRJ_SMALL__&#34;]
        # version = self._dict_pub_meta[&#34;__PP_VERSION__&#34;]
        # name_fmt = f&#34;{name_small}_{version}&#34;
        # find old dist? nuke it from orbit! it&#39;s the only way to be sure!
        a_dist = self._dir_prj / PP.S_DIR_DIST
        if a_dist.is_dir():
            shutil.rmtree(a_dist)

        # make child dir in case we nuked
        name_fmt = self._dict_prv_prj[&#34;__PP_DIST_FMT__&#34;]
        p_dist = a_dist / name_fmt
        Path.mkdir(p_dist, parents=True)

        # for each key, val (type, dict)
        for key, val in self._dict_pub_dist.items():

            # get src/dst rel to prj dir/dist dir
            src = self._dir_prj / key
            dst = p_dist / val
            if not dst.exists():
                Path.mkdir(dst, parents=True)
            dst = dst / src.name

            # do the copy
            if src.exists() and src.is_dir():
                shutil.copytree(src, dst, dirs_exist_ok=True)
            elif src.exists() and src.is_file():
                shutil.copy2(src, dst)

        # ----------------------------------------------------------------------
        # do copy lib dict

        # get list of libs for this prj type
        prj_type_short = self._dict_prv_prj[&#34;__PP_TYPE_PRJ__&#34;]
        val = PP.D_COPY_LIB.get(prj_type_short, [])

        # copy libs
        for item in val:

            # get src/dst
            src = self.P_DIR_PRJ / PP.S_DIR_LIB / item
            dst = p_dist / PP.S_DIR_ASSETS / PP.S_DIR_LIB / item

            # copy dir/file
            if src.is_dir():
                shutil.copytree(src, dst, dirs_exist_ok=True)
            else:
                shutil.copy2(src, dst)

        # ----------------------------------------------------------------------
        # call conf after dist

        PP.do_after_dist(self._dir_prj, self._dict_prv, self._dict_pub)

        # done copying project files
        print(PP.S_ACTION_DONE)

    # --------------------------------------------------------------------------
    # These are minor steps called from the main steps
    # --------------------------------------------------------------------------

    # --------------------------------------------------------------------------
    # Convert items in blacklist to absolute Path objects
    # --------------------------------------------------------------------------
    def _fix_blacklist_paths(self):
        &#34;&#34;&#34;
        Convert items in blacklist to absolute Path objects

        Get absolute paths for all entries in the blacklist.
        &#34;&#34;&#34;

        # def result
        res = {}

        # remove path separators
        # NB: this is mostly for glob support, as globs cannot end in path
        # separators
        l_bl = self._dict_pub_bl
        for key in l_bl:
            l_bl[key] = [item.rstrip(&#34;/&#34;) for item in l_bl[key]]
        self._dict_pub_bl = l_bl

        # support for absolute/relative/glob
        # NB: taken from cntree.py

        # for each section of blacklist
        for key, val in self._dict_pub_bl.items():
            # convert all items in list to Path objects
            paths = [Path(item) for item in val]

            # move absolute paths to one list
            abs_paths = [item for item in paths if item.is_absolute()]

            # move relative/glob paths to another list
            other_paths = [item for item in paths if not item.is_absolute()]

            # convert relative/glob paths back to strings
            other_strings = [str(item) for item in other_paths]

            # get glob results as generators
            glob_results = [self._dir_prj.glob(item) for item in other_strings]

            # start with absolutes
            result = abs_paths

            # for each generator
            for item in glob_results:
                # add results as whole shebang
                result += list(item)

            # set the list as the result list
            res[key] = result

        # return dict with path objects
        return res

    # --------------------------------------------------------------------------
    # Fix header or code for each line in a file
    # --------------------------------------------------------------------------
    def _fix_content(self, path, bl_hdr=False, bl_code=False):
        &#34;&#34;&#34;
        Fix header or code for each line in a file

        Args:
            path: Path for replacing text
            bl_hdr: Whether the file is blacklisted for header lines (default:
            False)
            bl_code: Whether the file is blacklisted for code lines (default:
            False)

        For the given file, loop through each line, checking to see if it is a
        header line or a code line. Ignore blank lines and comment-only lines.
        &#34;&#34;&#34;

        # default lines
        lines = []

        # open and read file
        with open(path, &#34;r&#34;, encoding=PP.S_ENCODING) as a_file:
            lines = a_file.readlines()

        # for each line in array
        for index, line in enumerate(lines):

            # ------------------------------------------------------------------
            # skip blank lines
            if line.strip() == &#34;&#34;:
                continue

            # ------------------------------------------------------------------
            # check for block switches

            # param is True if we are looking for block switch vs line switch
            if self._check_switches(line, True):
                continue

            # ------------------------------------------------------------------
            # check for header

            # check if blacklisted for headers
            if not bl_hdr:

                # check if it matches header pattern
                str_pattern = self._dict_type_rep[PP.S_KEY_HDR]
                res = re.search(str_pattern, line)
                if res:

                    # fix it
                    lines[index] = self._fix_header(line)

                    # stop on first match
                    continue

            # ------------------------------------------------------------------
            # skip any other comment lines

            str_pattern = self._dict_type_rep[PP.S_KEY_COMM]
            if re.search(str_pattern, line):
                continue

            # ------------------------------------------------------------------
            # not a blank, block, header, or comment, must be code ( + comment)

            # check if blacklisted for code
            if not bl_code:

                # fix dunders in real code lines (may still have trailing
                # comments)
                lines[index] = self._fix_code(line)

        # open and write file
        with open(path, &#34;w&#34;, encoding=PP.S_ENCODING) as a_file:
            a_file.writelines(lines)

    # --------------------------------------------------------------------------
    # Replace dunders inside a file header
    # --------------------------------------------------------------------------
    def _fix_header(self, line):
        &#34;&#34;&#34;
        Replace dunders inside a file header

        Args:
            line: The line of the file to replace text in

        Returns:
            The new line of code

        Replaces text inside a header line, using a regex to match specific
        lines. Given a line, it replaces the found pattern withe the
        replacement as it goes.
        &#34;&#34;&#34;

        # break apart header line
        # NB: gotta do this again, can&#39;t pass res param
        str_pattern = self._dict_type_rep[PP.S_KEY_HDR]
        res = re.search(str_pattern, line)
        if not res:
            return line

        # pull out lead, val, and pad (OXFORD COMMA FTW!)
        lead = res.group(self._dict_type_rep[PP.S_KEY_LEAD])
        val = res.group(self._dict_type_rep[PP.S_KEY_VAL])
        pad = res.group(self._dict_type_rep[PP.S_KEY_PAD])

        tmp_val = str(val)
        old_val_len = len(tmp_val)
        for key2, val2 in self._dict_rep.items():
            if isinstance(val2, str):
                tmp_val = tmp_val.replace(key2, val2)
        new_val_len = len(tmp_val)
        val_diff = new_val_len - old_val_len

        tmp_pad = str(pad)
        tmp_rat = tmp_pad.lstrip()
        len_pad = len(tmp_pad) - len(tmp_rat) - val_diff
        pad = &#34; &#34; * len_pad

        line = lead + tmp_val + pad + tmp_rat + &#34;\n&#34;

        # return
        return line

    # --------------------------------------------------------------------------
    # Replace dunders inside a markup file&#39;s contents
    # --------------------------------------------------------------------------
    def _fix_code(self, line):
        &#34;&#34;&#34;
        Replace dunders inside a markup file&#39;s contents

        Args:
            line: The line of the file to replace text in

        Returns:
            The new line of code

        Replaces text inside a line. Given a line, replaces dunders as it goes.
        When it is done, it returns the new line. This replaces the __PP
        dunders inside the file, excluding flag switches, headers, and
        comment-only lines (all of which are previously handled in
        _fix_content).
        &#34;&#34;&#34;

        # ----------------------------------------------------------------------
        # split the line into code and comm

        # we will split the line into two parts
        # NB: assume code is whole line (i.e. no trailing comment)
        code = line
        comm = &#34;&#34;

        # do the split, checking each match to see if we get a trailing comment
        matches = re.finditer(self._dict_type_rep[PP.S_KEY_SPLIT], line)
        for match in matches:
            # if there is a match group for hash mark (meaning we found a
            # trailing comment)
            if match.group(4):
                # split the line (comm includes hash mark as first char, code
                # get space between)
                split = match.start(4)
                code = line[:split]
                comm = line[split:]

        # ----------------------------------------------------------------------
        # check for line switches

        # for each line, reset line dict
        self._dict_sw_line = dict(PP.D_SW_LINE_DEF)

        # do the check
        self._check_switches(comm, False)

        # ----------------------------------------------------------------------

        # check for block or line replace switch
        repl = False
        if (
            self._dict_sw_block[PP.S_SW_REPLACE]
            and self._dict_sw_line[PP.S_SW_REPLACE] != PP.I_SW_FALSE
            or self._dict_sw_line[PP.S_SW_REPLACE] == PP.I_SW_TRUE
        ):
            repl = True

        # ----------------------------------------------------------------------

        # replace content using current flag setting
        if repl:
            for key, val in self._dict_rep.items():
                if isinstance(val, str):
                    code = code.replace(key, val)

        # put the line back together
        line = code + comm

        # replace version
        ver = self._dict_pub_meta[&#34;__PP_VERSION__&#34;]
        str_sch = PP.S_META_VER_SEARCH
        str_rep = PP.S_META_VER_REPL.format(ver)
        line = re.sub(str_sch, str_rep, line)

        # replace short desc
        desc = self._dict_pub_meta[&#34;__PP_SHORT_DESC__&#34;]
        str_sch = PP.S_META_SD_SEARCH
        str_rep = PP.S_META_SD_REPL.format(desc)
        line = re.sub(str_sch, str_rep, line)

        # return the (maybe replaced) line
        return line

    # --------------------------------------------------------------------------
    # Rename dirs/files in the project
    # --------------------------------------------------------------------------
    def _fix_path(self, path):
        &#34;&#34;&#34;
        Rename dirs/files in the project

        Args:
            path: Path for dir/file to be renamed

        Returns:
            A bool indication whether the name changed (Note that this
            does not mean the file was renamed, only that it should be).

        Rename dirs/files. Given a path, it renames the dir/file by replacing
        dunders in the path with their appropriate replacements from
        self._dict_rep.
        &#34;&#34;&#34;

        # first get the path name (we only want to change the last component)
        last_part = path.name

        # # replace dunders in last path component
        for key, val in self._dict_rep.items():
            if isinstance(val, str):
                last_part = last_part.replace(key, val)

        # replace the name
        path_new = path.parent / last_part

        # if it hasn&#39;t changed, skip to avoid overhead
        if path_new == path:
            return

        # do rename
        path.rename(path_new)

    # --------------------------------------------------------------------------
    # Check if line or trailing comment is a switch
    # --------------------------------------------------------------------------
    def _check_switches(self, line, block):
        &#34;&#34;&#34;
        Check if line or trailing comment is a switch

        Args:
            line: The line to check for block switches
            block: True if we want to check a block switch, False if we want
            to check a line switch

        Returns:
            True if a valid switch is found, False otherwise

        This method checks to see if a line or trailing comment contains a
        valid switch (for either markup or regular files). If a valid switch is
        found, it sets the appropriate flag in either self._dict_sw_block or
        self._dict_sw_line and returns True.
        &#34;&#34;&#34;

        # match  switches (&#39;#|&lt;!-- python: enable=replace&#39;, etc)
        match = re.match(self._dict_type_rep[PP.S_KEY_SWITCH], line)
        if not match:
            return False

        # this line is a switch
        key = None
        val = None
        if match.group(1) and match.group(2):
            key = match.group(2)
            val = match.group(1)

        # which dict to modify
        dict_to_check = self._dict_sw_block
        if not block:
            dict_to_check = self._dict_sw_line

        # ditch any matches that are not valid keys/vals
        if not key or not val or not key in dict_to_check:
            return False

        # test for specific values, in case it is malformed
        if val == PP.S_SW_ENABLE:
            dict_to_check[key] = PP.I_SW_TRUE
            return True
        if val == PP.S_SW_DISABLE:
            dict_to_check[key] = PP.I_SW_FALSE
            return True

        # no valid switch found
        return False

    # --------------------------------------------------------------------------
    # Check if new version number is semantic
    # --------------------------------------------------------------------------
    def _check_version(self, version):
        &#34;&#34;&#34;
        Check if new version number is semantic

        Args:
            version: New version number to check

        Returns:
            True if a valid version is found, False otherwise

        This method checks to see if the version string passed is valid for
        semantic versioning.
        &#34;&#34;&#34;

        # match semantic version from start of string
        pattern = PP.S_SEMVER_VALID
        return re.match(pattern, version)</code></pre>
</details>
<div class="desc"><p>The main class, responsible for the operation of the program</p>
<p>Public methods:
main: The main method of the program</p>
<p>This class implements all the needed functionality of PyBaker, to create a
distribution of a project from a settings file.</p>
<p>Initialize the new object</p>
<p>Initializes a new instance of the class, setting the default values
of its properties, and any other code that needs to run to create a
new object.</p></div>
<h3>Class variables</h3>
<dl>
<dt id="src.pybaker.PyBaker.P_DIR_PRJ"><code class="name">var <span class="ident">P_DIR_PRJ</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.pybaker.PyBaker.S_DBG_ACTION"><code class="name">var <span class="ident">S_DBG_ACTION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.pybaker.PyBaker.S_DBG_DEST"><code class="name">var <span class="ident">S_DBG_DEST</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.pybaker.PyBaker.S_DBG_HELP"><code class="name">var <span class="ident">S_DBG_HELP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.pybaker.PyBaker.S_DBG_OPTION"><code class="name">var <span class="ident">S_DBG_OPTION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.pybaker.PyBaker.S_IDE_ACTION"><code class="name">var <span class="ident">S_IDE_ACTION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.pybaker.PyBaker.S_IDE_DEST"><code class="name">var <span class="ident">S_IDE_DEST</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.pybaker.PyBaker.S_IDE_HELP"><code class="name">var <span class="ident">S_IDE_HELP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.pybaker.PyBaker.S_IDE_OPTION"><code class="name">var <span class="ident">S_IDE_OPTION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.pybaker.PyBaker.S_PP_ABOUT"><code class="name">var <span class="ident">S_PP_ABOUT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.pybaker.PyBaker.S_PP_EPILOG"><code class="name">var <span class="ident">S_PP_EPILOG</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.pybaker.PyBaker.S_PP_HELP"><code class="name">var <span class="ident">S_PP_HELP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.pybaker.PyBaker.S_PP_NAME_BIG"><code class="name">var <span class="ident">S_PP_NAME_BIG</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.pybaker.PyBaker.S_PP_NAME_SMALL"><code class="name">var <span class="ident">S_PP_NAME_SMALL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.pybaker.PyBaker.S_PP_SHORT_DESC"><code class="name">var <span class="ident">S_PP_SHORT_DESC</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.pybaker.PyBaker.S_PP_VENV"><code class="name">var <span class="ident">S_PP_VENV</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.pybaker.PyBaker.S_PP_VERSION"><code class="name">var <span class="ident">S_PP_VERSION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.pybaker.PyBaker.S_VER_FMT"><code class="name">var <span class="ident">S_VER_FMT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.pybaker.PyBaker.S_VER_OUT"><code class="name">var <span class="ident">S_VER_OUT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="src.pybaker.PyBaker.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>self, debug=False, ide=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main(self, debug=False, ide=False):
    &#34;&#34;&#34;
    The main method of the program

    Args:
        debug: Whether to run in debug mode (default: False)
        ide: Whether we are running in the ide, i.e. vscode launch.json
        (default: False)

    This method is the main entry point for the program, initializing the
    program, and performing its steps.
    &#34;&#34;&#34;

    # set properties
    self._debug = debug
    self._ide = ide

    # ----------------------------------------------------------------------
    #  do the work

    # call boilerplate code
    self._setup()

    # load current metadata from conf or user input
    self._get_project_info()

    # do any fixing up of dicts (like meta keywords, etc)
    self._do_before_fix()

    # fix metadata in files
    self._do_fix()

    # do extra stuff to final dir after fix
    self._do_after_fix()

    # copy project files into dist folder
    self._do_dist()</code></pre>
</details>
<div class="desc"><p>The main method of the program</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>debug</code></strong></dt>
<dd>Whether to run in debug mode (default: False)</dd>
<dt><strong><code>ide</code></strong></dt>
<dd>Whether we are running in the ide, i.e. vscode launch.json</dd>
</dl>
<p>(default: False)
This method is the main entry point for the program, initializing the
program, and performing its steps.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src" href="index.html">src</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.pybaker.PyBaker" href="#src.pybaker.PyBaker">PyBaker</a></code></h4>
<ul class="two-column">
<li><code><a title="src.pybaker.PyBaker.P_DIR_PRJ" href="#src.pybaker.PyBaker.P_DIR_PRJ">P_DIR_PRJ</a></code></li>
<li><code><a title="src.pybaker.PyBaker.S_DBG_ACTION" href="#src.pybaker.PyBaker.S_DBG_ACTION">S_DBG_ACTION</a></code></li>
<li><code><a title="src.pybaker.PyBaker.S_DBG_DEST" href="#src.pybaker.PyBaker.S_DBG_DEST">S_DBG_DEST</a></code></li>
<li><code><a title="src.pybaker.PyBaker.S_DBG_HELP" href="#src.pybaker.PyBaker.S_DBG_HELP">S_DBG_HELP</a></code></li>
<li><code><a title="src.pybaker.PyBaker.S_DBG_OPTION" href="#src.pybaker.PyBaker.S_DBG_OPTION">S_DBG_OPTION</a></code></li>
<li><code><a title="src.pybaker.PyBaker.S_IDE_ACTION" href="#src.pybaker.PyBaker.S_IDE_ACTION">S_IDE_ACTION</a></code></li>
<li><code><a title="src.pybaker.PyBaker.S_IDE_DEST" href="#src.pybaker.PyBaker.S_IDE_DEST">S_IDE_DEST</a></code></li>
<li><code><a title="src.pybaker.PyBaker.S_IDE_HELP" href="#src.pybaker.PyBaker.S_IDE_HELP">S_IDE_HELP</a></code></li>
<li><code><a title="src.pybaker.PyBaker.S_IDE_OPTION" href="#src.pybaker.PyBaker.S_IDE_OPTION">S_IDE_OPTION</a></code></li>
<li><code><a title="src.pybaker.PyBaker.S_PP_ABOUT" href="#src.pybaker.PyBaker.S_PP_ABOUT">S_PP_ABOUT</a></code></li>
<li><code><a title="src.pybaker.PyBaker.S_PP_EPILOG" href="#src.pybaker.PyBaker.S_PP_EPILOG">S_PP_EPILOG</a></code></li>
<li><code><a title="src.pybaker.PyBaker.S_PP_HELP" href="#src.pybaker.PyBaker.S_PP_HELP">S_PP_HELP</a></code></li>
<li><code><a title="src.pybaker.PyBaker.S_PP_NAME_BIG" href="#src.pybaker.PyBaker.S_PP_NAME_BIG">S_PP_NAME_BIG</a></code></li>
<li><code><a title="src.pybaker.PyBaker.S_PP_NAME_SMALL" href="#src.pybaker.PyBaker.S_PP_NAME_SMALL">S_PP_NAME_SMALL</a></code></li>
<li><code><a title="src.pybaker.PyBaker.S_PP_SHORT_DESC" href="#src.pybaker.PyBaker.S_PP_SHORT_DESC">S_PP_SHORT_DESC</a></code></li>
<li><code><a title="src.pybaker.PyBaker.S_PP_VENV" href="#src.pybaker.PyBaker.S_PP_VENV">S_PP_VENV</a></code></li>
<li><code><a title="src.pybaker.PyBaker.S_PP_VERSION" href="#src.pybaker.PyBaker.S_PP_VERSION">S_PP_VERSION</a></code></li>
<li><code><a title="src.pybaker.PyBaker.S_VER_FMT" href="#src.pybaker.PyBaker.S_VER_FMT">S_VER_FMT</a></code></li>
<li><code><a title="src.pybaker.PyBaker.S_VER_OUT" href="#src.pybaker.PyBaker.S_VER_OUT">S_VER_OUT</a></code></li>
<li><code><a title="src.pybaker.PyBaker.main" href="#src.pybaker.PyBaker.main">main</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.5</a>.</p>
</footer>
</body>
</html>
