<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>src.pyplate API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.pyplate</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#! /usr/bin/env python
# ------------------------------------------------------------------------------
# Project : PyPlate                                                /          \
# Filename: pyplate.py                                            |     ()     |
# Date    : 12/08/2022                                            |            |
# Author  : cyclopticnerve                                        |   \____/   |
# License : WTFPLv2                                                \          /
# ------------------------------------------------------------------------------

# ------------------------------------------------------------------------------
# Imports
# ------------------------------------------------------------------------------
from datetime import datetime
import json
import os
import re
import shlex
import shutil
import subprocess

# ------------------------------------------------------------------------------
# Constants
# ------------------------------------------------------------------------------

# this is the dir where the script is being run from
# (e.g. ~/Documents/Projects/Python/PyPlate/src/)
path = os.path.abspath(__file__)
DIR_CURR = os.path.dirname(path)

# this is the dir where the template files are located rel to the script
# (e.g. ~/Documents/Projects/Python/PyPlate/template/)
path = os.path.join(DIR_CURR, &#39;..&#39;, &#39;template&#39;)
DIR_TEMPLATE = os.path.abspath(path)

# this is the dir for project location (above PyPlate)
# (e.g. ~/Documents/Projects/Python/)
path = os.path.join(DIR_CURR, &#39;..&#39;, &#39;..&#39;)
DIR_BASE = os.path.abspath(path)

# this is the current user home dir
# (e.g. /home/cyclopticnerve/)
DIR_USER = os.path.expanduser(&#39;~&#39;)

# files to include in project
# NB: paths are relative to DIR_TEMPLATE
DICT_FILES = {
    &#39;common&#39;: [                 # common to all projects
        &#39;docs&#39;,
        &#39;misc&#39;,
        &#39;tests&#39;,
        &#39;.gitignore&#39;,
        &#39;LICENSE.txt&#39;,
        &#39;README.md&#39;,
        &#39;requirements.txt&#39;,
    ],
    &#39;m&#39;: [                      # for module projects
        &#39;src/__PP_NAME_SMALL__.mod.py&#39;,
        &#39;MANIFEST.in&#39;,
        &#39;pyproject.toml&#39;,
    ],
    &#39;p&#39;: [                      # for package projects
        &#39;src/__PP_NAME_SMALL__&#39;,
        &#39;MANIFEST.in&#39;,
        &#39;pyproject.toml&#39;,
    ],
    &#39;c&#39;: [                      # for cli projects
        &#39;src/__PP_NAME_SMALL__.app.py&#39;,
        &#39;install.py&#39;,
        &#39;uninstall.py&#39;,
    ],
    &#39;g&#39;: [                      # for gui projects
        &#39;gui&#39;,
        &#39;src/__PP_NAME_SMALL__.app.py&#39;,
        &#39;install.py&#39;,
        &#39;uninstall.py&#39;,
    ],
}

# the array of header strings to match for replacement
LIST_HEADER = [
    [&#39;# Project : &#39;,    &#39;__PP_NAME_BIG__&#39;,   &#39;/          \\ &#39;],
    [&#39;# Date    : &#39;,    &#39;__PP_DATE__&#39;,       &#39;|            |&#39;],
    [&#39;&lt;!-- Project : &#39;, &#39;__PP_NAME_BIG__&#39;,   &#39;/          \\  --&gt;&#39;],
    [&#39;&lt;!-- Date    : &#39;, &#39;__PP_DATE__&#39;,       &#39;|            | --&gt;&#39;],
]

# the dict of README tags to find/replace
DICT_README = {
    &#39;mp&#39;: {
        &#39;start_str&#39;:  &#39;&lt;!-- __PP_APP_START__ --&gt;&#39;,
        &#39;end_str&#39;:    &#39;&lt;!-- __PP_APP_END__ --&gt;&#39;,
        &#39;ignore_str&#39;: &#39;&lt;!-- __PP_MOD_&#39;,
    },
    &#39;cg&#39;: {
        &#39;start_str&#39;:  &#39;&lt;!-- __PP_MOD_START__ --&gt;&#39;,
        &#39;end_str&#39;:    &#39;&lt;!-- __PP_MOD_END__ --&gt;&#39;,
        &#39;ignore_str&#39;: &#39;&lt;!-- __PP_APP_&#39;,
    }
}

# ------------------------------------------------------------------------------
# Globals
# ------------------------------------------------------------------------------

# the default settings to use to create the project
# NB: these can be used later by metadata.py (in misc/settings.json)
dict_settings = {
    &#39;project&#39;: {
        &#39;type&#39;: &#39;&#39;,                 # m (Module), p (Package), c (CLI), g (GUI)
        &#39;path&#39;: &#39;&#39;,                 # path to project (DIR_BASE/type_dir/Foo)
    },
    &#39;reps&#39;: {
        &#39;__PP_NAME_BIG__&#39;:   &#39;&#39;,    # Foo
        &#39;__PP_NAME_SMALL__&#39;: &#39;&#39;,    # foo
        &#39;__PP_DATE__&#39;:       &#39;&#39;,    # 12/08/2022
    },
}


# ------------------------------------------------------------------------------
# Public functions
# ------------------------------------------------------------------------------

# ------------------------------------------------------------------------------
# Main function
# ------------------------------------------------------------------------------
def main():
    &#34;&#34;&#34;
        Main function

        This is the main function, which calls each step in the process of
        creating a project.
    &#34;&#34;&#34;

    # call each step
    get_project_info()
    copy_template()

    path = dict_settings[&#39;project&#39;][&#39;path&#39;]
    recurse(path)

    add_extras()


# ------------------------------------------------------------------------------
# Get project info
# ------------------------------------------------------------------------------
def get_project_info():
    &#34;&#34;&#34;
        Get project info

        Asks the user for project info, such as type and name.
    &#34;&#34;&#34;

    # the settings dict (global b/c we will modify here)
    global dict_settings

    # loop forever until we get a valid type
    while True:

        # ask what type of project
        prj_type = input(
            &#39;Project type: [m]odule | [p]ackage | [c]li | [g]ui: &#39;
        )

        # check project type
        pattern = r&#39;(^(m|p|c|g{1})$)&#39;
        res = re.search(pattern, prj_type, re.I)
        if res:

            # we got a valid type
            prj_type = prj_type.lower()
            dict_settings[&#39;project&#39;][&#39;type&#39;] = prj_type
            break

    # configure subdir
    type_dir = &#39;&#39;
    if prj_type in &#39;mp&#39;:
        type_dir = &#39;Libs&#39;
    else:
        type_dir = &#39;Apps&#39;

    # loop forever until we get a valid name and path
    while True:

        # ask for project name
        prj_name_big = input(&#39;Project name: &#39;)

        # check for valid name
        if not _validate_name(prj_name_big):
            continue

        # calculate final proj location
        prj_path = os.path.join(DIR_BASE, type_dir, prj_name_big)

        # check if project already exists
        if os.path.exists(prj_path):
            print(f&#39;Project {prj_path} already exists&#39;)
            continue

        # if name is valid, move on
        dict_settings[&#39;reps&#39;][&#39;__PP_NAME_BIG__&#39;] = prj_name_big
        dict_settings[&#39;project&#39;][&#39;path&#39;] = prj_path
        break

    # calculate small name
    prj_name_small = prj_name_big.lower()
    dict_settings[&#39;reps&#39;][&#39;__PP_NAME_SMALL__&#39;] = prj_name_small

    # calculate current date
    prj_date = datetime.now().strftime(&#39;%m/%d/%Y&#39;)
    dict_settings[&#39;reps&#39;][&#39;__PP_DATE__&#39;] = prj_date


# ------------------------------------------------------------------------------
# Copy template files to final location
# ------------------------------------------------------------------------------
def copy_template():
    &#34;&#34;&#34;
        Copy template files to final location

        Get file paths/names from dict_settings and copy them to the project
        folder.
    &#34;&#34;&#34;

    # create target folder
    prj_path = dict_settings[&#39;project&#39;][&#39;path&#39;]
    os.makedirs(prj_path)

    # get project type
    proj_type = dict_settings[&#39;project&#39;][&#39;type&#39;]

    # the group of files, common and type
    groups = [
        DICT_FILES[&#39;common&#39;],
        DICT_FILES[proj_type]
    ]

    # for each group, common and type
    items = [item for group in groups for item in group]
    for item in items:

        # build old path/new path
        path_old = os.path.join(DIR_TEMPLATE, item)
        path_new = os.path.join(prj_path, item)

        # if it&#39;s a dir, copy dir
        if os.path.isdir(path_old):
            shutil.copytree(path_old, path_new)
        else:

            # if it&#39;s a file, get the file&#39;s dir and create
            dir_new = os.path.dirname(path_new)
            os.makedirs(dir_new, exist_ok=True)

            # then copy file
            shutil.copy2(path_old, path_new)

    # write dict_settings to a file in misc
    file_path = os.path.join(prj_path, &#39;misc&#39;, &#39;settings.json&#39;)
    with open(file_path, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f:
        dict_str = json.dumps(dict_settings, indent=4)
        f.write(dict_str)


# ------------------------------------------------------------------------------
# Recursivly scan files/folders for replace/rename functions
# ------------------------------------------------------------------------------
def recurse(path):
    &#34;&#34;&#34;
        Recursivly scan files/folders for replace/rename functions

        Paramaters:
            path [string]: the folder to start recursively scanning from

        This is a recursive function to scan for files/folders under a given
        folder. It iterates over the contents of the &#39;path&#39; folder, checking if
        each item is a file or a folder. If it encounters a folder, it calls
        itself recursively, passing that folder as the parameter. If it
        encounters a file, it calls methods to do text replacement of headers,
        then other text. Finally it renames the file if the name contains a
        replacement key. Once all files are renamed, it will then bubble up to
        rename all folders.
    &#34;&#34;&#34;

    # get list of file names in dest dir
    items = [item for item in os.listdir(path)]
    for item in items:

        # put path back together
        path_item = os.path.join(path, item)

        # if it&#39;s a dir
        if os.path.isdir(path_item):

            # recurse itself to find more files
            recurse(path_item)

        else:

            # open file and get lines
            with open(path_item, &#39;r&#39;, encoding=&#39;utf-8&#39;) as f:
                lines = f.readlines()

            # replace headers from lines
            lines = _replace_headers(lines)

            # replace text from lines (skipping text in certain files in misc)
            if (
                item != &#39;metadata.py&#39; and
                item != &#39;settings.json&#39;
            ):
                lines = _replace_text(lines)

            # readme needs extra handling (if it is not excluded anywhere else)
            if item == &#39;README.md&#39;:
                lines = _fix_readme(lines)

            # save lines
            with open(path_item, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f:
                f.writelines(lines)

        # called for each file/folder
        _rename(path_item)


# ------------------------------------------------------------------------------
# Add .git and .venv folders to new project
# ------------------------------------------------------------------------------
def add_extras():
    &#34;&#34;&#34;
        Add .git and .venv folders to new project

        Adds a .git folder (repository) and a .venv (virtual environment) folder
        to the project, and sets them up as necessary.
    &#34;&#34;&#34;

    # make sure we are in current proj path
    dir = dict_settings[&#39;project&#39;][&#39;path&#39;]
    os.chdir(dir)

    # add git folder
    cmd = &#39;git init&#39;
    cmd_array = shlex.split(cmd)
    subprocess.run(cmd_array)

    # add venv dir
    # use &#39;.venv&#39; to be compatible with VSCodium
    cmd = &#39;python -m venv .venv&#39;
    cmd_array = shlex.split(cmd)
    subprocess.run(cmd_array)


# ------------------------------------------------------------------------------
# Private functions
# ------------------------------------------------------------------------------

# ------------------------------------------------------------------------------
# Check project name for allowed characters
# ------------------------------------------------------------------------------
def _validate_name(name):
    &#34;&#34;&#34;
        Check project name for allowed characters

        Paramaters:
            name [string]: the name to check for allowed characters

        Returns:
            [bool]: whether the name is valid to use

        This function checks the passed name for four criteria:
        1. blank name
        2. starts with an alpha char
        3. ends with an alphanumeric char
        4. contains only alphanumeric chars
    &#34;&#34;&#34;

    # 1. check for blank name
    if name == &#39;&#39;:
        return False

    # 2. match start or return false
    pattern = r&#39;(^[a-zA-Z])&#39;
    res = re.search(pattern, name)
    if not res:
        print(&#39;Project names must start with a letter&#39;)
        return False

    # 3. match end or return false
    pattern = r&#39;([a-zA-Z0-9]$)&#39;
    res = re.search(pattern, name)
    if not res:
        print(&#39;Project names must end with a letter or number&#39;)
        return False

    # 4. match middle or return false
    pattern = r&#39;(^[a-zA-Z0-9]*$)&#39;
    res = re.search(pattern, name)
    if not res:
        print(&#39;Project names must contain only letters or numbers&#39;)
        return False

    # if we made it this far, return true
    return True


# ------------------------------------------------------------------------------
# Replace header text inside files
# ------------------------------------------------------------------------------
def _replace_headers(lines):
    &#34;&#34;&#34;
        Replace header text inside files

        Paramaters:
            lines [list]: the list of file lines for replacing header text

        Returns:
            [list]: the list of replaced lines in the file

        This is a function to replace header text inside a file. Given a list of
        file lines, it iterates the list line by line, replacing header text as
        it goes. When it is done, it returns lhe list of lines. This replaces
        the __PP_.. stuff inside headers.
    &#34;&#34;&#34;

    # the array of dunder replacements we will use
    reps = dict_settings[&#39;reps&#39;]

    # for each line in array
    for i in range(0, len(lines)):

        # for each repl line
        for hdr_line in LIST_HEADER:

            # build start str
            key = hdr_line[0] + hdr_line[1]

            # if the key is in the line
            if key in lines[i]:

                # replace the dunder
                rep = reps[hdr_line[1]]

                # calculate spaces
                spaces = (80 - (len(hdr_line[0]) + len(rep) + len(hdr_line[2])))
                spaces_str = &#39; &#39; * spaces

                # create replacement string (with newline!!!)
                rep_s = (
                    f&#39;{hdr_line[0]}{rep}{spaces_str}{hdr_line[2].strip()}\n&#39;
                )

                # replace text in line
                lines[i] = rep_s

    # return the changed lines
    return lines


# ------------------------------------------------------------------------------
# Replace text inside files
# ------------------------------------------------------------------------------
def _replace_text(lines):
    &#34;&#34;&#34;
        Replace text inside files

        Paramaters:
            lines [list]: the list of file lines for replacing text

        Returns:
            [list]: the list of replaced lines in the file

        This is a function to replace text inside a file. Given a list of file
        lines, it iterates the list line by line, replacing text as it goes.
        When it is done, it returns the list of lines. This replaces the
        __PP_... stuff inside the file, excluding headers (which are already
        handled).
    &#34;&#34;&#34;

    # the array of dunder replacements we will use
    reps = dict_settings[&#39;reps&#39;]

    # for each line in array
    for i in range(0, len(lines)):

        # replace text in line
        for key in reps.keys():
            if key in lines[i]:
                lines[i] = lines[i].replace(key, reps[key])

    # save file with replacements
    return lines


# ------------------------------------------------------------------------------
# Remove unneccesary parts of the README file
# ------------------------------------------------------------------------------
def _fix_readme(lines):
    &#34;&#34;&#34;
        Remove unneccesary parts of the README file

        Paramaters:
            lines [list]: the list of file limnes for removing README text

        Returns:
            [list]: the list of replaced lines in the file

        This function removes sections of the README file that are not
        appropriate to the specified type of project, such as Module/Package or
        CLI/GUI.
    &#34;&#34;&#34;

    # the strategy here is to go through the full README and only copy lines
    # that are 1) not in any block or 2) in the block we want
    # the most efficient way to do this is to have an array that recieves wanted
    # lines, then save that array to a file

    # what type of project are we creating?
    proj_type = dict_settings[&#39;project&#39;][&#39;type&#39;]

    # just a boolean flag to say if we are kajiggering
    # if True, we are in a block we don&#39;t want to copy
    ignore = False

    # NB: we use a new array vs. in-situ replacement here b/c we are removing
    # A LOT OF LINES, which in-situ would result in A LOT OF BLANK LINES and
    # while that would look *ok* in the reulting Markdown, looks UGLY in the
    # source code. so we opt for not copying those lines.

    # where to put the needed lines
    new_lines = []

    # what to ignore in the text
    start_str = DICT_README[&#39;mp&#39;][&#39;start_str&#39;]
    end_str = DICT_README[&#39;mp&#39;][&#39;end_str&#39;]
    ignore_str = DICT_README[&#39;mp&#39;][&#39;ignore_str&#39;]
    if proj_type in &#39;cg&#39;:
        start_str = DICT_README[&#39;cg&#39;][&#39;start_str&#39;]
        end_str = DICT_README[&#39;cg&#39;][&#39;end_str&#39;]
        ignore_str = DICT_README[&#39;cg&#39;][&#39;ignore_str&#39;]

    # for each line
    for line in lines:

        # check if we are in a block
        if start_str in line:
            ignore = True

        # it&#39;s a valid line block, just copy it
        if not ignore:

            # ignore block wrapper lines
            if ignore_str not in line:
                new_lines.append(line)

        # check if we have left the block
        if end_str in line:
            ignore = False

    # return the new set of lines
    return new_lines


# ------------------------------------------------------------------------------
# Function for renaming files/folders
# ------------------------------------------------------------------------------
def _rename(path):
    &#34;&#34;&#34;
        Function for renaming files/folders

        Paramaters:
            path [string]: the path to file/folder for renaming

        This is a function to rename files/folders. Given a path to a
        file/folder, it renames the path by replacing keys in the dict_settings
        keys with their appropriate replacements.
    &#34;&#34;&#34;

    # the array of dunder replacements we will use
    reps = dict_settings[&#39;reps&#39;]

    # store paths before changing
    old_path = path
    new_path = path

    # replace all replacements in path
    for key in reps.keys():
        new_path = new_path.replace(key, reps[key])

    # remove erronious exts
    new_path = _remove_exts(new_path)

    # do the replacement in os (test exists for already renamed)
    if not os.path.exists(new_path):
        os.renames(old_path, new_path)


# ------------------------------------------------------------------------------
# Function for removing extraneous exts (for duplicate files in template)
# ------------------------------------------------------------------------------
def _remove_exts(path):
    &#34;&#34;&#34;
        Function for removing extraneous exts (for duplicate files in template)

        Paramaters:
            path [string]: the path to file/folder for removing exts

        Returns:
            [string]: the file with only the last ext

        This is a function to remove extraneous extensions. Given a path to a
        file/folder, it renames the path by removing extranious extensions.
    &#34;&#34;&#34;

    # split dir/file
    dir_name = os.path.dirname(path)
    base = os.path.basename(path)

    # split file name by dot
    file_array = base.split(&#39;.&#39;)

    # if there is at least one dot
    if len(file_array) &gt; 2:

        # the result is the pre-dot plus last dot
        base = file_array[0] + &#39;.&#39; + file_array[-1]

    return os.path.join(dir_name, base)


# ------------------------------------------------------------------------------
# Code to run when called from command line
# ------------------------------------------------------------------------------
if __name__ == &#39;__main__&#39;:
    &#34;&#34;&#34;
        Code to run when called from command line

        This is the top level code of the program, called when the Python file
        is invoked from the command line.
    &#34;&#34;&#34;

    main()

# -)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="src.pyplate.add_extras"><code class="name flex">
<span>def <span class="ident">add_extras</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Add .git and .venv folders to new project</p>
<p>Adds a .git folder (repository) and a .venv (virtual environment) folder
to the project, and sets them up as necessary.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_extras():
    &#34;&#34;&#34;
        Add .git and .venv folders to new project

        Adds a .git folder (repository) and a .venv (virtual environment) folder
        to the project, and sets them up as necessary.
    &#34;&#34;&#34;

    # make sure we are in current proj path
    dir = dict_settings[&#39;project&#39;][&#39;path&#39;]
    os.chdir(dir)

    # add git folder
    cmd = &#39;git init&#39;
    cmd_array = shlex.split(cmd)
    subprocess.run(cmd_array)

    # add venv dir
    # use &#39;.venv&#39; to be compatible with VSCodium
    cmd = &#39;python -m venv .venv&#39;
    cmd_array = shlex.split(cmd)
    subprocess.run(cmd_array)</code></pre>
</details>
</dd>
<dt id="src.pyplate.copy_template"><code class="name flex">
<span>def <span class="ident">copy_template</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Copy template files to final location</p>
<p>Get file paths/names from dict_settings and copy them to the project
folder.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy_template():
    &#34;&#34;&#34;
        Copy template files to final location

        Get file paths/names from dict_settings and copy them to the project
        folder.
    &#34;&#34;&#34;

    # create target folder
    prj_path = dict_settings[&#39;project&#39;][&#39;path&#39;]
    os.makedirs(prj_path)

    # get project type
    proj_type = dict_settings[&#39;project&#39;][&#39;type&#39;]

    # the group of files, common and type
    groups = [
        DICT_FILES[&#39;common&#39;],
        DICT_FILES[proj_type]
    ]

    # for each group, common and type
    items = [item for group in groups for item in group]
    for item in items:

        # build old path/new path
        path_old = os.path.join(DIR_TEMPLATE, item)
        path_new = os.path.join(prj_path, item)

        # if it&#39;s a dir, copy dir
        if os.path.isdir(path_old):
            shutil.copytree(path_old, path_new)
        else:

            # if it&#39;s a file, get the file&#39;s dir and create
            dir_new = os.path.dirname(path_new)
            os.makedirs(dir_new, exist_ok=True)

            # then copy file
            shutil.copy2(path_old, path_new)

    # write dict_settings to a file in misc
    file_path = os.path.join(prj_path, &#39;misc&#39;, &#39;settings.json&#39;)
    with open(file_path, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f:
        dict_str = json.dumps(dict_settings, indent=4)
        f.write(dict_str)</code></pre>
</details>
</dd>
<dt id="src.pyplate.get_project_info"><code class="name flex">
<span>def <span class="ident">get_project_info</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Get project info</p>
<p>Asks the user for project info, such as type and name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_project_info():
    &#34;&#34;&#34;
        Get project info

        Asks the user for project info, such as type and name.
    &#34;&#34;&#34;

    # the settings dict (global b/c we will modify here)
    global dict_settings

    # loop forever until we get a valid type
    while True:

        # ask what type of project
        prj_type = input(
            &#39;Project type: [m]odule | [p]ackage | [c]li | [g]ui: &#39;
        )

        # check project type
        pattern = r&#39;(^(m|p|c|g{1})$)&#39;
        res = re.search(pattern, prj_type, re.I)
        if res:

            # we got a valid type
            prj_type = prj_type.lower()
            dict_settings[&#39;project&#39;][&#39;type&#39;] = prj_type
            break

    # configure subdir
    type_dir = &#39;&#39;
    if prj_type in &#39;mp&#39;:
        type_dir = &#39;Libs&#39;
    else:
        type_dir = &#39;Apps&#39;

    # loop forever until we get a valid name and path
    while True:

        # ask for project name
        prj_name_big = input(&#39;Project name: &#39;)

        # check for valid name
        if not _validate_name(prj_name_big):
            continue

        # calculate final proj location
        prj_path = os.path.join(DIR_BASE, type_dir, prj_name_big)

        # check if project already exists
        if os.path.exists(prj_path):
            print(f&#39;Project {prj_path} already exists&#39;)
            continue

        # if name is valid, move on
        dict_settings[&#39;reps&#39;][&#39;__PP_NAME_BIG__&#39;] = prj_name_big
        dict_settings[&#39;project&#39;][&#39;path&#39;] = prj_path
        break

    # calculate small name
    prj_name_small = prj_name_big.lower()
    dict_settings[&#39;reps&#39;][&#39;__PP_NAME_SMALL__&#39;] = prj_name_small

    # calculate current date
    prj_date = datetime.now().strftime(&#39;%m/%d/%Y&#39;)
    dict_settings[&#39;reps&#39;][&#39;__PP_DATE__&#39;] = prj_date</code></pre>
</details>
</dd>
<dt id="src.pyplate.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Main function</p>
<p>This is the main function, which calls each step in the process of
creating a project.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main():
    &#34;&#34;&#34;
        Main function

        This is the main function, which calls each step in the process of
        creating a project.
    &#34;&#34;&#34;

    # call each step
    get_project_info()
    copy_template()

    path = dict_settings[&#39;project&#39;][&#39;path&#39;]
    recurse(path)

    add_extras()</code></pre>
</details>
</dd>
<dt id="src.pyplate.recurse"><code class="name flex">
<span>def <span class="ident">recurse</span></span>(<span>path)</span>
</code></dt>
<dd>
<div class="desc"><p>Recursivly scan files/folders for replace/rename functions</p>
<h2 id="paramaters">Paramaters</h2>
<p>path [string]: the folder to start recursively scanning from</p>
<p>This is a recursive function to scan for files/folders under a given
folder. It iterates over the contents of the 'path' folder, checking if
each item is a file or a folder. If it encounters a folder, it calls
itself recursively, passing that folder as the parameter. If it
encounters a file, it calls methods to do text replacement of headers,
then other text. Finally it renames the file if the name contains a
replacement key. Once all files are renamed, it will then bubble up to
rename all folders.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recurse(path):
    &#34;&#34;&#34;
        Recursivly scan files/folders for replace/rename functions

        Paramaters:
            path [string]: the folder to start recursively scanning from

        This is a recursive function to scan for files/folders under a given
        folder. It iterates over the contents of the &#39;path&#39; folder, checking if
        each item is a file or a folder. If it encounters a folder, it calls
        itself recursively, passing that folder as the parameter. If it
        encounters a file, it calls methods to do text replacement of headers,
        then other text. Finally it renames the file if the name contains a
        replacement key. Once all files are renamed, it will then bubble up to
        rename all folders.
    &#34;&#34;&#34;

    # get list of file names in dest dir
    items = [item for item in os.listdir(path)]
    for item in items:

        # put path back together
        path_item = os.path.join(path, item)

        # if it&#39;s a dir
        if os.path.isdir(path_item):

            # recurse itself to find more files
            recurse(path_item)

        else:

            # open file and get lines
            with open(path_item, &#39;r&#39;, encoding=&#39;utf-8&#39;) as f:
                lines = f.readlines()

            # replace headers from lines
            lines = _replace_headers(lines)

            # replace text from lines (skipping text in certain files in misc)
            if (
                item != &#39;metadata.py&#39; and
                item != &#39;settings.json&#39;
            ):
                lines = _replace_text(lines)

            # readme needs extra handling (if it is not excluded anywhere else)
            if item == &#39;README.md&#39;:
                lines = _fix_readme(lines)

            # save lines
            with open(path_item, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f:
                f.writelines(lines)

        # called for each file/folder
        _rename(path_item)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src" href="index.html">src</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="src.pyplate.add_extras" href="#src.pyplate.add_extras">add_extras</a></code></li>
<li><code><a title="src.pyplate.copy_template" href="#src.pyplate.copy_template">copy_template</a></code></li>
<li><code><a title="src.pyplate.get_project_info" href="#src.pyplate.get_project_info">get_project_info</a></code></li>
<li><code><a title="src.pyplate.main" href="#src.pyplate.main">main</a></code></li>
<li><code><a title="src.pyplate.recurse" href="#src.pyplate.recurse">recurse</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>