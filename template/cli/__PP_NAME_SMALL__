#! /usr/bin/env python
# ------------------------------------------------------------------------------
# Project : __PP_NAME_BIG__                                        /          \
# Filename: __PP_NAME_SMALL__                                     |     ()     |
# Date    : __PP_DATE__                                           |            |
# Author  : __PP_AUTHOR__                                         |   \____/   |
# License : __PP_LICENSE_NAME__                                    \          /
# ------------------------------------------------------------------------------

"""
The main file that runs the program

This file is executable and can be called from the terminal like:

foo@bar:~$ cd [path to directory of this file]
foo@bar:~[path to directory of this file]$ ./__PP_NAME_SMALL__ [cmd line]

or if installed in a global location:

foo@bar:~$ __PP_NAME_SMALL__ [cmd line]

Typical usage is show in the main() function.
"""

# ------------------------------------------------------------------------------
# Imports
# ------------------------------------------------------------------------------

# system imports
import argparse
import json
from pathlib import Path

# ------------------------------------------------------------------------------
# Constants
# ------------------------------------------------------------------------------

# get path to default config file
# NB: this path is read-only
C_CFG_PATH_DEF = Path.home() / ".config/__PP_NAME_SMALL__/default.json"

# the default config dict
C_CFG_DICT = {}

# ------------------------------------------------------------------------------
# Globals
# ------------------------------------------------------------------------------

# ------------------------------------------------------------------------------
# Strings
# ------------------------------------------------------------------------------

# version string for -h/-v option
S_HELP_VERSION = (
    "__PP_NAME_SMALL__\n"
    "__PP_SHORT_DESC__\n"
    "__PP_VERSION__\n"
    "__PP_EMAIL__"
)

# version option strings
S_VER_OPTION = "v"
S_VER_OPTION_LONG = "version"
S_VER_ACTION = "version"
S_VER_VERSION = S_HELP_VERSION

# config option strings
S_CFG_OPTION = "c"
S_CFG_OPTION_LONG = "config-file"
S_CFG_DEST = "CFG_DEST"
S_CFG_HELP = "load configuration from file"
S_CFG_METAVAR = "FILE"

# config debug gui strings
S_DBG_OPTION = "d"
S_DBG_OPTION_LONG = "debug"
S_DBG_ACTION = "store_true"
S_DBG_DEST = "DBG_DEST"
S_DBG_HELP = "enable debugging option"


# config load/save error strings
S_CFG_ERR_EXIST = "load config: config file '{}' does not exist"
S_CFG_ERR_VALID = "load config: config file '{}' is not a valid JSON file"
S_CFG_ERR_CREATE = "save config: config file '{}' could not be created"

# ------------------------------------------------------------------------------
# Public classes
# ------------------------------------------------------------------------------


# ------------------------------------------------------------------------------
# The main class, responsible for the operation of the program
# ------------------------------------------------------------------------------
class __PP_NAME_BIG__:
    """
    The main class, responsible for the operation of the program

    Public functions:
        main: The main function of the program

    This object does the all the work of a typical CLI program. It parses
    command line options, loads/saves config files, and performs the operations
    required for the program.
    """

    # --------------------------------------------------------------------------
    # Class functions
    # --------------------------------------------------------------------------

    # --------------------------------------------------------------------------
    # Initialize the new object
    # --------------------------------------------------------------------------
    def __init__(self):
        """
        Initialize the new object

        Initializes a new instance of the class, setting the default values
        of its properties, and any other code that needs to run to create a
        new object.
        """

        # set defaults
        self._args = argparse.Namespace()
        self._path_config = None
        self._dict_cfg = C_CFG_DICT

    # --------------------------------------------------------------------------
    # Public functions
    # --------------------------------------------------------------------------

    # --------------------------------------------------------------------------
    # The main function of the program
    # --------------------------------------------------------------------------
    def main(self):
        """
        The main function of the program

        This function is the main entry point for the program, initializing the
        program, and performing its steps.
        """

        # ----------------------------------------------------------------------
        # steps

        # do parser setup
        self._setup_parser()

        # load config
        self._load_config()

        # call the steps in order
        print(self.func())

        # save config dict to passed in file, NOT def, or LOSE built-in
        self._save_dict(self._path_config, self._dict_cfg)

    # --------------------------------------------------------------------------
    # Short description
    # --------------------------------------------------------------------------
    def func(self):
        """
        Short description

        Arguments:
            var_name: Description

        Returns:
            Description

        Raises:
            exception_type(vars): Description

        Long description (including HTML).
        """

        return "this is func"

    # --------------------------------------------------------------------------
    # Private functions
    # --------------------------------------------------------------------------

    # --------------------------------------------------------------------------
    # Sets up the command line parser
    # --------------------------------------------------------------------------
    def _setup_parser(self):
        """
        Sets up the command line parser

        This function sets up the command line parser to minimize code in
        main(). 
        """

        # create the command line parser
        parser = argparse.ArgumentParser(
            # use the string constant for help/version and the custom formatter
            # class
            description=S_HELP_VERSION,
            formatter_class=_MyFormatter,
        )

        # call the _add_args function to add args (teased out for easier code
        # maintenance)
        self._add_args(parser)

        # get namespace object
        self._args = parser.parse_args()

    # --------------------------------------------------------------------------
    # Loads config file from several sources
    # --------------------------------------------------------------------------
    def _load_config(self):
        """
        Loads config file from several sources

        This function loads config files from several sources, and is teased
        out to simplify the code in main().
        """

        # load config dict from file, def, or just keep built-in
        # Order of precedence is:
        # 1. The file passed to the command-line stored in CFG_DEST
        # 2. The file set in the C_CFG_PATH_DEF constant
        # If neither of the above files are valid, the dict_config dictionary
        # will remain unchanged.

        # load from default
        paths_load = [C_CFG_PATH_DEF]

        # if arg is present
        arg_config = self._args.CFG_DEST
        if arg_config is not None:

            # convert to path
            self._path_config = Path(arg_config)

            # add to load list
            paths_load.append(self._path_config)

        # load dict(s) from path(s)
        self._dict_cfg = self._load_dicts(paths_load, self._dict_cfg)

    # --------------------------------------------------------------------------
    # Add arguments to argparse parser
    # --------------------------------------------------------------------------
    def _add_args(self, parser):
        """
        Add arguments to argparse parser

        Arguments:
            parser: the parser to add arguments to

        This function is teased out for better code maintenance.
        """

        # add version option
        parser.add_argument(
            f"-{S_VER_OPTION}",
            f"--{S_VER_OPTION_LONG}",
            action=S_VER_ACTION,
            version=S_VER_VERSION,
        )

        # add config (user dict) option
        parser.add_argument(
            f"-{S_CFG_OPTION}",
            f"--{S_CFG_OPTION_LONG}",
            dest=S_CFG_DEST,
            help=S_CFG_HELP,
            metavar=S_CFG_METAVAR,
        )

        # add debug option
        parser.add_argument(
            f"-{S_DBG_OPTION}",
            f"--{S_DBG_OPTION_LONG}",
            action=S_DBG_ACTION,
            dest=S_DBG_DEST,
            help=S_DBG_HELP,
        )

    # --------------------------------------------------------------------------
    # Loads dictionaries from all found paths, combining each in order
    # --------------------------------------------------------------------------
    def _load_dicts(self, paths, dict_start=None):
        """
        Loads dictionaries from all found paths, combining each in order

        Arguments:
            paths: the list of file paths to load from
            dict_start: the final dict that will be returned after combining

        Returns:
            the combination of dict_start and all loaded dicts in paths

        Raises:
            FileNotFoundError: If the file does not exist
            json.JSONDecodeError: If the file is not a valid JSON file

        Load the dictionaries from all files at all found locations, and
        combine them.
        """

        # set the default result
        if dict_start is None:
            dict_start = {}

        # loop through possible files
        for path in paths:

            # sanity check
            if path is None:
                if self._args.DBG_DEST:
                    print(S_CFG_ERR_EXIST.format(path))
                continue

            # try each option
            try:

                # make sure path is absolute
                if not path.is_absolute:
                    if self._args.DBG_DEST:
                        print(S_CFG_ERR_EXIST.format(path))
                    continue

                # open the file
                with open(path, "r", encoding="UTF-8") as a_file:
                    # load dict from file
                    temp_dict = json.load(a_file)

                    # debug
                    if self._args.DBG_DEST:
                        print("load:", temp_dict)
                        print("from:", path)

                # combine new dict with previous
                dict_start = self._combine_dicts(dict_start, temp_dict)

            # file not found
            except FileNotFoundError:
                if self._args.DBG_DEST:
                    print(S_CFG_ERR_EXIST.format(path))

            # file mot JSON
            except json.JSONDecodeError:
                if self._args.DBG_DEST:
                    print(S_CFG_ERR_VALID.format(path))

        # debug
        if self._args.DBG_DEST:
            print("final cfg:", dict_start)

        # return result
        return dict_start

    # --------------------------------------------------------------------------
    # Saves a dictionary to a path
    # --------------------------------------------------------------------------
    def _save_dict(self, path, dict_):
        """
        Saves a dictionary to a path

        Arguments:
            path: the file path to save to
            dict_: the dictionary to save to the file

        Raises:
            Exception: If the file does not exist and can't be created

        Save the dictionary to a file at the specified location.
        """

        # sanity check
        if path is None:
            if self._args.DBG_DEST:
                print(S_CFG_ERR_EXIST.format(path))
            return

        # try path
        try:

            # make sure path is absolute
            if not path.is_absolute():
                if self._args.DBG_DEST:
                    print(S_CFG_ERR_CREATE.format(path))
                return

            # first make dirs
            path.parent.mkdir(parents=True, exist_ok=True)

            # open the file
            with open(path, "w", encoding="UTF-8") as a_file:
                # save dict tp file
                json.dump(dict_, a_file, indent=4)

                # debug
                if self._args.DBG_DEST:
                    print("save:", dict_)
                    print("to:", path)

        # raise an OS Error
        except OSError:
            if self._args.DBG_DEST:
                print(S_CFG_ERR_CREATE.format(path))

    # --------------------------------------------------------------------------
    # Updates a dictionary with new values and missing key/value pairs from a
    # second dictionary
    # --------------------------------------------------------------------------
    def _combine_dicts(self, dict_old, dict_new):
        """
        Updates a dictionary with new values and missing key/value pairs from a
        second dictionary

        Arguments:
            dict_old: The dictionary defined as the one to receive updates
            dict_new: The dictionary containing new keys/values to be updated
            in the old dictionary

        Returns:
            The updated dict_old, filled with updates from dict_new

        This function takes keys/values from dict_new and adds/overwrites these
        keys and values in dict_old.
        """

        # for each k,v pair in dict_new
        for k, v in dict_new.items():
            # copy whole value if key is missing
            if not k in dict_old:
                dict_old[k] = v

            # if the key is present in both
            else:
                # if the value is a dict
                if isinstance(v, dict):
                    # start recursing
                    # recurse using the current key and value
                    dict_old[k] = self._combine_dicts(dict_old[k], v)

                # if the value is not a dict
                else:
                    # just copy value from one dict to the other
                    dict_old[k] = v

        # return the updated dict_old
        return dict_old


# ------------------------------------------------------------------------------
# Private classes
# ------------------------------------------------------------------------------


# ------------------------------------------------------------------------------
# A dummy class to combine multiple argparse formatters
# ------------------------------------------------------------------------------
class _MyFormatter(
    argparse.RawTextHelpFormatter, argparse.RawDescriptionHelpFormatter
):
    """
    A dummy class to combine multiple argparse formatters

    Arguments:
        RawTextHelpFormatter: Maintains whitespace for all sorts of help text,
        including argument descriptions.
        RawDescriptionHelpFormatter: Indicates that description and epilog are
        already correctly formatted and should not be line-wrapped.

    A dummy class to combine multiple argparse formatters.
    """


# ------------------------------------------------------------------------------
# Code to run when called from command line
# ------------------------------------------------------------------------------
if __name__ == "__main__":
    # Code to run when called from command line

    # This is the top level code of the program, called when the Python file is
    # invoked from the command line.

    # create a new instance of the main class
    inst = __PP_NAME_BIG__()

    # run main function
    inst.main()

# -)
