#! /usr/bin/env python
# ------------------------------------------------------------------------------
# Project : PyPlate                                                /          \
# Filename: pybaker.py                                            |     ()     |
# Date    : 12/08/2022                                            |            |
# Author  : cyclopticnerve                                        |   \____/   |
# License : WTFPLv2                                                \          /
# ------------------------------------------------------------------------------

"""
A program to set the metadata of a PyPlate project and create a dist

This module sets the project metadata in each of the files, according to the
data present in the conf files. It then sets up the dist folder with all
necessary files to create a complete distribution of the project.
"""

# TODO: replace all PB_VERSION with new version, across all files in prj dir


# TODO: fix every metadata using choice menu for new value
# gonna need a lot of regex in pybaker.conf
# TODO: do we need D_PRJ_DEF/D_PRJ_EXTRA?
# TODO: what do we need from D_PRJ_CFG? just __PP_DEV_PP__?

# TODO: pybaker
# Y ask for ver or default
# Y update meta
# Y ask for desc or default
# Y update meta
# replace ver and desc in all files (dunder)
# replace ver and desc in all files (context)
# check for dunders
# make install.py
# make dist

# TODO: pybaker not rely so much on regex, more on context start/end

# ------------------------------------------------------------------------------

# TODO: pull in a fresh copy of libs on every run and put it in dist
# we need to get the location of PyPlate from settings (src)
# we need the name of the "lib" folder from settings (dst)
# TODO: any time pybaker encounters a file with __PP_DATE__ still in the
# header, make sure to use today's date, not the one stored in a config dict
# TODO: install script must install libs, src, etc. into proper folders
# TODO: installer for pkg should move pkg to __PP_USER_LIB__

# ------------------------------------------------------------------------------
# Imports
# ------------------------------------------------------------------------------

# system imports
import argparse
import json
import os
from pathlib import Path
import re
import shlex
import subprocess
import sys

# pylint: disable=wrong-import-position
# pylint: disable=wrong-import-order
# pylint: disable=no-name-in-module
# pylint: disable=import-error

# my imports
# add custom import paths

# path to this project
# parent is src, parents[1] is PyPlate
# NB: needed to get imports from conf (bootstrap)
P_DIR_PYPLATE = Path(__file__).parents[1].resolve()
P_DIR_PP_LIB = P_DIR_PYPLATE / "lib"
sys.path.append(str(P_DIR_PYPLATE))
sys.path.append(str(P_DIR_PP_LIB))

# local imports
from conf import pybaker_conf as B  # type:ignore
from conf import pymaker_conf as M  # type:ignore
from cnlib import cnfunctions as F  # type: ignore
from cnlib.cnformatter import CNFormatter  # type: ignore
from cnlib.cnpot import CNPotPy  # type: ignore
from cnlib.cntree import CNTree  # type: ignore

# pylint: enable=wrong-import-position
# pylint: enable=wrong-import-order
# pylint: enable=no-name-in-module
# pylint: enable=import-error

# ------------------------------------------------------------------------------
# Strings
# ------------------------------------------------------------------------------

# ------------------------------------------------------------------------------
# this is our metadata bootstrap

# get names
S_PP_NAME_BIG = "PyBaker"
S_PP_NAME_SMALL = "pybaker"
S_PP_SHORT_DESC = (
    "A program to set the metadata of a PyPlate project and create a dist"
)

# formatted version
S_PP_VER_FMT = f"Version {B.S_VERSION}"

# about string
S_PP_ABOUT = (
    f"{S_PP_NAME_SMALL}\n"
    f"{S_PP_SHORT_DESC}\n"
    f"{S_PP_VER_FMT}\n"
    f"https://www.github.com/cyclopticnerve/{S_PP_NAME_BIG}"
)

# debug option strings
S_DBG_OPTION = "-d"
S_DBG_ACTION = "store_true"
S_DBG_DEST = "DBG_DEST"
S_DBG_HELP = "enable debugging option"

# folder option strings
S_PRJ_OPTION = "-f"
S_PRJ_METAVAR = "PROJECT DIR"
S_PRJ_DEST = "PRJ_DEST"
S_PRJ_HELP = "the project directory to bake"

# ------------------------------------------------------------------------------
# other strings

# shorten sep
S = os.sep

# path to prj pyplate files
S_PP_PRV = f"pyplate{S}conf{S}private.json"
S_PP_PRJ = f"pyplate{S}conf{S}project.json"

# ------------------------------------------------------------------------------
# Public classes
# ------------------------------------------------------------------------------


# ------------------------------------------------------------------------------
# The main class, responsible for the operation of the program
# ------------------------------------------------------------------------------
class PyBaker:
    """
    The main class, responsible for the operation of the program

    Public methods:
        main: The main method of the program

    This class implements all the needed functionality of PyBaker, to create a
    distribution of a project from a settings file.
    """

    # --------------------------------------------------------------------------
    # Class methods
    # --------------------------------------------------------------------------

    # --------------------------------------------------------------------------
    # Initialize the new object
    # --------------------------------------------------------------------------
    def __init__(self):
        """
        Initialize the new object

        Initializes a new instance of the class, setting the default values
        of its properties, and any other code that needs to run to create a
        new object.
        """

        # set the initial values of properties
        self._d_args = {}
        self._debug = False
        self._dict_rep = {}
        self._dir_prj = Path()
        self._version = ""
        self._d_blacklist = {}  # project.json
        self._d_i18n = {}  # project.json
        self._d_metadata = {}  # project.json
        self._d_settings = {}  # private.json
        self._error_count = 0

    # --------------------------------------------------------------------------
    # Public methods
    # --------------------------------------------------------------------------

    # --------------------------------------------------------------------------
    # The main method of the program
    # --------------------------------------------------------------------------
    def main(self):
        """
        The main method of the program

        This method is the main entry point for the program, initializing the
        program, and performing its steps.
        """

        # ----------------------------------------------------------------------
        #  do the work

        # call boilerplate code
        self._setup()

        # load the config files
        if not self._debug:
            self.load_config_files()

        # ask for version number
        self._get_version()

        # replace all dunders ala pymaker
        # self._fix_version()
        self._fix_toml()

        self._fix_src()
        # fix_blacklist()
        # fix_readme()

        # # pkg
        # fix_pyproject()
        # # fix_init()

        # # cli/gui
        # fix_argparse()
        # fix_install()

        # # gui
        # fix_desktop()
        # fix_gtk3()

        # # check for dunders left over or we missed
        # recurse_and_check(_DIR_PRJ)

        # # do housekeeping
        # do_extras()

        # # do gettext stuff
        # # do_gettext()

        # # # print error count (dunder stuff found)
        # s = G_STRINGS["S_ERR_COUNT"]
        # print(s.format(G_ERROR_COUNT))

    # --------------------------------------------------------------------------
    # Private methods
    # --------------------------------------------------------------------------

    # NB: these are the main steps, called in order from main

    # --------------------------------------------------------------------------
    # Boilerplate to use at the start of main
    # --------------------------------------------------------------------------
    def _setup(self):
        """
        Boilerplate to use at the start of main

        Perform some mundane stuff like running the arg parser and loading
        config files.
        """

        # ----------------------------------------------------------------------
        # set pp cmd line stuff

        # get cmd line args
        dict_args = self._run_parser()

        # check for flags
        self._debug = dict_args[S_DBG_DEST]

        # check for folder
        if self._debug:
            self._dir_prj = (
                Path.home() / "Documents/Projects/Python/CLIs/CLIs_DEBUG"
            )
        else:
            self._dir_prj = Path(dict_args[S_PRJ_DEST])

    # --------------------------------------------------------------------------
    # Load the required config files
    # --------------------------------------------------------------------------
    def load_config_files(self):
        """
        Load the required config files

        Get required config files and load them into the dictionaries required
        by the program. These files may sometimes be edited by users, so we
        need to check that they:
        (1. exist)
        and
        (2. are valid JSON).
        Both of these are handled by F.load_dicts.
        """

        # TODO use dunders here
        # get individual dicts in the project file
        path_to_conf = self._dir_prj / "pyplate" / "conf" / "project.json"
        dict_all = F.load_dicts([path_to_conf], {})
        self._d_blacklist = dict_all["BLACKLIST"]
        self._d_i18n = dict_all["I18N"]
        self._d_metadata = dict_all["META"]

        # get main dict in private.json
        path_to_conf = self._dir_prj / "pyplate" / "conf" / "private.json"
        self._d_settings = F.load_dicts([path_to_conf], {})

    # --------------------------------------------------------------------------
    # NB: these are minor steps called from the main steps

    # --------------------------------------------------------------------------
    # Set up and run the command line parser
    # --------------------------------------------------------------------------
    def _run_parser(self):
        """
        Set up and run the command line parser

        Returns: A dictionary of command line arguments

        This method sets up and runs the command line parser to minimize code
        in the main method.
        """

        # create the command line parser
        parser = argparse.ArgumentParser(formatter_class=CNFormatter)

        # add args
        self._add_args(parser)

        # get namespace object
        args = parser.parse_args()

        # convert namespace to dict
        self._d_args = vars(args)

        return self._d_args

    # --------------------------------------------------------------------------
    # Add arguments to argparse parser
    # --------------------------------------------------------------------------
    def _add_args(self, parser):
        """
        Add arguments to argparse parser

        Arguments:
            parser: The parser for which to add arguments

        This method is teased out for better code maintenance.
        """

        # set help string
        parser.description = S_PP_ABOUT

        # add debug option
        parser.add_argument(
            S_DBG_OPTION,
            action=S_DBG_ACTION,
            dest=S_DBG_DEST,
            help=S_DBG_HELP,
        )

        # add project dir
        parser.add_argument(
            S_PRJ_OPTION,
            metavar=S_PRJ_METAVAR,
            dest=S_PRJ_DEST,
            help=S_PRJ_HELP,
        )


# ------------------------------------------------------------------------------
# Code to run when called from command line
# ------------------------------------------------------------------------------
if __name__ == "__main__":
    # Code to run when called from command line

    # This is the top level code of the program, called when the Python file is
    # invoked from the command line.

    # run main method
    pb = PyBaker()
    pb.main()
