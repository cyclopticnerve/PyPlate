{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Coming soon","title":"Home"},{"location":"API/bin/pybaker/","text":"pybaker.py The main file that runs the program This file is executable and can be called from the terminal like: foo@bar:~$ pybaker [cmd line] when placed in a folder that is in the default $PATH, ie: /usr/bin ~/.local/bin etc. All command line options will be passed to the main class, usually located at ~/.local/share/pyplate/src/pybaker.py. Typical usage is show in the main() method. PyBaker The entry point class, responsible for launching the program Public methods main: The main method of the program This class starts the program from the command line when it is installed in directories that are defined in the $PATH variable. These are places like /usr/bin, ~/.local/bin, etc. and can be called from the command line regardless of the current working directory. It is basically a \"bootstrap\" file, activating the venv and calling the main program. Source code in bin/pybaker.py class PyBaker: \"\"\" The entry point class, responsible for launching the program Public methods: main: The main method of the program This class starts the program from the command line when it is installed in directories that are defined in the $PATH variable. These are places like /usr/bin, ~/.local/bin, etc. and can be called from the command line regardless of the current working directory. It is basically a \"bootstrap\" file, activating the venv and calling the main program. \"\"\" # -------------------------------------------------------------------------- # Class constants # -------------------------------------------------------------------------- # find path to prj/lib P_DIR_PP = f\"{Path.home()}/.local/share/pyplate\" # commands to run S_CMD_ACTIVATE = f\". {P_DIR_PP}/.venv-pyplate/bin/activate\" S_CMD_RUN = f\"{P_DIR_PP}/src/pybaker.py\" S_CMD_RUN_ARGS = \"{} {}\" # -------------------------------------------------------------------------- # Public methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # The main method of the program # -------------------------------------------------------------------------- def main(self): \"\"\" The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. It then calls the real main module, located in the install dir. \"\"\" # ---------------------------------------------------------------------- # save project path to return after venv activate start_dir = Path.cwd() # get args args = sys.argv # remove our path args = args[1:] # quote any args with spaces args = [f'\"{item}\"' if \" \" in item else item for item in args] # put args back together with spaces args = \" \".join(args) # def cmd line - no args src_run = self.S_CMD_RUN # add args if present if len(args) > 0: src_run = self.S_CMD_RUN_ARGS.format(self.S_CMD_RUN, args) # ---------------------------------------------------------------------- # build cmd cmd = ( # cd to inst f\"cd {self.P_DIR_PP};\" # activate venv f\"{self.S_CMD_ACTIVATE};\" # get back to start dir (where we were called) f\"cd {start_dir};\" # call src w/ args f\"{src_run}\" ) # run cmd try: subprocess.run(cmd, shell=True, check=True) except subprocess.CalledProcessError: print(\"error\") main() The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. It then calls the real main module, located in the install dir. Source code in bin/pybaker.py def main(self): \"\"\" The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. It then calls the real main module, located in the install dir. \"\"\" # ---------------------------------------------------------------------- # save project path to return after venv activate start_dir = Path.cwd() # get args args = sys.argv # remove our path args = args[1:] # quote any args with spaces args = [f'\"{item}\"' if \" \" in item else item for item in args] # put args back together with spaces args = \" \".join(args) # def cmd line - no args src_run = self.S_CMD_RUN # add args if present if len(args) > 0: src_run = self.S_CMD_RUN_ARGS.format(self.S_CMD_RUN, args) # ---------------------------------------------------------------------- # build cmd cmd = ( # cd to inst f\"cd {self.P_DIR_PP};\" # activate venv f\"{self.S_CMD_ACTIVATE};\" # get back to start dir (where we were called) f\"cd {start_dir};\" # call src w/ args f\"{src_run}\" ) # run cmd try: subprocess.run(cmd, shell=True, check=True) except subprocess.CalledProcessError: print(\"error\")","title":"pybaker.py"},{"location":"API/bin/pybaker/#pybakerpy","text":"The main file that runs the program This file is executable and can be called from the terminal like: foo@bar:~$ pybaker [cmd line] when placed in a folder that is in the default $PATH, ie: /usr/bin ~/.local/bin etc. All command line options will be passed to the main class, usually located at ~/.local/share/pyplate/src/pybaker.py. Typical usage is show in the main() method.","title":"pybaker.py"},{"location":"API/bin/pybaker/#bin.pybaker.PyBaker","text":"The entry point class, responsible for launching the program Public methods main: The main method of the program This class starts the program from the command line when it is installed in directories that are defined in the $PATH variable. These are places like /usr/bin, ~/.local/bin, etc. and can be called from the command line regardless of the current working directory. It is basically a \"bootstrap\" file, activating the venv and calling the main program. Source code in bin/pybaker.py class PyBaker: \"\"\" The entry point class, responsible for launching the program Public methods: main: The main method of the program This class starts the program from the command line when it is installed in directories that are defined in the $PATH variable. These are places like /usr/bin, ~/.local/bin, etc. and can be called from the command line regardless of the current working directory. It is basically a \"bootstrap\" file, activating the venv and calling the main program. \"\"\" # -------------------------------------------------------------------------- # Class constants # -------------------------------------------------------------------------- # find path to prj/lib P_DIR_PP = f\"{Path.home()}/.local/share/pyplate\" # commands to run S_CMD_ACTIVATE = f\". {P_DIR_PP}/.venv-pyplate/bin/activate\" S_CMD_RUN = f\"{P_DIR_PP}/src/pybaker.py\" S_CMD_RUN_ARGS = \"{} {}\" # -------------------------------------------------------------------------- # Public methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # The main method of the program # -------------------------------------------------------------------------- def main(self): \"\"\" The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. It then calls the real main module, located in the install dir. \"\"\" # ---------------------------------------------------------------------- # save project path to return after venv activate start_dir = Path.cwd() # get args args = sys.argv # remove our path args = args[1:] # quote any args with spaces args = [f'\"{item}\"' if \" \" in item else item for item in args] # put args back together with spaces args = \" \".join(args) # def cmd line - no args src_run = self.S_CMD_RUN # add args if present if len(args) > 0: src_run = self.S_CMD_RUN_ARGS.format(self.S_CMD_RUN, args) # ---------------------------------------------------------------------- # build cmd cmd = ( # cd to inst f\"cd {self.P_DIR_PP};\" # activate venv f\"{self.S_CMD_ACTIVATE};\" # get back to start dir (where we were called) f\"cd {start_dir};\" # call src w/ args f\"{src_run}\" ) # run cmd try: subprocess.run(cmd, shell=True, check=True) except subprocess.CalledProcessError: print(\"error\")","title":"PyBaker"},{"location":"API/bin/pybaker/#bin.pybaker.PyBaker.main","text":"The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. It then calls the real main module, located in the install dir. Source code in bin/pybaker.py def main(self): \"\"\" The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. It then calls the real main module, located in the install dir. \"\"\" # ---------------------------------------------------------------------- # save project path to return after venv activate start_dir = Path.cwd() # get args args = sys.argv # remove our path args = args[1:] # quote any args with spaces args = [f'\"{item}\"' if \" \" in item else item for item in args] # put args back together with spaces args = \" \".join(args) # def cmd line - no args src_run = self.S_CMD_RUN # add args if present if len(args) > 0: src_run = self.S_CMD_RUN_ARGS.format(self.S_CMD_RUN, args) # ---------------------------------------------------------------------- # build cmd cmd = ( # cd to inst f\"cd {self.P_DIR_PP};\" # activate venv f\"{self.S_CMD_ACTIVATE};\" # get back to start dir (where we were called) f\"cd {start_dir};\" # call src w/ args f\"{src_run}\" ) # run cmd try: subprocess.run(cmd, shell=True, check=True) except subprocess.CalledProcessError: print(\"error\")","title":"main"},{"location":"API/bin/pymaker/","text":"pymaker.py The main file that runs the program This file is executable and can be called from the terminal like: foo@bar:~$ pymaker [cmd line] when placed in a folder that is in the default $PATH, ie: /usr/bin ~/.local/bin etc. All command line options will be passed to the main class, usually located at ~/.local/share/pyplate/src/pymaker.py. Typical usage is show in the main() method. PyMaker The entry point class, responsible for launching the program Public methods main: The main method of the program This class starts the program from the command line when it is installed in directories that are defined in the $PATH variable. These are places like /usr/bin, ~/.local/bin, etc. and can be called from the command line regardless of the current working directory. It is basically a \"bootstrap\" file, activating the venv and calling the main program. Source code in bin/pymaker.py class PyMaker: \"\"\" The entry point class, responsible for launching the program Public methods: main: The main method of the program This class starts the program from the command line when it is installed in directories that are defined in the $PATH variable. These are places like /usr/bin, ~/.local/bin, etc. and can be called from the command line regardless of the current working directory. It is basically a \"bootstrap\" file, activating the venv and calling the main program. \"\"\" # -------------------------------------------------------------------------- # Class constants # -------------------------------------------------------------------------- # find path to prj/lib P_DIR_PP = f\"{Path.home()}/.local/share/pyplate\" # commands to run S_CMD_ACTIVATE = f\". {P_DIR_PP}/.venv-pyplate/bin/activate\" S_CMD_RUN = f\"{P_DIR_PP}/src/pymaker.py\" S_CMD_RUN_ARGS = \"{} {}\" # -------------------------------------------------------------------------- # Public methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # The main method of the program # -------------------------------------------------------------------------- def main(self): \"\"\" The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. It then calls the real main module, located in the install dir. \"\"\" # ---------------------------------------------------------------------- # save project path to return after venv activate start_dir = Path.cwd() # get args args = sys.argv # remove our path args = args[1:] # quote any args with spaces args = [f'\"{item}\"' if \" \" in item else item for item in args] # put args back together with spaces args = \" \".join(args) # def cmd line - no args src_run = self.S_CMD_RUN # add args if present if len(args) > 0: src_run = self.S_CMD_RUN_ARGS.format(self.S_CMD_RUN, args) # ---------------------------------------------------------------------- # build cmd cmd = ( # cd to inst f\"cd {self.P_DIR_PP};\" # activate venv f\"{self.S_CMD_ACTIVATE};\" # get back to start dir (where we were called) f\"cd {start_dir};\" # call src w/ args f\"{src_run}\" ) # run cmd try: subprocess.run(cmd, shell=True, check=True) except subprocess.CalledProcessError: print(\"error\") main() The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. It then calls the real main module, located in the install dir. Source code in bin/pymaker.py def main(self): \"\"\" The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. It then calls the real main module, located in the install dir. \"\"\" # ---------------------------------------------------------------------- # save project path to return after venv activate start_dir = Path.cwd() # get args args = sys.argv # remove our path args = args[1:] # quote any args with spaces args = [f'\"{item}\"' if \" \" in item else item for item in args] # put args back together with spaces args = \" \".join(args) # def cmd line - no args src_run = self.S_CMD_RUN # add args if present if len(args) > 0: src_run = self.S_CMD_RUN_ARGS.format(self.S_CMD_RUN, args) # ---------------------------------------------------------------------- # build cmd cmd = ( # cd to inst f\"cd {self.P_DIR_PP};\" # activate venv f\"{self.S_CMD_ACTIVATE};\" # get back to start dir (where we were called) f\"cd {start_dir};\" # call src w/ args f\"{src_run}\" ) # run cmd try: subprocess.run(cmd, shell=True, check=True) except subprocess.CalledProcessError: print(\"error\")","title":"pymaker.py"},{"location":"API/bin/pymaker/#pymakerpy","text":"The main file that runs the program This file is executable and can be called from the terminal like: foo@bar:~$ pymaker [cmd line] when placed in a folder that is in the default $PATH, ie: /usr/bin ~/.local/bin etc. All command line options will be passed to the main class, usually located at ~/.local/share/pyplate/src/pymaker.py. Typical usage is show in the main() method.","title":"pymaker.py"},{"location":"API/bin/pymaker/#bin.pymaker.PyMaker","text":"The entry point class, responsible for launching the program Public methods main: The main method of the program This class starts the program from the command line when it is installed in directories that are defined in the $PATH variable. These are places like /usr/bin, ~/.local/bin, etc. and can be called from the command line regardless of the current working directory. It is basically a \"bootstrap\" file, activating the venv and calling the main program. Source code in bin/pymaker.py class PyMaker: \"\"\" The entry point class, responsible for launching the program Public methods: main: The main method of the program This class starts the program from the command line when it is installed in directories that are defined in the $PATH variable. These are places like /usr/bin, ~/.local/bin, etc. and can be called from the command line regardless of the current working directory. It is basically a \"bootstrap\" file, activating the venv and calling the main program. \"\"\" # -------------------------------------------------------------------------- # Class constants # -------------------------------------------------------------------------- # find path to prj/lib P_DIR_PP = f\"{Path.home()}/.local/share/pyplate\" # commands to run S_CMD_ACTIVATE = f\". {P_DIR_PP}/.venv-pyplate/bin/activate\" S_CMD_RUN = f\"{P_DIR_PP}/src/pymaker.py\" S_CMD_RUN_ARGS = \"{} {}\" # -------------------------------------------------------------------------- # Public methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # The main method of the program # -------------------------------------------------------------------------- def main(self): \"\"\" The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. It then calls the real main module, located in the install dir. \"\"\" # ---------------------------------------------------------------------- # save project path to return after venv activate start_dir = Path.cwd() # get args args = sys.argv # remove our path args = args[1:] # quote any args with spaces args = [f'\"{item}\"' if \" \" in item else item for item in args] # put args back together with spaces args = \" \".join(args) # def cmd line - no args src_run = self.S_CMD_RUN # add args if present if len(args) > 0: src_run = self.S_CMD_RUN_ARGS.format(self.S_CMD_RUN, args) # ---------------------------------------------------------------------- # build cmd cmd = ( # cd to inst f\"cd {self.P_DIR_PP};\" # activate venv f\"{self.S_CMD_ACTIVATE};\" # get back to start dir (where we were called) f\"cd {start_dir};\" # call src w/ args f\"{src_run}\" ) # run cmd try: subprocess.run(cmd, shell=True, check=True) except subprocess.CalledProcessError: print(\"error\")","title":"PyMaker"},{"location":"API/bin/pymaker/#bin.pymaker.PyMaker.main","text":"The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. It then calls the real main module, located in the install dir. Source code in bin/pymaker.py def main(self): \"\"\" The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. It then calls the real main module, located in the install dir. \"\"\" # ---------------------------------------------------------------------- # save project path to return after venv activate start_dir = Path.cwd() # get args args = sys.argv # remove our path args = args[1:] # quote any args with spaces args = [f'\"{item}\"' if \" \" in item else item for item in args] # put args back together with spaces args = \" \".join(args) # def cmd line - no args src_run = self.S_CMD_RUN # add args if present if len(args) > 0: src_run = self.S_CMD_RUN_ARGS.format(self.S_CMD_RUN, args) # ---------------------------------------------------------------------- # build cmd cmd = ( # cd to inst f\"cd {self.P_DIR_PP};\" # activate venv f\"{self.S_CMD_ACTIVATE};\" # get back to start dir (where we were called) f\"cd {start_dir};\" # call src w/ args f\"{src_run}\" ) # run cmd try: subprocess.run(cmd, shell=True, check=True) except subprocess.CalledProcessError: print(\"error\")","title":"main"},{"location":"API/conf/conf/","text":"conf.py This module separates out the constants from pymaker.py. It also includes hook functions to extend the functionality of pymaker.py and pybaker.py. This file, and the template folder, are the main ways to customize PyPlate. do_after_dist(dir_prj, dict_prv, _dict_pub, dict_dbg) Do any work after making dist Parameters: Name Type Description Default dir_prj The root of the new project required dict_prv The dictionary containing private pyplate data required dict_pub The dictionary containing public project data required dict_dbg The dictionary containing the current session's debug required Do any work on the dist folder after it is created. This method is called after _do_dist. Currently, this method purges any \"ABOUT\" file used as placeholders for github syncing. It also tars the source folder if it is a package, making for one (or two) less steps in the user's install process. Source code in conf/conf.py def do_after_dist(dir_prj, dict_prv, _dict_pub, dict_dbg): \"\"\" Do any work after making dist Args: dir_prj: The root of the new project dict_prv: The dictionary containing private pyplate data dict_pub: The dictionary containing public project data dict_dbg: The dictionary containing the current session's debug settings Do any work on the dist folder after it is created. This method is called after _do_dist. Currently, this method purges any \"ABOUT\" file used as placeholders for github syncing. It also tars the source folder if it is a package, making for one (or two) less steps in the user's install process. \"\"\" # get dist dir for all operations dist = Path(dir_prj) / S_DIR_DIST name_fmt = dict_prv[S_KEY_PRV_PRJ][\"__PP_DIST_DIR__\"] p_dist = dist / name_fmt # -------------------------------------------------------------------------- # move some files around between end of dist and start of install # get project type prj_type = dict_prv[S_KEY_PRV_PRJ][\"__PP_TYPE_PRJ__\"] if prj_type in L_APP_INSTALL: # move install.py to above assets file_inst = p_dist / S_DIR_ASSETS / S_DIR_INSTALL / S_FILE_INST_PY if file_inst.exists(): shutil.move(file_inst, p_dist) # move uninstall.py to top of assets file_uninst = p_dist / S_DIR_ASSETS / S_DIR_INSTALL / S_FILE_UNINST_PY if file_uninst.exists(): dest = p_dist / S_DIR_ASSETS shutil.move(file_uninst, dest) # -------------------------------------------------------------------------- # remove all \"ABOUT\" files # print info print(S_ACTION_PURGE, end=\"\", flush=True) # first purge all dummy files for root, _root_dirs, root_files in p_dist.walk(): # convert files into Paths files = [root / f for f in root_files] # for each file item for item in files: # if it is in purge list, delete it if item.name in L_PURGE_FILES: item.unlink() # print info print(S_ACTION_DONE) # -------------------------------------------------------------------------- # compress dist # print info print(S_ACTION_COMPRESS, end=\"\", flush=True) # get prj type name_small = dict_prv[S_KEY_PRV_PRJ][\"__PP_NAME_PRJ_SMALL__\"] # remove ext from bin file old_bin = ( p_dist / S_DIR_ASSETS / S_DIR_BIN / f\"{name_small}{S_DIST_REMOVE}\" ) new_bin = p_dist / S_DIR_ASSETS / S_DIR_BIN / f\"{name_small}\" if old_bin.exists(): old_bin.rename(new_bin) # now do normal dist tar in_dir = p_dist out_file = Path(S_DIR_DIST) / f\"{in_dir}{S_DIST_EXT}\" with tarfile.open(out_file, mode=S_DIST_MODE) as compressed: compressed.add(in_dir, arcname=Path(in_dir).name) # print info print(S_ACTION_DONE) # -------------------------------------------------------------------------- # delete the origin dir, if key set # if debug key set if dict_dbg[S_KEY_DBG_DIST]: # print info print(S_ACTION_REM_DIST, end=\"\", flush=True) # get dist dir for all operations dist = Path(dir_prj) / S_DIR_DIST name_fmt = dict_prv[S_KEY_PRV_PRJ][\"__PP_DIST_DIR__\"] p_dist = dist / name_fmt # delete folder shutil.rmtree(p_dist) # show info print(S_ACTION_DONE) do_after_fix(dir_prj, dict_prv, dict_pub, dict_dbg) Do any work after fix Parameters: Name Type Description Default dir_prj The root of the new project required dict_prv The dictionary containing private pyplate data required dict_pub The dictionary containing public project data required dict_dbg The dictionary containing the current session's debug required Do any work after fix. This function is called by both PyMaker and PyBaker. This method is called just after _do_fix, after all files have been modified. It is mostly used to update metadata once all the normal fixes have been applied. Source code in conf/conf.py def do_after_fix(dir_prj, dict_prv, dict_pub, dict_dbg): \"\"\" Do any work after fix Args: dir_prj: The root of the new project dict_prv: The dictionary containing private pyplate data dict_pub: The dictionary containing public project data dict_dbg: The dictionary containing the current session's debug settings Do any work after fix.\\n This function is called by both PyMaker and PyBaker.\\n This method is called just after _do_fix, after all files have been modified.\\n It is mostly used to update metadata once all the normal fixes have been applied. \"\"\" # get project type prj_type = dict_prv[S_KEY_PRV_PRJ][\"__PP_TYPE_PRJ__\"] # -------------------------------------------------------------------------- # metadata # NB: this is an example of how to use the blacklist filter in your own # customized fix routine # print info print(S_ACTION_META, end=\"\", flush=True) # NB: this function uses the blacklist to filter files at the very end of # the fix process. at this point you can assume ALL dunders in ALL eligible # files have been fixed, as well as paths/filenames. also dict_pub and # dict_prv have been undunderized dict_bl = dict_pub[S_KEY_PUB_BL] # just shorten the names skip_all = dict_bl[S_KEY_SKIP_ALL] skip_contents = dict_bl[S_KEY_SKIP_CONTENTS] # -------------------------------------------------------------------------- # do the fixes # NB: root is a full path, dirs and files are relative to root for root, root_dirs, root_files in dir_prj.walk(): # handle dirs in skip_all if root in skip_all: # NB: don't recurse into subfolders root_dirs.clear() continue # convert files into Paths files = [root / f for f in root_files] # for each file item for item in files: # handle files in skip_all if item in skip_all: continue # handle dirs/files in skip_contents if not root in skip_contents and not item in skip_contents: # fix content with appropriate dict _fix_meta(item, dict_prv, dict_pub) # print done print(S_ACTION_DONE) # -------------------------------------------------------------------------- # readme chop section path_readme = dir_prj / D_PRV_ALL[\"__PP_README_FILE__\"] if path_readme.exists(): print(S_ACTION_README, end=\"\", flush=True) # the whole text of the file text = \"\" # open and read whole file with open(path_readme, \"r\", encoding=S_ENCODING) as a_file: text = a_file.read() # find the remove blocks (opposite of prj type) if prj_type in L_APP_INSTALL: str_pattern = S_RM_PKG else: str_pattern = S_RM_APP # replace block with empty string (equiv to deleting it) # NB: need S flag to make dot match newline text = re.sub(str_pattern, \"\", text, flags=re.S) # save file with open(path_readme, \"w\", encoding=S_ENCODING) as a_file: a_file.write(text) # show info print(S_ACTION_DONE) # -------------------------------------------------------------------------- # i18n # path to desktop template path_dsk_tmp = dir_prj / S_FILE_DSK_TMP # path to desktop output path_dsk_out = dir_prj / dict_prv[S_KEY_PRV_PRJ][\"__PP_FILE_DESK__\"] # if i18n flag is set if dict_dbg[S_KEY_DBG_I18N]: # print info print(S_ACTION_I18N, end=\"\", flush=True) # ---------------------------------------------------------------------- # do bulk of i18n # create CNPotPy object potpy = CNPotPy( # header str_domain=dict_prv[S_KEY_PRV_PRJ][\"__PP_NAME_PRJ_SMALL__\"], str_version=dict_prv[S_KEY_PRV_PRJ][\"__PP_VER_MMR__\"], str_author=dict_prv[S_KEY_PRV_ALL][\"__PP_AUTHOR__\"], str_email=dict_prv[S_KEY_PRV_ALL][\"__PP_EMAIL__\"], # base prj dir dir_prj=dir_prj, # in list_src=dict_pub[S_KEY_PUB_I18N][S_KEY_PUB_I18N_SRC], # out dir_pot=S_PATH_POT, dir_po=S_PATH_PO, dir_locale=S_PATH_LOCALE, # optional in str_tag=S_I18N_TAG, dict_clangs=dict_pub[S_KEY_PUB_I18N][S_KEY_PUB_I18N_CLANGS], dict_no_ext=dict_pub[S_KEY_PUB_I18N][S_KEY_PUB_I18N_NO_EXT], list_wlangs=dict_pub[S_KEY_PUB_I18N][S_KEY_PUB_I18N_WLANGS], charset=dict_pub[S_KEY_PUB_I18N][S_KEY_PUB_I18N_CHAR], location=False, ) # make .pot, .po, and .mo files potpy.main() # ---------------------------------------------------------------------- # do .desktop i18n/version # check if we want template if prj_type in L_MAKE_DESK and not path_dsk_tmp.exists(): # we want template, but does not exist print(\"\\n\" + S_ERR_DESK_NO_TEMP.format(path_dsk_tmp, path_dsk_out)) else: # do the thing potpy.make_desktop(path_dsk_tmp, path_dsk_out) # fix version in .po files (not always recreated by pybaker) path_po = dir_prj / S_DIR_I18N / S_DIR_PO for root, root_dirs, root_files in path_po.walk(): files = [root / file for file in root_files] files = [ file for file in files if PP.is_path_in_list(file, L_EXT_PO) ] for item in files: # get sub-dicts we need dict_prv_prj = dict_prv[S_KEY_PRV_PRJ] # default text if we can't open file text = \"\" # open file and get contents with open(item, \"r\", encoding=S_ENCODING) as a_file: text = a_file.read() # replace version str_pattern = S_PO_VER_SCH pp_version = dict_prv_prj[\"__PP_VER_MMR__\"] str_rep = S_PO_VER_REP.format(pp_version) text = re.sub(str_pattern, str_rep, text, flags=re.M | re.S) # save file with open(item, \"w\", encoding=S_ENCODING) as a_file: a_file.write(text) # ---------------------------------------------------------------------- # we are done print(S_ACTION_DONE) # -------------------------------------------------------------------------- # tree # NB: run last so it includes .git and .venv folders # NB: this will wipe out all previous checks (maybe good?) # if tree flag is set if dict_dbg[S_KEY_DBG_TREE]: # print info print(S_ACTION_TREE, end=\"\", flush=True) # get path to tree file_tree = dir_prj / S_TREE_FILE # create the file so it includes itself with open(file_tree, \"w\", encoding=S_ENCODING) as a_file: a_file.write(\"\") # create tree object and call tree_obj = CNTree( str(dir_prj), filter_list=dict_pub[S_KEY_PUB_BL][S_KEY_SKIP_TREE], dir_format=S_TREE_DIR_FORMAT, file_format=S_TREE_FILE_FORMAT, ) tree_str = tree_obj.main() # write to file with open(file_tree, \"w\", encoding=S_ENCODING) as a_file: a_file.write(tree_str) # ---------------------------------------------------------------------- # we are done print(S_ACTION_DONE) # -------------------------------------------------------------------------- # fix po files outside blacklist # print info print(S_ACTION_PO, end=\"\", flush=True) # get i18n path path = dir_prj / S_DIR_I18N # get sub-dicts we need dict_prv_prj = dict_prv[S_KEY_PRV_PRJ] for root, root_dirs, root_files in path.walk(): root_files = [root / root_file for root_file in root_files] for root_file in root_files: # only fix po files # if not root_file.suffix.lower() == \".po\": if not PP.is_path_in_list(root_file, L_EXT_PO): continue # default text if we can't open file text = \"\" # open file and get contents with open(root_file, \"r\", encoding=S_ENCODING) as a_file: text = a_file.read() # replace version str_pattern = S_PO_VER_SCH pp_version = dict_prv_prj[\"__PP_VER_MMR__\"] str_rep = S_PO_VER_REP.format(pp_version) text = re.sub(str_pattern, str_rep, text, flags=re.M | re.S) # save file with open(root_file, \"w\", encoding=S_ENCODING) as a_file: a_file.write(text) # -------------------------------------------------------------------------- # purge package dirs if prj_type in D_PURGE_DIRS: l_purge = D_PURGE_DIRS[prj_type] l_purge = [ ( Path(dir_prj) / item if not Path(item).is_absolute() else Path(item) ) for item in l_purge ] for item in l_purge: if item.exists(): shutil.rmtree(item) # print done print(S_ACTION_DONE) # -------------------------------------------------------------------------- # docs # if docs flag is set if dict_dbg[S_KEY_DBG_DOCS]: # get the doc tool from the project info # NB: doc_tool is the import file name str_doc_tool = dict_pub[S_KEY_PUB_DOCS][S_KEY_DOCS_TOOL] doc_tool = None if str_doc_tool == S_DOCS_PDOCS: doc_tool = pdoc elif str_doc_tool == S_DOCS_MKDOCS: doc_tool = mkdocs # if we found a tool if doc_tool: # print info print(S_ACTION_DOCS, end=\"\", flush=True) # the command to run pdoc/mkdocs/... try: doc_tool.make_docs( dir_prj, dict_prv, dict_pub, P_DIR_PP, P_DIR_PP_VENV ) print(S_ACTION_DONE) except Exception as e: print(S_ACTION_FAIL) raise e do_after_template(dir_prj, dict_prv, _dict_pub, dict_dbg) Do any work after template copy Parameters: Name Type Description Default dir_prj The root of the new project required dict_prv The dictionary containing private pyplate data required dict_pub The dictionary containing public project data required dict_dbg The dictionary containing the current session's debug required Do any work after copying the template. This function is called after _do_template, and before _do_before_fix. Use this function to create any files that your project needs to be created dynamically. You can also run code that is only called by PyMaker before fixing, like chopping the readme file sections. Source code in conf/conf.py def do_after_template(dir_prj, dict_prv, _dict_pub, dict_dbg): \"\"\" Do any work after template copy Args: dir_prj: The root of the new project dict_prv: The dictionary containing private pyplate data dict_pub: The dictionary containing public project data dict_dbg: The dictionary containing the current session's debug settings Do any work after copying the template. This function is called after _do_template, and before _do_before_fix.\\n Use this function to create any files that your project needs to be created dynamically. You can also run code that is only called by PyMaker before fixing, like chopping the readme file sections. \"\"\" # get project type prj_type = dict_prv[S_KEY_PRV_PRJ][\"__PP_TYPE_PRJ__\"] # -------------------------------------------------------------------------- # venv # if venv flag is set if dict_dbg[S_KEY_DBG_VENV]: # venv only for certain project types if prj_type in L_MAKE_VENV: print(S_ACTION_VENV, end=\"\", flush=True) # get name ov venv folder and reqs file dir_venv = dict_prv[S_KEY_PRV_PRJ][\"__PP_NAME_VENV__\"] file_reqs = dir_prj / S_FILE_REQS # do the thing with the thing cv = CNVenv(dir_prj, dir_venv) try: cv.create() if file_reqs.exists(): cv.install_reqs(file_reqs) print(S_ACTION_DONE) except Exception as e: print(S_ACTION_FAIL) print(S_MSG_NO_INTERNET) raise e else: # no venv, no reqs (Path(dir_prj) / S_FILE_REQS).unlink() # -------------------------------------------------------------------------- # git # if git flag if dict_dbg[S_KEY_DBG_GIT]: # show info print(S_ACTION_GIT, end=\"\", flush=True) # add git dir cmd = S_CMD_GIT_CREATE.format(dir_prj) F.sh(cmd, shell=True) # show info print(S_ACTION_DONE) # -------------------------------------------------------------------------- # install/uninstall config files # if install flag is set if dict_dbg[S_KEY_DBG_INST]: # cli/gui if prj_type in L_APP_INSTALL: # show info print(S_ACTION_INST, end=\"\", flush=True) # create a template install cfg file dict_inst = D_INSTALL[prj_type] # fix dunders in inst cfg file path_inst = dir_prj / S_PATH_INST_CFG F.save_dict(dict_inst, [path_inst]) # create a template uninstall cfg file dict_uninst = D_UNINSTALL[prj_type] # fix dunders in uninst cfg file path_uninst = dir_prj / S_PATH_UNINST_CFG F.save_dict(dict_uninst, [path_uninst]) # show info print(S_ACTION_DONE) do_before_dist(dir_prj, dict_prv, dict_pub, dict_dbg) Do any work before making dist Parameters: Name Type Description Default dir_prj The root of the new project required dict_prv The dictionary containing private pyplate data required dict_pub The dictionary containing public project data required dict_dbg The dictionary containing the current session's debug required Do any work on the dist folder before it is created. This method is called after _do_after_fix, and before _do_dist. Source code in conf/conf.py def do_before_dist(dir_prj, dict_prv, dict_pub, dict_dbg): \"\"\" Do any work before making dist Args: dir_prj: The root of the new project dict_prv: The dictionary containing private pyplate data dict_pub: The dictionary containing public project data dict_dbg: The dictionary containing the current session's debug settings Do any work on the dist folder before it is created. This method is called after _do_after_fix, and before _do_dist. \"\"\" # get project type prj_type = dict_prv[S_KEY_PRV_PRJ][\"__PP_TYPE_PRJ__\"] # -------------------------------------------------------------------------- # docs # if docs flag is set if dict_dbg[S_KEY_DBG_DOCS]: # get the doc tool from the project info # NB: doc_tool is the import file name str_doc_tool = dict_pub[S_KEY_PUB_DOCS][S_KEY_DOCS_TOOL] doc_tool = None if str_doc_tool == S_DOCS_MKDOCS: doc_tool = mkdocs # if we found a tool if doc_tool: # print info print(S_ACTION_DEPLOY_DOCS, end=\"\", flush=True) # the command to run pdoc/mkdocs/... try: doc_tool.deploy_docs( dir_prj, dict_prv, dict_pub, P_DIR_PP, P_DIR_PP_VENV ) print(S_ACTION_DONE) except Exception as e: print(S_ACTION_FAIL) raise e # -------------------------------------------------------------------------- # venv # if venv flag is set if dict_dbg[S_KEY_DBG_VENV]: # venv only for certain project types if prj_type in L_MAKE_VENV: # print info print(S_ACTION_FREEZE, end=\"\", flush=True) # get name ov venv folder and reqs file dir_venv = dict_prv[S_KEY_PRV_PRJ][\"__PP_NAME_VENV__\"] file_reqs = dir_prj / S_FILE_REQS # do the thing with the thing cv = CNVenv(dir_prj, dir_venv) try: cv.freeze(file_reqs) print(S_ACTION_DONE) except Exception as e: print(S_ACTION_FAIL) raise e # -------------------------------------------------------------------------- # purge package dirs # if project type in dict if prj_type in D_PURGE_DIRS: # get list and make items absolute l_purge = D_PURGE_DIRS[prj_type] l_purge = [Path(item) for item in l_purge] l_purge = [ dir_prj / item if not item.is_absolute() else item for item in l_purge ] # purge dirs for item in l_purge: if item.exists() and item.is_dir(): shutil.rmtree(item) do_before_fix(_dir_prj, dict_prv, dict_pub, _dict_dbg) Do any work before fix Parameters: Name Type Description Default dir_prj The root of the new project required dict_prv The dictionary containing private pyplate data required dict_pub The dictionary containing public project data required dict_dbg The dictionary containing the current session's debug required Do any work before fix. This function is called by both PyMaker and PyBaker. This method is called just before_do_fix, after all dunders have been configured, but before any files have been modified. It is mostly used to make final adjustments to the 'dict_prv' and 'dict_pub' dicts before any replacement occurs. Source code in conf/conf.py def do_before_fix(_dir_prj, dict_prv, dict_pub, _dict_dbg): \"\"\" Do any work before fix Args: dir_prj: The root of the new project dict_prv: The dictionary containing private pyplate data dict_pub: The dictionary containing public project data dict_dbg: The dictionary containing the current session's debug settings Do any work before fix.\\n This function is called by both PyMaker and PyBaker.\\n This method is called just before_do_fix, after all dunders have been configured, but before any files have been modified.\\n It is mostly used to make final adjustments to the 'dict_prv' and 'dict_pub' dicts before any replacement occurs. \"\"\" # -------------------------------------------------------------------------- # these paths are formatted here because they are complex and may be # changed by dev # get sub-dicts we need dict_prv_all = dict_prv[S_KEY_PRV_ALL] dict_prv_prj = dict_prv[S_KEY_PRV_PRJ] dict_pub_meta = dict_pub[S_KEY_PUB_META] # get values after pymaker has set them name_prj_small = dict_prv_prj[\"__PP_NAME_PRJ_SMALL__\"] # paths relative to the end user's (or dev's) useful folders usr_inst = f\"{S_USR_SHARE}/{name_prj_small}\" dict_prv_prj[\"__PP_USR_INST__\"] = usr_inst # k/v to fix desktop name_prj_big = dict_prv_prj[\"__PP_NAME_PRJ_BIG__\"] dict_prv_prj[\"__PP_FILE_DESK__\"] = ( f\"{S_DIR_SRC}/{S_DIR_GUI}/{S_DIR_DESKTOP}/{name_prj_big}.desktop\" ) # app id for gui author = dict_prv_all[\"__PP_AUTHOR__\"] dict_prv_prj[\"__PP_APP_ID__\"] = S_APP_ID_FMT.format(author, name_prj_small) # -------------------------------------------------------------------------- # version stuff # get base version ver_base = dict_pub_meta[S_KEY_META_VERSION] # set display of version dict_prv_prj[\"__PP_VER_DISP__\"] = S_VER_DISP_FMT.format(ver_base) # semantic version with meta info str_sem = ver_base dict_prv_prj[\"__PP_VER_MMR__\"] = str_sem # fix ver for dist filename ver_dist = str_sem # format dist dir name with prj and ver name_fmt = S_VER_DIST_FMT.format(name_prj_small, ver_dist) dict_prv_prj[\"__PP_DIST_DIR__\"] = name_fmt # ---------------------------------------------------------------------- # calculate current date # NB: this is the initial create date for all files in the template # new files added to the project will have their dates set to the date # when pybaker was last run # get current date and format it according to dev fmt now = datetime.now() fmt_date = S_DATE_FMT info_date = now.strftime(fmt_date) dict_prv_prj[\"__PP_DATE__\"] = info_date # gui app/win replacements name_prj_pascal = dict_prv_prj[\"__PP_NAME_PRJ_PASCAL__\"] name_sec_small = dict_prv_prj[\"__PP_NAME_SEC_SMALL__\"] name_sec_pascal = dict_prv_prj[\"__PP_NAME_SEC_PASCAL__\"] dict_prv_prj[\"__PP_FILE_APP__\"] = S_APP_FILE_FMT.format(name_prj_small) dict_prv_prj[\"__PP_CLASS_APP__\"] = S_APP_CLASS_FMT.format(name_prj_pascal) dict_prv_prj[\"__PP_FILE_WIN__\"] = S_WIN_FILE_FMT.format(name_sec_small) dict_prv_prj[\"__PP_CLASS_WIN__\"] = S_WIN_CLASS_FMT.format(name_sec_pascal) # various image files img_ext = ( f\".{S_IMG_EXT.lower()}\" if not S_IMG_EXT.startswith(\".\") else S_IMG_EXT.lower() ) dict_prv_prj[\"__PP_IMG_README__\"] = ( f\"{S_DIR_IMAGES}/{name_prj_small}{img_ext}\" ) # NB: .desktop needs abs path to img dict_prv_prj[\"__PP_IMG_DESK__\"] = ( f\"{usr_inst}/{S_DIR_IMAGES}/{name_prj_small}{img_ext}\" ) # NB: .ui files need rel path to img dict_prv_prj[\"__PP_IMG_DASH__\"] = ( f\"{\"../../..\"}/{S_DIR_IMAGES}/{name_prj_small}{img_ext}\" ) dict_prv_prj[\"__PP_IMG_ABOUT__\"] = ( f\"{\"../../..\"}/{S_DIR_IMAGES}/{name_prj_small}{img_ext}\" ) do_before_template(_dir_prj, _dict_prv, _dict_pub, _dict_dbg) Do any work before template copy Parameters: Name Type Description Default dir_prj The root of the new project required dict_prv The dictionary containing private pyplate data required dict_pub The dictionary containing public project data required dict_dbg The dictionary containing the current session's debug required Do any work before copying the template. This method is called just before _do_template, before any files have been copied. It is mostly used to make final adjustments to the 'dict_prv' and 'dict_pub' dicts before any copying occurs. Source code in conf/conf.py def do_before_template(_dir_prj, _dict_prv, _dict_pub, _dict_dbg): \"\"\" Do any work before template copy Args: dir_prj: The root of the new project dict_prv: The dictionary containing private pyplate data dict_pub: The dictionary containing public project data dict_dbg: The dictionary containing the current session's debug settings Do any work before copying the template. This method is called just before _do_template, before any files have been copied.\\n It is mostly used to make final adjustments to the 'dict_prv' and 'dict_pub' dicts before any copying occurs. \"\"\"","title":"conf.py"},{"location":"API/conf/conf/#confpy","text":"This module separates out the constants from pymaker.py. It also includes hook functions to extend the functionality of pymaker.py and pybaker.py. This file, and the template folder, are the main ways to customize PyPlate.","title":"conf.py"},{"location":"API/conf/conf/#conf.conf.do_after_dist","text":"Do any work after making dist Parameters: Name Type Description Default dir_prj The root of the new project required dict_prv The dictionary containing private pyplate data required dict_pub The dictionary containing public project data required dict_dbg The dictionary containing the current session's debug required Do any work on the dist folder after it is created. This method is called after _do_dist. Currently, this method purges any \"ABOUT\" file used as placeholders for github syncing. It also tars the source folder if it is a package, making for one (or two) less steps in the user's install process. Source code in conf/conf.py def do_after_dist(dir_prj, dict_prv, _dict_pub, dict_dbg): \"\"\" Do any work after making dist Args: dir_prj: The root of the new project dict_prv: The dictionary containing private pyplate data dict_pub: The dictionary containing public project data dict_dbg: The dictionary containing the current session's debug settings Do any work on the dist folder after it is created. This method is called after _do_dist. Currently, this method purges any \"ABOUT\" file used as placeholders for github syncing. It also tars the source folder if it is a package, making for one (or two) less steps in the user's install process. \"\"\" # get dist dir for all operations dist = Path(dir_prj) / S_DIR_DIST name_fmt = dict_prv[S_KEY_PRV_PRJ][\"__PP_DIST_DIR__\"] p_dist = dist / name_fmt # -------------------------------------------------------------------------- # move some files around between end of dist and start of install # get project type prj_type = dict_prv[S_KEY_PRV_PRJ][\"__PP_TYPE_PRJ__\"] if prj_type in L_APP_INSTALL: # move install.py to above assets file_inst = p_dist / S_DIR_ASSETS / S_DIR_INSTALL / S_FILE_INST_PY if file_inst.exists(): shutil.move(file_inst, p_dist) # move uninstall.py to top of assets file_uninst = p_dist / S_DIR_ASSETS / S_DIR_INSTALL / S_FILE_UNINST_PY if file_uninst.exists(): dest = p_dist / S_DIR_ASSETS shutil.move(file_uninst, dest) # -------------------------------------------------------------------------- # remove all \"ABOUT\" files # print info print(S_ACTION_PURGE, end=\"\", flush=True) # first purge all dummy files for root, _root_dirs, root_files in p_dist.walk(): # convert files into Paths files = [root / f for f in root_files] # for each file item for item in files: # if it is in purge list, delete it if item.name in L_PURGE_FILES: item.unlink() # print info print(S_ACTION_DONE) # -------------------------------------------------------------------------- # compress dist # print info print(S_ACTION_COMPRESS, end=\"\", flush=True) # get prj type name_small = dict_prv[S_KEY_PRV_PRJ][\"__PP_NAME_PRJ_SMALL__\"] # remove ext from bin file old_bin = ( p_dist / S_DIR_ASSETS / S_DIR_BIN / f\"{name_small}{S_DIST_REMOVE}\" ) new_bin = p_dist / S_DIR_ASSETS / S_DIR_BIN / f\"{name_small}\" if old_bin.exists(): old_bin.rename(new_bin) # now do normal dist tar in_dir = p_dist out_file = Path(S_DIR_DIST) / f\"{in_dir}{S_DIST_EXT}\" with tarfile.open(out_file, mode=S_DIST_MODE) as compressed: compressed.add(in_dir, arcname=Path(in_dir).name) # print info print(S_ACTION_DONE) # -------------------------------------------------------------------------- # delete the origin dir, if key set # if debug key set if dict_dbg[S_KEY_DBG_DIST]: # print info print(S_ACTION_REM_DIST, end=\"\", flush=True) # get dist dir for all operations dist = Path(dir_prj) / S_DIR_DIST name_fmt = dict_prv[S_KEY_PRV_PRJ][\"__PP_DIST_DIR__\"] p_dist = dist / name_fmt # delete folder shutil.rmtree(p_dist) # show info print(S_ACTION_DONE)","title":"do_after_dist"},{"location":"API/conf/conf/#conf.conf.do_after_fix","text":"Do any work after fix Parameters: Name Type Description Default dir_prj The root of the new project required dict_prv The dictionary containing private pyplate data required dict_pub The dictionary containing public project data required dict_dbg The dictionary containing the current session's debug required Do any work after fix. This function is called by both PyMaker and PyBaker. This method is called just after _do_fix, after all files have been modified. It is mostly used to update metadata once all the normal fixes have been applied. Source code in conf/conf.py def do_after_fix(dir_prj, dict_prv, dict_pub, dict_dbg): \"\"\" Do any work after fix Args: dir_prj: The root of the new project dict_prv: The dictionary containing private pyplate data dict_pub: The dictionary containing public project data dict_dbg: The dictionary containing the current session's debug settings Do any work after fix.\\n This function is called by both PyMaker and PyBaker.\\n This method is called just after _do_fix, after all files have been modified.\\n It is mostly used to update metadata once all the normal fixes have been applied. \"\"\" # get project type prj_type = dict_prv[S_KEY_PRV_PRJ][\"__PP_TYPE_PRJ__\"] # -------------------------------------------------------------------------- # metadata # NB: this is an example of how to use the blacklist filter in your own # customized fix routine # print info print(S_ACTION_META, end=\"\", flush=True) # NB: this function uses the blacklist to filter files at the very end of # the fix process. at this point you can assume ALL dunders in ALL eligible # files have been fixed, as well as paths/filenames. also dict_pub and # dict_prv have been undunderized dict_bl = dict_pub[S_KEY_PUB_BL] # just shorten the names skip_all = dict_bl[S_KEY_SKIP_ALL] skip_contents = dict_bl[S_KEY_SKIP_CONTENTS] # -------------------------------------------------------------------------- # do the fixes # NB: root is a full path, dirs and files are relative to root for root, root_dirs, root_files in dir_prj.walk(): # handle dirs in skip_all if root in skip_all: # NB: don't recurse into subfolders root_dirs.clear() continue # convert files into Paths files = [root / f for f in root_files] # for each file item for item in files: # handle files in skip_all if item in skip_all: continue # handle dirs/files in skip_contents if not root in skip_contents and not item in skip_contents: # fix content with appropriate dict _fix_meta(item, dict_prv, dict_pub) # print done print(S_ACTION_DONE) # -------------------------------------------------------------------------- # readme chop section path_readme = dir_prj / D_PRV_ALL[\"__PP_README_FILE__\"] if path_readme.exists(): print(S_ACTION_README, end=\"\", flush=True) # the whole text of the file text = \"\" # open and read whole file with open(path_readme, \"r\", encoding=S_ENCODING) as a_file: text = a_file.read() # find the remove blocks (opposite of prj type) if prj_type in L_APP_INSTALL: str_pattern = S_RM_PKG else: str_pattern = S_RM_APP # replace block with empty string (equiv to deleting it) # NB: need S flag to make dot match newline text = re.sub(str_pattern, \"\", text, flags=re.S) # save file with open(path_readme, \"w\", encoding=S_ENCODING) as a_file: a_file.write(text) # show info print(S_ACTION_DONE) # -------------------------------------------------------------------------- # i18n # path to desktop template path_dsk_tmp = dir_prj / S_FILE_DSK_TMP # path to desktop output path_dsk_out = dir_prj / dict_prv[S_KEY_PRV_PRJ][\"__PP_FILE_DESK__\"] # if i18n flag is set if dict_dbg[S_KEY_DBG_I18N]: # print info print(S_ACTION_I18N, end=\"\", flush=True) # ---------------------------------------------------------------------- # do bulk of i18n # create CNPotPy object potpy = CNPotPy( # header str_domain=dict_prv[S_KEY_PRV_PRJ][\"__PP_NAME_PRJ_SMALL__\"], str_version=dict_prv[S_KEY_PRV_PRJ][\"__PP_VER_MMR__\"], str_author=dict_prv[S_KEY_PRV_ALL][\"__PP_AUTHOR__\"], str_email=dict_prv[S_KEY_PRV_ALL][\"__PP_EMAIL__\"], # base prj dir dir_prj=dir_prj, # in list_src=dict_pub[S_KEY_PUB_I18N][S_KEY_PUB_I18N_SRC], # out dir_pot=S_PATH_POT, dir_po=S_PATH_PO, dir_locale=S_PATH_LOCALE, # optional in str_tag=S_I18N_TAG, dict_clangs=dict_pub[S_KEY_PUB_I18N][S_KEY_PUB_I18N_CLANGS], dict_no_ext=dict_pub[S_KEY_PUB_I18N][S_KEY_PUB_I18N_NO_EXT], list_wlangs=dict_pub[S_KEY_PUB_I18N][S_KEY_PUB_I18N_WLANGS], charset=dict_pub[S_KEY_PUB_I18N][S_KEY_PUB_I18N_CHAR], location=False, ) # make .pot, .po, and .mo files potpy.main() # ---------------------------------------------------------------------- # do .desktop i18n/version # check if we want template if prj_type in L_MAKE_DESK and not path_dsk_tmp.exists(): # we want template, but does not exist print(\"\\n\" + S_ERR_DESK_NO_TEMP.format(path_dsk_tmp, path_dsk_out)) else: # do the thing potpy.make_desktop(path_dsk_tmp, path_dsk_out) # fix version in .po files (not always recreated by pybaker) path_po = dir_prj / S_DIR_I18N / S_DIR_PO for root, root_dirs, root_files in path_po.walk(): files = [root / file for file in root_files] files = [ file for file in files if PP.is_path_in_list(file, L_EXT_PO) ] for item in files: # get sub-dicts we need dict_prv_prj = dict_prv[S_KEY_PRV_PRJ] # default text if we can't open file text = \"\" # open file and get contents with open(item, \"r\", encoding=S_ENCODING) as a_file: text = a_file.read() # replace version str_pattern = S_PO_VER_SCH pp_version = dict_prv_prj[\"__PP_VER_MMR__\"] str_rep = S_PO_VER_REP.format(pp_version) text = re.sub(str_pattern, str_rep, text, flags=re.M | re.S) # save file with open(item, \"w\", encoding=S_ENCODING) as a_file: a_file.write(text) # ---------------------------------------------------------------------- # we are done print(S_ACTION_DONE) # -------------------------------------------------------------------------- # tree # NB: run last so it includes .git and .venv folders # NB: this will wipe out all previous checks (maybe good?) # if tree flag is set if dict_dbg[S_KEY_DBG_TREE]: # print info print(S_ACTION_TREE, end=\"\", flush=True) # get path to tree file_tree = dir_prj / S_TREE_FILE # create the file so it includes itself with open(file_tree, \"w\", encoding=S_ENCODING) as a_file: a_file.write(\"\") # create tree object and call tree_obj = CNTree( str(dir_prj), filter_list=dict_pub[S_KEY_PUB_BL][S_KEY_SKIP_TREE], dir_format=S_TREE_DIR_FORMAT, file_format=S_TREE_FILE_FORMAT, ) tree_str = tree_obj.main() # write to file with open(file_tree, \"w\", encoding=S_ENCODING) as a_file: a_file.write(tree_str) # ---------------------------------------------------------------------- # we are done print(S_ACTION_DONE) # -------------------------------------------------------------------------- # fix po files outside blacklist # print info print(S_ACTION_PO, end=\"\", flush=True) # get i18n path path = dir_prj / S_DIR_I18N # get sub-dicts we need dict_prv_prj = dict_prv[S_KEY_PRV_PRJ] for root, root_dirs, root_files in path.walk(): root_files = [root / root_file for root_file in root_files] for root_file in root_files: # only fix po files # if not root_file.suffix.lower() == \".po\": if not PP.is_path_in_list(root_file, L_EXT_PO): continue # default text if we can't open file text = \"\" # open file and get contents with open(root_file, \"r\", encoding=S_ENCODING) as a_file: text = a_file.read() # replace version str_pattern = S_PO_VER_SCH pp_version = dict_prv_prj[\"__PP_VER_MMR__\"] str_rep = S_PO_VER_REP.format(pp_version) text = re.sub(str_pattern, str_rep, text, flags=re.M | re.S) # save file with open(root_file, \"w\", encoding=S_ENCODING) as a_file: a_file.write(text) # -------------------------------------------------------------------------- # purge package dirs if prj_type in D_PURGE_DIRS: l_purge = D_PURGE_DIRS[prj_type] l_purge = [ ( Path(dir_prj) / item if not Path(item).is_absolute() else Path(item) ) for item in l_purge ] for item in l_purge: if item.exists(): shutil.rmtree(item) # print done print(S_ACTION_DONE) # -------------------------------------------------------------------------- # docs # if docs flag is set if dict_dbg[S_KEY_DBG_DOCS]: # get the doc tool from the project info # NB: doc_tool is the import file name str_doc_tool = dict_pub[S_KEY_PUB_DOCS][S_KEY_DOCS_TOOL] doc_tool = None if str_doc_tool == S_DOCS_PDOCS: doc_tool = pdoc elif str_doc_tool == S_DOCS_MKDOCS: doc_tool = mkdocs # if we found a tool if doc_tool: # print info print(S_ACTION_DOCS, end=\"\", flush=True) # the command to run pdoc/mkdocs/... try: doc_tool.make_docs( dir_prj, dict_prv, dict_pub, P_DIR_PP, P_DIR_PP_VENV ) print(S_ACTION_DONE) except Exception as e: print(S_ACTION_FAIL) raise e","title":"do_after_fix"},{"location":"API/conf/conf/#conf.conf.do_after_template","text":"Do any work after template copy Parameters: Name Type Description Default dir_prj The root of the new project required dict_prv The dictionary containing private pyplate data required dict_pub The dictionary containing public project data required dict_dbg The dictionary containing the current session's debug required Do any work after copying the template. This function is called after _do_template, and before _do_before_fix. Use this function to create any files that your project needs to be created dynamically. You can also run code that is only called by PyMaker before fixing, like chopping the readme file sections. Source code in conf/conf.py def do_after_template(dir_prj, dict_prv, _dict_pub, dict_dbg): \"\"\" Do any work after template copy Args: dir_prj: The root of the new project dict_prv: The dictionary containing private pyplate data dict_pub: The dictionary containing public project data dict_dbg: The dictionary containing the current session's debug settings Do any work after copying the template. This function is called after _do_template, and before _do_before_fix.\\n Use this function to create any files that your project needs to be created dynamically. You can also run code that is only called by PyMaker before fixing, like chopping the readme file sections. \"\"\" # get project type prj_type = dict_prv[S_KEY_PRV_PRJ][\"__PP_TYPE_PRJ__\"] # -------------------------------------------------------------------------- # venv # if venv flag is set if dict_dbg[S_KEY_DBG_VENV]: # venv only for certain project types if prj_type in L_MAKE_VENV: print(S_ACTION_VENV, end=\"\", flush=True) # get name ov venv folder and reqs file dir_venv = dict_prv[S_KEY_PRV_PRJ][\"__PP_NAME_VENV__\"] file_reqs = dir_prj / S_FILE_REQS # do the thing with the thing cv = CNVenv(dir_prj, dir_venv) try: cv.create() if file_reqs.exists(): cv.install_reqs(file_reqs) print(S_ACTION_DONE) except Exception as e: print(S_ACTION_FAIL) print(S_MSG_NO_INTERNET) raise e else: # no venv, no reqs (Path(dir_prj) / S_FILE_REQS).unlink() # -------------------------------------------------------------------------- # git # if git flag if dict_dbg[S_KEY_DBG_GIT]: # show info print(S_ACTION_GIT, end=\"\", flush=True) # add git dir cmd = S_CMD_GIT_CREATE.format(dir_prj) F.sh(cmd, shell=True) # show info print(S_ACTION_DONE) # -------------------------------------------------------------------------- # install/uninstall config files # if install flag is set if dict_dbg[S_KEY_DBG_INST]: # cli/gui if prj_type in L_APP_INSTALL: # show info print(S_ACTION_INST, end=\"\", flush=True) # create a template install cfg file dict_inst = D_INSTALL[prj_type] # fix dunders in inst cfg file path_inst = dir_prj / S_PATH_INST_CFG F.save_dict(dict_inst, [path_inst]) # create a template uninstall cfg file dict_uninst = D_UNINSTALL[prj_type] # fix dunders in uninst cfg file path_uninst = dir_prj / S_PATH_UNINST_CFG F.save_dict(dict_uninst, [path_uninst]) # show info print(S_ACTION_DONE)","title":"do_after_template"},{"location":"API/conf/conf/#conf.conf.do_before_dist","text":"Do any work before making dist Parameters: Name Type Description Default dir_prj The root of the new project required dict_prv The dictionary containing private pyplate data required dict_pub The dictionary containing public project data required dict_dbg The dictionary containing the current session's debug required Do any work on the dist folder before it is created. This method is called after _do_after_fix, and before _do_dist. Source code in conf/conf.py def do_before_dist(dir_prj, dict_prv, dict_pub, dict_dbg): \"\"\" Do any work before making dist Args: dir_prj: The root of the new project dict_prv: The dictionary containing private pyplate data dict_pub: The dictionary containing public project data dict_dbg: The dictionary containing the current session's debug settings Do any work on the dist folder before it is created. This method is called after _do_after_fix, and before _do_dist. \"\"\" # get project type prj_type = dict_prv[S_KEY_PRV_PRJ][\"__PP_TYPE_PRJ__\"] # -------------------------------------------------------------------------- # docs # if docs flag is set if dict_dbg[S_KEY_DBG_DOCS]: # get the doc tool from the project info # NB: doc_tool is the import file name str_doc_tool = dict_pub[S_KEY_PUB_DOCS][S_KEY_DOCS_TOOL] doc_tool = None if str_doc_tool == S_DOCS_MKDOCS: doc_tool = mkdocs # if we found a tool if doc_tool: # print info print(S_ACTION_DEPLOY_DOCS, end=\"\", flush=True) # the command to run pdoc/mkdocs/... try: doc_tool.deploy_docs( dir_prj, dict_prv, dict_pub, P_DIR_PP, P_DIR_PP_VENV ) print(S_ACTION_DONE) except Exception as e: print(S_ACTION_FAIL) raise e # -------------------------------------------------------------------------- # venv # if venv flag is set if dict_dbg[S_KEY_DBG_VENV]: # venv only for certain project types if prj_type in L_MAKE_VENV: # print info print(S_ACTION_FREEZE, end=\"\", flush=True) # get name ov venv folder and reqs file dir_venv = dict_prv[S_KEY_PRV_PRJ][\"__PP_NAME_VENV__\"] file_reqs = dir_prj / S_FILE_REQS # do the thing with the thing cv = CNVenv(dir_prj, dir_venv) try: cv.freeze(file_reqs) print(S_ACTION_DONE) except Exception as e: print(S_ACTION_FAIL) raise e # -------------------------------------------------------------------------- # purge package dirs # if project type in dict if prj_type in D_PURGE_DIRS: # get list and make items absolute l_purge = D_PURGE_DIRS[prj_type] l_purge = [Path(item) for item in l_purge] l_purge = [ dir_prj / item if not item.is_absolute() else item for item in l_purge ] # purge dirs for item in l_purge: if item.exists() and item.is_dir(): shutil.rmtree(item)","title":"do_before_dist"},{"location":"API/conf/conf/#conf.conf.do_before_fix","text":"Do any work before fix Parameters: Name Type Description Default dir_prj The root of the new project required dict_prv The dictionary containing private pyplate data required dict_pub The dictionary containing public project data required dict_dbg The dictionary containing the current session's debug required Do any work before fix. This function is called by both PyMaker and PyBaker. This method is called just before_do_fix, after all dunders have been configured, but before any files have been modified. It is mostly used to make final adjustments to the 'dict_prv' and 'dict_pub' dicts before any replacement occurs. Source code in conf/conf.py def do_before_fix(_dir_prj, dict_prv, dict_pub, _dict_dbg): \"\"\" Do any work before fix Args: dir_prj: The root of the new project dict_prv: The dictionary containing private pyplate data dict_pub: The dictionary containing public project data dict_dbg: The dictionary containing the current session's debug settings Do any work before fix.\\n This function is called by both PyMaker and PyBaker.\\n This method is called just before_do_fix, after all dunders have been configured, but before any files have been modified.\\n It is mostly used to make final adjustments to the 'dict_prv' and 'dict_pub' dicts before any replacement occurs. \"\"\" # -------------------------------------------------------------------------- # these paths are formatted here because they are complex and may be # changed by dev # get sub-dicts we need dict_prv_all = dict_prv[S_KEY_PRV_ALL] dict_prv_prj = dict_prv[S_KEY_PRV_PRJ] dict_pub_meta = dict_pub[S_KEY_PUB_META] # get values after pymaker has set them name_prj_small = dict_prv_prj[\"__PP_NAME_PRJ_SMALL__\"] # paths relative to the end user's (or dev's) useful folders usr_inst = f\"{S_USR_SHARE}/{name_prj_small}\" dict_prv_prj[\"__PP_USR_INST__\"] = usr_inst # k/v to fix desktop name_prj_big = dict_prv_prj[\"__PP_NAME_PRJ_BIG__\"] dict_prv_prj[\"__PP_FILE_DESK__\"] = ( f\"{S_DIR_SRC}/{S_DIR_GUI}/{S_DIR_DESKTOP}/{name_prj_big}.desktop\" ) # app id for gui author = dict_prv_all[\"__PP_AUTHOR__\"] dict_prv_prj[\"__PP_APP_ID__\"] = S_APP_ID_FMT.format(author, name_prj_small) # -------------------------------------------------------------------------- # version stuff # get base version ver_base = dict_pub_meta[S_KEY_META_VERSION] # set display of version dict_prv_prj[\"__PP_VER_DISP__\"] = S_VER_DISP_FMT.format(ver_base) # semantic version with meta info str_sem = ver_base dict_prv_prj[\"__PP_VER_MMR__\"] = str_sem # fix ver for dist filename ver_dist = str_sem # format dist dir name with prj and ver name_fmt = S_VER_DIST_FMT.format(name_prj_small, ver_dist) dict_prv_prj[\"__PP_DIST_DIR__\"] = name_fmt # ---------------------------------------------------------------------- # calculate current date # NB: this is the initial create date for all files in the template # new files added to the project will have their dates set to the date # when pybaker was last run # get current date and format it according to dev fmt now = datetime.now() fmt_date = S_DATE_FMT info_date = now.strftime(fmt_date) dict_prv_prj[\"__PP_DATE__\"] = info_date # gui app/win replacements name_prj_pascal = dict_prv_prj[\"__PP_NAME_PRJ_PASCAL__\"] name_sec_small = dict_prv_prj[\"__PP_NAME_SEC_SMALL__\"] name_sec_pascal = dict_prv_prj[\"__PP_NAME_SEC_PASCAL__\"] dict_prv_prj[\"__PP_FILE_APP__\"] = S_APP_FILE_FMT.format(name_prj_small) dict_prv_prj[\"__PP_CLASS_APP__\"] = S_APP_CLASS_FMT.format(name_prj_pascal) dict_prv_prj[\"__PP_FILE_WIN__\"] = S_WIN_FILE_FMT.format(name_sec_small) dict_prv_prj[\"__PP_CLASS_WIN__\"] = S_WIN_CLASS_FMT.format(name_sec_pascal) # various image files img_ext = ( f\".{S_IMG_EXT.lower()}\" if not S_IMG_EXT.startswith(\".\") else S_IMG_EXT.lower() ) dict_prv_prj[\"__PP_IMG_README__\"] = ( f\"{S_DIR_IMAGES}/{name_prj_small}{img_ext}\" ) # NB: .desktop needs abs path to img dict_prv_prj[\"__PP_IMG_DESK__\"] = ( f\"{usr_inst}/{S_DIR_IMAGES}/{name_prj_small}{img_ext}\" ) # NB: .ui files need rel path to img dict_prv_prj[\"__PP_IMG_DASH__\"] = ( f\"{\"../../..\"}/{S_DIR_IMAGES}/{name_prj_small}{img_ext}\" ) dict_prv_prj[\"__PP_IMG_ABOUT__\"] = ( f\"{\"../../..\"}/{S_DIR_IMAGES}/{name_prj_small}{img_ext}\" )","title":"do_before_fix"},{"location":"API/conf/conf/#conf.conf.do_before_template","text":"Do any work before template copy Parameters: Name Type Description Default dir_prj The root of the new project required dict_prv The dictionary containing private pyplate data required dict_pub The dictionary containing public project data required dict_dbg The dictionary containing the current session's debug required Do any work before copying the template. This method is called just before _do_template, before any files have been copied. It is mostly used to make final adjustments to the 'dict_prv' and 'dict_pub' dicts before any copying occurs. Source code in conf/conf.py def do_before_template(_dir_prj, _dict_prv, _dict_pub, _dict_dbg): \"\"\" Do any work before template copy Args: dir_prj: The root of the new project dict_prv: The dictionary containing private pyplate data dict_pub: The dictionary containing public project data dict_dbg: The dictionary containing the current session's debug settings Do any work before copying the template. This method is called just before _do_template, before any files have been copied.\\n It is mostly used to make final adjustments to the 'dict_prv' and 'dict_pub' dicts before any copying occurs. \"\"\"","title":"do_before_template"},{"location":"API/conf/mkdocs/","text":"mkdocs.py This module makes documentation for a project using MkDocs. It uses the project's source files and the config file \"mkdocs.yml\" to create MarkDown files in the \"docs\" folder. It then builds the html file structure in the \"site\" folder. It uses the \"gh-deploy\" program to publish the site to a remote-only branch. It then instructs GitHub Pages to auto-publish your docs at .github.io/ from that branch. As much code/settings/constants as can be are reused from conf.py. deploy_docs(dir_prj, _dict_prv, _dict_pub, p_dir_pp, p_dir_pp_venv) Deploy docs using mkdocs Parameters: Name Type Description Default dir_prj The root of the new project required dict_prv The dictionary containing private pyplate data required dict_pub The dictionary containing public project data required p_dir_pp Path to PyPlate program required p_dir_pp_env Path to PyPlate's venv (to activate pdoc3) required Deploy the documents using the specified parameters. Source code in conf/mkdocs.py def deploy_docs(dir_prj, _dict_prv, _dict_pub, p_dir_pp, p_dir_pp_venv): \"\"\" Deploy docs using mkdocs Args: dir_prj: The root of the new project dict_prv: The dictionary containing private pyplate data dict_pub: The dictionary containing public project data p_dir_pp: Path to PyPlate program p_dir_pp_env: Path to PyPlate's venv (to activate pdoc3) Deploy the documents using the specified parameters. \"\"\" # format cmd using pdoc template dir, output dir, and start dir cmd_docs = S_CMD_DOC_DEPLOY.format( p_dir_pp, p_dir_pp_venv, dir_prj, ) # the command to run mkdocs try: subprocess.run( cmd_docs, shell=True, check=True, stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT, ) except Exception as e: print(S_ERR_NO_REPO) raise e make_docs(dir_prj, dict_prv, dict_pub, p_dir_pp, p_dir_pp_venv) Make docs using mkdocs Parameters: Name Type Description Default dir_prj The root of the new project required dict_prv The dictionary containing private pyplate data required dict_pub The dictionary containing public project data required p_dir_pp Path to PyPlate program required p_dir_pp_env Path to PyPlate's venv (to activate pdoc3) required Make the documents using the specified parameters. Source code in conf/mkdocs.py def make_docs(dir_prj, dict_prv, dict_pub, p_dir_pp, p_dir_pp_venv): \"\"\" Make docs using mkdocs Args: dir_prj: The root of the new project dict_prv: The dictionary containing private pyplate data dict_pub: The dictionary containing public project data p_dir_pp: Path to PyPlate program p_dir_pp_env: Path to PyPlate's venv (to activate pdoc3) Make the documents using the specified parameters. \"\"\" # where to put the .md files dir_docs_out = dir_prj / conf.S_DIR_DOCS # -------------------------------------------------------------------------- # make yaml # get theme from dict_pub dict_docs = dict_pub[conf.S_KEY_PUB_DOCS] theme = dict_docs.get(conf.S_KEY_DOCS_THEME, \"\") # path to file yaml_file = dir_prj / S_YML_NAME if not yaml_file.exists(): # create a new yaml with default text text = S_YML_TEXT.format(dir_prj.name, theme) # write file with open(yaml_file, \"w\", encoding=conf.S_ENCODING) as a_file: a_file.write(text) # -------------------------------------------------------------------------- # make home page # NB: just copy readme.md to index.md # path to files readme_file = dir_prj / conf.S_FILE_README index_file = dir_docs_out / S_INDEX_NAME if not index_file.exists(): # read input file text = \"\" with open(readme_file, \"r\", encoding=conf.S_ENCODING) as a_file: text = a_file.read() # write file with open(index_file, \"w\", encoding=conf.S_ENCODING) as a_file: a_file.write(text) # copy image for index.md as README.md prj_name = dict_prv[conf.S_KEY_PRV_PRJ][\"__PP_NAME_PRJ_SMALL__\"] prj_img = prj_name + \".png\" img_src = dir_prj / conf.S_DIR_IMAGES / prj_img dir_img_dest = dir_docs_out / conf.S_DIR_IMAGES dir_img_dest.mkdir(parents=True, exist_ok=True) shutil.copy(img_src, dir_img_dest) # -------------------------------------------------------------------------- # run mkdocstrings # NB: this function uses the blacklist to filter files at the very end of # the fix process. at this point you can assume ALL dunders in ALL eligible # files have been fixed, as well as paths/filenames. also dict_pub and # dict_prv have been undunderized dict_bl = dict_pub[conf.S_KEY_PUB_BL] # just shorten the names skip_all = dict_bl[conf.S_KEY_SKIP_ALL] skip_contents = dict_bl[conf.S_KEY_SKIP_CONTENTS] # -------------------------------------------------------------------------- # do the fixes files_out = [] # NB: root is a full path, dirs and files are relative to root for root, root_dirs, root_files in dir_prj.walk(): # handle dirs in skip_all if root in skip_all: # NB: don't recurse into subfolders root_dirs.clear() continue # convert files into Paths files = [root / f for f in root_files] files = [f for f in files if f.suffix.lower() == S_EXT_IN] # for each file item for item in files: # handle files in skip_all if item in skip_all: continue # handle dirs/files in skip_contents if not root in skip_contents and not item in skip_contents: # add the python file to the list files_out.append(item) # -------------------------------------------------------------------------- # make structure # make the api folder dir_docs_api = dir_prj / S_DIR_API dir_docs_api.mkdir(parents=True, exist_ok=True) # for each py file for f in files_out: # make a parent folder in docs (goes in nav bar) # NB: basically we find every .py file and get its path relative to # project dir # then we make a folder with the same relative path, but rel to docs # dir path_rel = f.relative_to(dir_prj) path_doc = dir_docs_api / path_rel.parent path_doc.mkdir(parents=True, exist_ok=True) # create a default file # NB: just swap \".py\" ext for \".md\" file_md = path_doc / Path(str(f.stem) + S_EXT_OUT) # fix rel path into package dot notation s_parts = \".\".join(path_rel.parts) if s_parts.endswith(S_EXT_IN): s_parts = s_parts.removesuffix(S_EXT_IN) # format contents of file file_fmt = S_DEF_FILE.format(f.name, s_parts) with open(file_md, \"w\", encoding=conf.S_ENCODING) as a_file: a_file.write(file_fmt) # -------------------------------------------------------------------------- # make docs # format cmd using pdoc template dir, output dir, and start dir cmd_docs = S_CMD_DOC_BUILD.format( p_dir_pp, p_dir_pp_venv, dir_prj, ) # the command to run pdoc try: subprocess.run( cmd_docs, shell=True, check=True, stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT, ) except Exception as e: raise e","title":"mkdocs.py"},{"location":"API/conf/mkdocs/#mkdocspy","text":"This module makes documentation for a project using MkDocs. It uses the project's source files and the config file \"mkdocs.yml\" to create MarkDown files in the \"docs\" folder. It then builds the html file structure in the \"site\" folder. It uses the \"gh-deploy\" program to publish the site to a remote-only branch. It then instructs GitHub Pages to auto-publish your docs at .github.io/ from that branch. As much code/settings/constants as can be are reused from conf.py.","title":"mkdocs.py"},{"location":"API/conf/mkdocs/#conf.mkdocs.deploy_docs","text":"Deploy docs using mkdocs Parameters: Name Type Description Default dir_prj The root of the new project required dict_prv The dictionary containing private pyplate data required dict_pub The dictionary containing public project data required p_dir_pp Path to PyPlate program required p_dir_pp_env Path to PyPlate's venv (to activate pdoc3) required Deploy the documents using the specified parameters. Source code in conf/mkdocs.py def deploy_docs(dir_prj, _dict_prv, _dict_pub, p_dir_pp, p_dir_pp_venv): \"\"\" Deploy docs using mkdocs Args: dir_prj: The root of the new project dict_prv: The dictionary containing private pyplate data dict_pub: The dictionary containing public project data p_dir_pp: Path to PyPlate program p_dir_pp_env: Path to PyPlate's venv (to activate pdoc3) Deploy the documents using the specified parameters. \"\"\" # format cmd using pdoc template dir, output dir, and start dir cmd_docs = S_CMD_DOC_DEPLOY.format( p_dir_pp, p_dir_pp_venv, dir_prj, ) # the command to run mkdocs try: subprocess.run( cmd_docs, shell=True, check=True, stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT, ) except Exception as e: print(S_ERR_NO_REPO) raise e","title":"deploy_docs"},{"location":"API/conf/mkdocs/#conf.mkdocs.make_docs","text":"Make docs using mkdocs Parameters: Name Type Description Default dir_prj The root of the new project required dict_prv The dictionary containing private pyplate data required dict_pub The dictionary containing public project data required p_dir_pp Path to PyPlate program required p_dir_pp_env Path to PyPlate's venv (to activate pdoc3) required Make the documents using the specified parameters. Source code in conf/mkdocs.py def make_docs(dir_prj, dict_prv, dict_pub, p_dir_pp, p_dir_pp_venv): \"\"\" Make docs using mkdocs Args: dir_prj: The root of the new project dict_prv: The dictionary containing private pyplate data dict_pub: The dictionary containing public project data p_dir_pp: Path to PyPlate program p_dir_pp_env: Path to PyPlate's venv (to activate pdoc3) Make the documents using the specified parameters. \"\"\" # where to put the .md files dir_docs_out = dir_prj / conf.S_DIR_DOCS # -------------------------------------------------------------------------- # make yaml # get theme from dict_pub dict_docs = dict_pub[conf.S_KEY_PUB_DOCS] theme = dict_docs.get(conf.S_KEY_DOCS_THEME, \"\") # path to file yaml_file = dir_prj / S_YML_NAME if not yaml_file.exists(): # create a new yaml with default text text = S_YML_TEXT.format(dir_prj.name, theme) # write file with open(yaml_file, \"w\", encoding=conf.S_ENCODING) as a_file: a_file.write(text) # -------------------------------------------------------------------------- # make home page # NB: just copy readme.md to index.md # path to files readme_file = dir_prj / conf.S_FILE_README index_file = dir_docs_out / S_INDEX_NAME if not index_file.exists(): # read input file text = \"\" with open(readme_file, \"r\", encoding=conf.S_ENCODING) as a_file: text = a_file.read() # write file with open(index_file, \"w\", encoding=conf.S_ENCODING) as a_file: a_file.write(text) # copy image for index.md as README.md prj_name = dict_prv[conf.S_KEY_PRV_PRJ][\"__PP_NAME_PRJ_SMALL__\"] prj_img = prj_name + \".png\" img_src = dir_prj / conf.S_DIR_IMAGES / prj_img dir_img_dest = dir_docs_out / conf.S_DIR_IMAGES dir_img_dest.mkdir(parents=True, exist_ok=True) shutil.copy(img_src, dir_img_dest) # -------------------------------------------------------------------------- # run mkdocstrings # NB: this function uses the blacklist to filter files at the very end of # the fix process. at this point you can assume ALL dunders in ALL eligible # files have been fixed, as well as paths/filenames. also dict_pub and # dict_prv have been undunderized dict_bl = dict_pub[conf.S_KEY_PUB_BL] # just shorten the names skip_all = dict_bl[conf.S_KEY_SKIP_ALL] skip_contents = dict_bl[conf.S_KEY_SKIP_CONTENTS] # -------------------------------------------------------------------------- # do the fixes files_out = [] # NB: root is a full path, dirs and files are relative to root for root, root_dirs, root_files in dir_prj.walk(): # handle dirs in skip_all if root in skip_all: # NB: don't recurse into subfolders root_dirs.clear() continue # convert files into Paths files = [root / f for f in root_files] files = [f for f in files if f.suffix.lower() == S_EXT_IN] # for each file item for item in files: # handle files in skip_all if item in skip_all: continue # handle dirs/files in skip_contents if not root in skip_contents and not item in skip_contents: # add the python file to the list files_out.append(item) # -------------------------------------------------------------------------- # make structure # make the api folder dir_docs_api = dir_prj / S_DIR_API dir_docs_api.mkdir(parents=True, exist_ok=True) # for each py file for f in files_out: # make a parent folder in docs (goes in nav bar) # NB: basically we find every .py file and get its path relative to # project dir # then we make a folder with the same relative path, but rel to docs # dir path_rel = f.relative_to(dir_prj) path_doc = dir_docs_api / path_rel.parent path_doc.mkdir(parents=True, exist_ok=True) # create a default file # NB: just swap \".py\" ext for \".md\" file_md = path_doc / Path(str(f.stem) + S_EXT_OUT) # fix rel path into package dot notation s_parts = \".\".join(path_rel.parts) if s_parts.endswith(S_EXT_IN): s_parts = s_parts.removesuffix(S_EXT_IN) # format contents of file file_fmt = S_DEF_FILE.format(f.name, s_parts) with open(file_md, \"w\", encoding=conf.S_ENCODING) as a_file: a_file.write(file_fmt) # -------------------------------------------------------------------------- # make docs # format cmd using pdoc template dir, output dir, and start dir cmd_docs = S_CMD_DOC_BUILD.format( p_dir_pp, p_dir_pp_venv, dir_prj, ) # the command to run pdoc try: subprocess.run( cmd_docs, shell=True, check=True, stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT, ) except Exception as e: raise e","title":"make_docs"},{"location":"API/conf/pdoc/","text":"pdoc.py This module makes documentation for a project using PDoc3. It uses the project's source files and the config files in the \"pdoc3\" folder to create html files in the \"docs\" folder. It then tweaks the file structure to allow GitHub Pages to auto-publish your docs at .github.io/ . It also fixes the version number and icon for your docs. As much code/settings/constants as can be are reused from conf.py. make_docs(dir_prj, dict_prv, _dict_pub, p_dir_pp, p_dir_pp_venv) Make docs using pdoc3 Parameters: Name Type Description Default dir_prj The root of the new project required dict_prv The dictionary containing private pyplate data required dict_pub The dictionary containing public project data required p_dir_pp Path to PyPlate program required p_dir_pp_env Path to PyPlate's venv (to activate pdoc3) required Fix version number, make the docs, move the docs, and fix the icon paths. Source code in conf/pdoc.py def make_docs(dir_prj, dict_prv, _dict_pub, p_dir_pp, p_dir_pp_venv): \"\"\" Make docs using pdoc3 Args: dir_prj: The root of the new project dict_prv: The dictionary containing private pyplate data dict_pub: The dictionary containing public project data p_dir_pp: Path to PyPlate program p_dir_pp_env: Path to PyPlate's venv (to activate pdoc3) Fix version number, make the docs, move the docs, and fix the icon paths. \"\"\" # -------------------------------------------------------------------------- # nuke / remake docs dir dir_docs_out = dir_prj / conf.S_DIR_DOCS # nuke old docs if dir_docs_out.exists(): # delete and recreate docs dir shutil.rmtree(dir_docs_out) dir_docs_out.mkdir(parents=True) # -------------------------------------------------------------------------- # fix version path_mako = dir_prj / S_PATH_MAKO # open and read whole file with open(path_mako, \"r\", encoding=conf.S_ENCODING) as a_file: text = a_file.read() # replace version str_pattern = conf.S_RM_VER_SCH pp_ver_disp = dict_prv[conf.S_KEY_PRV_PRJ][\"__PP_VER_DISP__\"] str_rep = conf.S_RM_VER_REP.format(pp_ver_disp) text = re.sub(str_pattern, str_rep, text, flags=re.S) # save file with open(path_mako, \"w\", encoding=conf.S_ENCODING) as a_file: a_file.write(text) # -------------------------------------------------------------------------- # make docs # get template and output dirs dir_docs_tplt = dir_prj / S_DIR_PDOC # format cmd using pdoc template dir, output dir, and start dir cmd_docs = S_CMD_DOC.format( p_dir_pp, p_dir_pp_venv, dir_prj, dir_docs_tplt, dir_docs_out, dir_prj, ) # the command to run pdoc try: subprocess.run( cmd_docs, shell=True, check=True, stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT, ) except Exception as e: raise e # -------------------------------------------------------------------------- # fix location # find the inner docs folder (named for src dir) dir_docs = dir_docs_out / dir_prj.name # get all files/dirs in inner dir files = list(dir_docs.iterdir()) # move all files/dirs up one level for file in files: shutil.move(file, dir_docs_out) # delete empty inner dir dir_docs.rmdir() # -------------------------------------------------------------------------- # copy image # make the inner img dir dir_docs_img = dir_docs_out / S_DIR_IMG dir_docs_img.mkdir(parents=True) # copy image to inner img dir img_src = dir_prj / dict_prv[conf.S_KEY_PRV_PRJ][\"__PP_IMG_README__\"] shutil.copy(img_src, dir_docs_img) # -------------------------------------------------------------------------- # fix image # where is the image now? img_file = Path(S_DIR_IMG) / img_src.name # make sure we got a dot ext s_html_ext = S_HTML_EXT if S_HTML_EXT.startswith(\".\") else \".\" + S_HTML_EXT # walk the docs tree for root, _dirs, files in dir_docs_out.walk(): # get full paths and filter for html files files = [root / f for f in files] files = [f for f in files if f.suffix.lower() == s_html_ext.lower()] # for eac html file for f in files: # get it's rel path to docs folder path_rel = f.relative_to(dir_docs_out) # calculate number of ups based on depth from docs # NB: subtract 1 for no dots if same parent level = len(path_rel.parents) - 1 # build the dots, one set for each level dots = \"\" for _i in range(level): dots += \"../\" # add the image path rel to prj dir dots += str(img_file) # format the rep str img_rep = S_DOC_IMG_REP.format(dots) # open html file for read with open(f, \"r\", encoding=conf.S_ENCODING) as a_file: text = a_file.read() # replace img src with dots text = re.sub(S_DOC_IMG_SCH, img_rep, text, flags=re.S) # write text back to file with open(f, \"w\", encoding=conf.S_ENCODING) as a_file: a_file.write(text)","title":"pdoc.py"},{"location":"API/conf/pdoc/#pdocpy","text":"This module makes documentation for a project using PDoc3. It uses the project's source files and the config files in the \"pdoc3\" folder to create html files in the \"docs\" folder. It then tweaks the file structure to allow GitHub Pages to auto-publish your docs at .github.io/ . It also fixes the version number and icon for your docs. As much code/settings/constants as can be are reused from conf.py.","title":"pdoc.py"},{"location":"API/conf/pdoc/#conf.pdoc.make_docs","text":"Make docs using pdoc3 Parameters: Name Type Description Default dir_prj The root of the new project required dict_prv The dictionary containing private pyplate data required dict_pub The dictionary containing public project data required p_dir_pp Path to PyPlate program required p_dir_pp_env Path to PyPlate's venv (to activate pdoc3) required Fix version number, make the docs, move the docs, and fix the icon paths. Source code in conf/pdoc.py def make_docs(dir_prj, dict_prv, _dict_pub, p_dir_pp, p_dir_pp_venv): \"\"\" Make docs using pdoc3 Args: dir_prj: The root of the new project dict_prv: The dictionary containing private pyplate data dict_pub: The dictionary containing public project data p_dir_pp: Path to PyPlate program p_dir_pp_env: Path to PyPlate's venv (to activate pdoc3) Fix version number, make the docs, move the docs, and fix the icon paths. \"\"\" # -------------------------------------------------------------------------- # nuke / remake docs dir dir_docs_out = dir_prj / conf.S_DIR_DOCS # nuke old docs if dir_docs_out.exists(): # delete and recreate docs dir shutil.rmtree(dir_docs_out) dir_docs_out.mkdir(parents=True) # -------------------------------------------------------------------------- # fix version path_mako = dir_prj / S_PATH_MAKO # open and read whole file with open(path_mako, \"r\", encoding=conf.S_ENCODING) as a_file: text = a_file.read() # replace version str_pattern = conf.S_RM_VER_SCH pp_ver_disp = dict_prv[conf.S_KEY_PRV_PRJ][\"__PP_VER_DISP__\"] str_rep = conf.S_RM_VER_REP.format(pp_ver_disp) text = re.sub(str_pattern, str_rep, text, flags=re.S) # save file with open(path_mako, \"w\", encoding=conf.S_ENCODING) as a_file: a_file.write(text) # -------------------------------------------------------------------------- # make docs # get template and output dirs dir_docs_tplt = dir_prj / S_DIR_PDOC # format cmd using pdoc template dir, output dir, and start dir cmd_docs = S_CMD_DOC.format( p_dir_pp, p_dir_pp_venv, dir_prj, dir_docs_tplt, dir_docs_out, dir_prj, ) # the command to run pdoc try: subprocess.run( cmd_docs, shell=True, check=True, stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT, ) except Exception as e: raise e # -------------------------------------------------------------------------- # fix location # find the inner docs folder (named for src dir) dir_docs = dir_docs_out / dir_prj.name # get all files/dirs in inner dir files = list(dir_docs.iterdir()) # move all files/dirs up one level for file in files: shutil.move(file, dir_docs_out) # delete empty inner dir dir_docs.rmdir() # -------------------------------------------------------------------------- # copy image # make the inner img dir dir_docs_img = dir_docs_out / S_DIR_IMG dir_docs_img.mkdir(parents=True) # copy image to inner img dir img_src = dir_prj / dict_prv[conf.S_KEY_PRV_PRJ][\"__PP_IMG_README__\"] shutil.copy(img_src, dir_docs_img) # -------------------------------------------------------------------------- # fix image # where is the image now? img_file = Path(S_DIR_IMG) / img_src.name # make sure we got a dot ext s_html_ext = S_HTML_EXT if S_HTML_EXT.startswith(\".\") else \".\" + S_HTML_EXT # walk the docs tree for root, _dirs, files in dir_docs_out.walk(): # get full paths and filter for html files files = [root / f for f in files] files = [f for f in files if f.suffix.lower() == s_html_ext.lower()] # for eac html file for f in files: # get it's rel path to docs folder path_rel = f.relative_to(dir_docs_out) # calculate number of ups based on depth from docs # NB: subtract 1 for no dots if same parent level = len(path_rel.parents) - 1 # build the dots, one set for each level dots = \"\" for _i in range(level): dots += \"../\" # add the image path rel to prj dir dots += str(img_file) # format the rep str img_rep = S_DOC_IMG_REP.format(dots) # open html file for read with open(f, \"r\", encoding=conf.S_ENCODING) as a_file: text = a_file.read() # replace img src with dots text = re.sub(S_DOC_IMG_SCH, img_rep, text, flags=re.S) # write text back to file with open(f, \"w\", encoding=conf.S_ENCODING) as a_file: a_file.write(text)","title":"make_docs"},{"location":"API/install/install/","text":"install.py The install script for this project THis module installs the project, copying its files and folders to the appropriate locations on the user's computer. This file is real ugly b/c we can't access the venv, so we do it manually. CNFormatter Bases: RawTextHelpFormatter , RawDescriptionHelpFormatter A dummy class to combine multiple argparse formatters Parameters: Name Type Description Default RawTextHelpFormatter Maintains whitespace for all sorts of help text, required RawDescriptionHelpFormatter Indicates that description and epilog are required A dummy class to combine multiple argparse formatters. Source code in install/install.py class CNFormatter( argparse.RawTextHelpFormatter, argparse.RawDescriptionHelpFormatter ): \"\"\" A dummy class to combine multiple argparse formatters Args: RawTextHelpFormatter: Maintains whitespace for all sorts of help text, including argument descriptions. RawDescriptionHelpFormatter: Indicates that description and epilog are already correctly formatted and should not be line-wrapped. A dummy class to combine multiple argparse formatters. \"\"\" CNInstall The class to use for installing a PyPlate program This class performs the install operation. Source code in install/install.py class CNInstall: \"\"\" The class to use for installing a PyPlate program This class performs the install operation. \"\"\" # -------------------------------------------------------------------------- # Class constants # -------------------------------------------------------------------------- # keys S_KEY_INST_NAME = \"INST_NAME\" S_KEY_INST_VER = \"INST_VER\" S_KEY_INST_DESK = \"INST_DESK\" S_KEY_INST_CONT = \"INST_CONT\" # short description # NB: MUST BE ALL ON ONE LINE!!! # I18N: short desc in installer S_PP_SHORT_DESC = _(\"foobar\") # version string # NB: MUST BE ALL ON ONE LINE!!! S_PP_VERSION = \"0.0.3\" # debug option strings S_ARG_DRY_OPTION = \"-d\" S_ARG_DRY_ACTION = \"store_true\" S_ARG_DRY_DEST = \"DRY_DEST\" # I18N help string for debug cmd line option S_ARG_DRY_HELP = _(\"enable dry run mode\") # config option strings S_ARG_HLP_OPTION = \"-h\" S_ARG_HLP_ACTION = \"store_true\" S_ARG_HLP_DEST = \"HLP_DEST\" # I18N: help option help S_ARG_HLP_HELP = _(\"show this help message and exit\") # about string (to be set by subclass) S_ABOUT = ( \"\\n\" \"PyPlate\\n\" f\"{S_PP_SHORT_DESC}\\n\" f\"{S_PP_VERSION}\\n\" \"https://github.com/cyclopticnerve/PyPlate\\n\" ) # I18N if using argparse, add help at end of about S_ABOUT_HELP = _(\"Use -h for help\") # cmd line instructions string S_EPILOG = \"\" # -------------------------------------------------------------------------- # messages # NB: format params are prog_name and prog_version # I18N: install the program S_MSG_INST_START = _(\"Installing {} Version {}\") # NB: format param is prog_name # I18N: done installing S_MSG_INST_END = _(\"{} installed\") # I18N: done with step S_MSG_DONE = _(\"Done\") # I18N: step failed S_MSG_FAIL = _(\"Fail\") # I18N: show the copy step S_MSG_COPY_START = _(\"Copying files... \") # I18N: show the venv step S_MSG_VENV_START = _(\"Making venv folder... \") # I18N: show the reqs step S_MSG_REQS_START = _(\"Installing requirements... \") # I18N: show desktop step S_MSG_DSK_START = _(\"Fixing .desktop file... \") # I18N: install aborted S_MSG_ABORT = _(\"Installation aborted\") # questions # I18N: ask to overwrite same version S_ASK_VER_INST = _(\"The current version of this program will be installed.\\nDo you want to continue? [Y/n] \") # I18N: ask to overwrite same version S_ASK_VER_SAME = _(\"The current version of this program is already installed.\\nDo you want to overwrite? [y/N] \") # I18N: ask to overwrite newer version S_ASK_VER_OLDER = _(\"A newer version of this program is currently installed.\\nDo you want to overwrite? [y/N] \") # I18N: confirm overwrite install S_ASK_CONFIRM = _(\"y\") # errors # NB: format param is file path # I18N: config file not found S_ERR_NOT_FOUND = _(\"File {} not found\") # NB: format param is file path # I18N: config file is not valid json S_ERR_NOT_JSON = _(\"File {} is not a JSON file\") # I18N: version numbers invalid S_ERR_VERSION = _(\"One or both version numbers are invalid\") # NB: format param is source path # I18N: src path invalid S_ERR_SRC_PATH = _(\"Source path can not be {}\") # NB: format param is dest path # I18N: dst path invalid S_ERR_DST_PATH = _(\"Destination path can not be {}\") # dry run messages S_DRY_VENV = \"\\nvenv cmd:\" S_DRY_REQS = \"\\nreqs cmd:\" # NB: format params are source and destination file/dir S_DRY_COPY = \"\\ncopy\\n{}\\nto\\n{}\" # NB: format param is path to icon S_DRY_DESK_ICON = \"set desktop icon: {}\" # commands # NB: format param is dir_venv S_CMD_CREATE = \"python -m venv {}\" # NB: format params are path to prj, path to venv, and path to reqs file S_CMD_INSTALL = \"cd {};. {}/bin/activate;python -m pip install -r {}\" # regex # regex to compare version numbers R_VERSION = r\"(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(.*)$\" R_VERSION_GROUP_MAJ = 1 R_VERSION_GROUP_MIN = 2 R_VERSION_GROUP_REV = 3 # regex for adding user's home to icon path R_ICON_SCH = r\"^(Icon=)(.*)$\" R_ICON_REP = r\"\\g<1>{}\" # Icon=<home/__PP_IMG_DESK__> # -------------------------------------------------------------------------- # Class methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Initialize the class # -------------------------------------------------------------------------- def __init__(self): \"\"\" Initialize the class Creates a new instance of the object and initializes its properties. \"\"\" # set arg properties self._dict_args = {} self._dry_run = False # project stuff # NB: set to path objects to avoid comparing to None self._dir_assets = Path() self._dir_usr_inst = Path() self._path_cfg_inst = Path() self._path_cfg_uninst = Path() self._dir_venv = Path() self._path_reqs = Path() self._file_desk = Path() self._file_desk_icon = Path() # config stuff self._dict_cfg = {} # cmd line stuff # NB: placeholder to avoid comparing to None self._parser = argparse.ArgumentParser() # -------------------------------------------------------------------------- # Install the program # -------------------------------------------------------------------------- def main( self, dir_assets, dir_usr_inst, path_cfg_inst, path_cfg_uninst, dir_venv, path_reqs, file_desk=None, file_desk_icon=None, ): \"\"\" Install the program Args: dir_assets: Path to the assets folder where all of the program files are put in dist. This is the base source path to use when copying files to the user's computer dir_usr_inst: The program's install folder in which to place files path_cfg_inst: Path to the file that contains the current install dict info path_cfg_uninst: Path to the currently installed program's uninstall dict info dir_venv: The path to the venv folder to create path_reqs: Path to the requirements.txt file to add requirements to the venv file_desk: Path to the .desktop file (if GUI) (default: None) file_desk_icon: Path to the .desktop file icon (if GUI) (default: None) Runs the install operation. \"\"\" # set props from params if dir_assets: dir_assets = Path(dir_assets) if not dir_assets.is_absolute(): # make abs rel to self dir_assets = P_DIR_PRJ / dir_assets self._dir_assets = dir_assets if dir_usr_inst: dir_usr_inst = Path(dir_usr_inst) if not dir_usr_inst.is_absolute(): # make abs rel to self dir_usr_inst = self._dir_assets / dir_usr_inst self._dir_usr_inst = dir_usr_inst if path_cfg_inst: path_cfg_inst = Path(path_cfg_inst) if not path_cfg_inst.is_absolute(): # make abs rel to self path_cfg_inst = self._dir_assets / path_cfg_inst self._path_cfg_inst = path_cfg_inst if path_cfg_uninst: path_cfg_uninst = Path(path_cfg_uninst) if not path_cfg_uninst.is_absolute(): # make abs rel to self path_cfg_uninst = self._dir_assets / path_cfg_uninst self._path_cfg_uninst = path_cfg_uninst if dir_venv: dir_venv = Path(dir_venv) if not dir_venv.is_absolute(): # make abs rel to self dir_venv = self._dir_assets / dir_venv self._dir_venv = dir_venv if path_reqs: path_reqs = Path(path_reqs) if not path_reqs.is_absolute(): # make abs rel to self path_reqs = self._dir_assets / path_reqs self._path_reqs = path_reqs if file_desk: file_desk = Path(file_desk) if not file_desk.is_absolute(): # make abs rel to self file_desk = self._dir_assets / file_desk self._file_desk = file_desk if file_desk_icon: file_desk_icon = Path(file_desk_icon) if not file_desk_icon.is_absolute(): # make abs rel to self file_desk_icon = self._dir_assets / file_desk_icon self._file_desk_icon = file_desk_icon # ---------------------------------------------------------------------- # do setup self._setup() # parse cmd line and get args self._do_cmd_line() # get prj info from cfg self._get_project_info() # check for existing/old version self._check_ver() # make the venv on the user's comp self._make_venv() # install reqs self._install_reqs() # fix desktop file if present self._fix_desktop_file() # move content self._install_content() # wind down self._teardown() # -------------------------------------------------------------------------- # Private methods # -------------------------------------------------------------------------- # NB: these are the main steps, called in order from main() # -------------------------------------------------------------------------- # Boilerplate to use at the start of main # -------------------------------------------------------------------------- def _setup(self): \"\"\" Boilerplate to use at the start of main Perform some mundane stuff like setting properties. \"\"\" # print default about text print(self.S_ABOUT) # create a parser object in case we need it self._parser = argparse.ArgumentParser( add_help=False, epilog=self.S_EPILOG, formatter_class=CNFormatter, ) # add help text to about block print(self.S_ABOUT_HELP) # add help option self._parser.add_argument( self.S_ARG_HLP_OPTION, dest=self.S_ARG_HLP_DEST, help=self.S_ARG_HLP_HELP, action=self.S_ARG_HLP_ACTION, ) # add dry run option self._parser.add_argument( self.S_ARG_DRY_OPTION, dest=self.S_ARG_DRY_DEST, help=self.S_ARG_DRY_HELP, action=self.S_ARG_DRY_ACTION, ) # -------------------------------------------------------------------------- # Parse the arguments from the command line # -------------------------------------------------------------------------- def _do_cmd_line(self): \"\"\" Parse the arguments from the command line Parse the arguments from the command line, after the parser has been set up. \"\"\" # get namespace object args = self._parser.parse_args() # convert namespace to dict self._dict_args = vars(args) # if -h passed, this will print and exit if self._dict_args.get(self.S_ARG_HLP_DEST, False): self._parser.print_help() sys.exit() # no -h, print epilog print(self.S_EPILOG) # ---------------------------------------------------------------------- # get the args self._dry_run = self._dict_args.get(self.S_ARG_DRY_DEST, False) # -------------------------------------------------------------------------- # Get project info # -------------------------------------------------------------------------- def _get_project_info(self): \"\"\" Get project info Get the install info from the config file. \"\"\" # get project info self._dict_cfg = self._get_dict_from_file(self._path_cfg_inst) # get prg name/version prog_name = self._dict_cfg[self.S_KEY_INST_NAME] prog_version = self._dict_cfg[self.S_KEY_INST_VER] # print start msg print(self.S_MSG_INST_START.format(prog_name, prog_version)) # -------------------------------------------------------------------------- # Check version info # -------------------------------------------------------------------------- def _check_ver(self): \"\"\" Check version info Get the version info from the new config file and the old config file (if present), compare the two values, and either continue or abort. \"\"\" # if we did pass an old conf, it must exist (if it doesn't, this could # be the first install but we will want to check on later updates) if self._path_cfg_uninst and Path(self._path_cfg_uninst).exists(): # get info from old cfg dict_cfg_old = self._get_dict_from_file(self._path_cfg_uninst) # check versions ver_old = dict_cfg_old[self.S_KEY_INST_VER] ver_new = self._dict_cfg[self.S_KEY_INST_VER] res = self._do_compare_versions(ver_old, ver_new) # same version is installed if res == 0: # ask to install same version str_ask = input(self.S_ASK_VER_SAME) # user hit enter or typed anything else except \"y\" if ( len(str_ask) == 0 or str_ask.lower()[0] != self.S_ASK_CONFIRM ): print(self.S_MSG_ABORT) sys.exit() # newer version is installed elif res == -1: # ask to install old version over newer str_ask = input(self.S_ASK_VER_OLDER) # user hit enter or typed anything else except \"y\" if ( len(str_ask) == 0 or str_ask.lower()[0] != self.S_ASK_CONFIRM ): print(self.S_MSG_ABORT) sys.exit() # fresh install else: # ask to install old version over newer str_ask = input(self.S_ASK_VER_INST) # user hit \"y\" or \"Enter\" if len(str_ask) == 0 or str_ask.lower()[0] == self.S_ASK_CONFIRM: pass else: print(self.S_MSG_ABORT) sys.exit() # -------------------------------------------------------------------------- # Make venv for this program on user's computer # -------------------------------------------------------------------------- def _make_venv(self): \"\"\" Make venv for this program on user's computer Raises: subprocess.CalledProcessError if the venv creation fails Makes a .venv-XXX folder on the user's computer. \"\"\" # show progress print(self.S_MSG_VENV_START, flush=True, end=\"\") # the command to create a venv cmd = self.S_CMD_CREATE.format(self._dir_venv) # if it's a dry run, don't make venv if self._dry_run: print(self.S_DRY_VENV, cmd) print(self.S_MSG_DONE) return # the cmd to create the venv try: subprocess.run(cmd, shell=True, check=True) print(self.S_MSG_DONE) except Exception as e: print(self.S_MSG_FAIL) raise e # -------------------------------------------------------------------------- # Install requirements.txt # -------------------------------------------------------------------------- def _install_reqs(self): \"\"\" Install requirements.txt Raises: subprocess.CalledProcessError if the reqs install fails Installs the contents of a requirements.txt file into the program's venv. \"\"\" # show progress print(self.S_MSG_REQS_START, end=\"\", flush=True) # the command to install packages to venv from reqs cmd = self.S_CMD_INSTALL.format( self._dir_venv.parent, self._dir_venv.name, self._path_reqs ) # if it's a dry run, don't install if self._dry_run: print(self.S_DRY_REQS, cmd) print(self.S_MSG_DONE) return # the cmd to install the reqs try: # NB: hide output subprocess.run( cmd, shell=True, check=True, stdout=subprocess.DEVNULL ) print(self.S_MSG_DONE) except Exception as e: print(self.S_MSG_FAIL) raise e # -------------------------------------------------------------------------- # Fix .desktop file, for paths and such # -------------------------------------------------------------------------- def _fix_desktop_file(self): \"\"\" Fix .desktop file, for paths and such Raises: OSError if one of both of the files does not exist Fixes entries in the .desktop file (absolute paths, etc.) Currently only fixes absolute path to icon. \"\"\" # make sure we even care about desktop use_desk = self._dict_cfg.get(self.S_KEY_INST_DESK, False) if not use_desk: return # check both files for None and exist if not self._file_desk or not self._file_desk.exists(): raise OSError(self.S_ERR_NOT_FOUND.format(self._file_desk)) if not self._file_desk_icon or not self._file_desk_icon.exists(): raise OSError(self.S_ERR_NOT_FOUND.format(self._file_desk_icon)) # print info print(self.S_MSG_DSK_START, end=\"\", flush=True) # don't mess with file if self._dry_run: print(self.S_DRY_DESK_ICON.format(self._file_desk_icon)) print(self.S_MSG_DONE) return # open file text = \"\" with open(self._file_desk, \"r\", encoding=\"UTF-8\") as a_file: text = a_file.read() # find icon line and fix res = re.search(self.R_ICON_SCH, text, flags=re.M) if res: # get user's home and path to icon rel to prj path_icon = Path.home() / self._file_desk_icon # fix abs path to icon r_icon_rep = self.R_ICON_REP.format(path_icon) text = re.sub(self.R_ICON_SCH, r_icon_rep, text, flags=re.M) # ------------------------------------------------------------------ # write fixed text back to file with open(self._file_desk, \"w\", encoding=\"UTF-8\") as a_file: a_file.write(text) # show some info print(self.S_MSG_DONE) # -------------------------------------------------------------------------- # Copy source files/folders # -------------------------------------------------------------------------- def _install_content(self): \"\"\" Copy source files/folders This method copies files and folders from the assets folder of the source to their final locations in the user's folder structure. \"\"\" # show some info print(self.S_MSG_COPY_START, flush=True, end=\"\") # content list from dict content = self._dict_cfg.get(self.S_KEY_INST_CONT, {}) # for each key, value for k, v in content.items(): # get full paths of source / destination src = self._dir_assets / k dst = Path.home() / v / src.name # debug may omit certain assets if not src.exists(): continue # check for dry run if self._dry_run: print(self.S_DRY_COPY.format(src, dst)) else: # if the source is a dir if src.is_dir(): shutil.copytree(src, dst, dirs_exist_ok=True) # if the src is a file else: shutil.copy(src, dst) # show some info print(self.S_MSG_DONE) # -------------------------------------------------------------------------- # Boilerplate to use at the end of main # -------------------------------------------------------------------------- def _teardown(self): \"\"\" Boilerplate to use at the end of main Perform some mundane stuff like saving config files. \"\"\" # just show we are done prog_name = self._dict_cfg[self.S_KEY_INST_NAME] print(self.S_MSG_INST_END.format(prog_name)) # -------------------------------------------------------------------------- # These are the minor steps, called from major steps for support # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Get a dict from a file # -------------------------------------------------------------------------- def _get_dict_from_file(self, a_file): \"\"\" Get a dict from a file Args: a_file: The file to load the dict from Raises: OSError if the file cannot be found or is not a valid JSON file Returns: The dict found in the file Get a dict from a file, checking if the file exists and is a valid JSON file \"\"\" # default result a_dict = {} # get dict from file try: with open(a_file, \"r\", encoding=\"UTF-8\") as a_file: a_dict = json.load(a_file) # file not found except FileNotFoundError as e: raise OSError(self.S_ERR_NOT_FOUND.format(a_file)) from e # not valid json in file except json.JSONDecodeError as e: raise OSError(self.S_ERR_NOT_JSON.format(a_file)) from e # return result return a_dict # -------------------------------------------------------------------------- # Compare two version strings for relativity # -------------------------------------------------------------------------- def _do_compare_versions(self, ver_old, ver_new): \"\"\" Compare two version strings for relativity Args: ver_old: Old version string ver_new: New version string Returns: An integer representing the relativity of the two version strings. 0 means the two versions are equal, 1 means new_ver is newer than old_ver (or there is no old_ver), and -1 means new_ver is older than old_ver. This method compares two version strings and determines which is older, which is newer, or if they are equal. Note that this method converts only the first three parts of a semantic version string (https://semver.org/). \"\"\" # test for new install (don't try to regex) if ver_old == \"\": return 1 # test for equal (just save some cpu cycles) if ver_old == ver_new: return 0 # compare version string parts (only x.x.x) res_old = re.search(self.R_VERSION, ver_old) res_new = re.search(self.R_VERSION, ver_new) # if both version strings are valid if res_old and res_new: # make a list of groups to check lst_groups = [ self.R_VERSION_GROUP_MAJ, self.R_VERSION_GROUP_MIN, self.R_VERSION_GROUP_REV, ] # for each part as int for group in lst_groups: old_val = int(res_old.group(group)) new_val = int(res_new.group(group)) # slide out at the first difference if old_val < new_val: return 1 elif old_val > new_val: return -1 else: continue else: raise OSError(self.S_ERR_VERSION) # return 0 if equal return 0 __init__() Initialize the class Creates a new instance of the object and initializes its properties. Source code in install/install.py def __init__(self): \"\"\" Initialize the class Creates a new instance of the object and initializes its properties. \"\"\" # set arg properties self._dict_args = {} self._dry_run = False # project stuff # NB: set to path objects to avoid comparing to None self._dir_assets = Path() self._dir_usr_inst = Path() self._path_cfg_inst = Path() self._path_cfg_uninst = Path() self._dir_venv = Path() self._path_reqs = Path() self._file_desk = Path() self._file_desk_icon = Path() # config stuff self._dict_cfg = {} # cmd line stuff # NB: placeholder to avoid comparing to None self._parser = argparse.ArgumentParser() main(dir_assets, dir_usr_inst, path_cfg_inst, path_cfg_uninst, dir_venv, path_reqs, file_desk=None, file_desk_icon=None) Install the program Parameters: Name Type Description Default dir_assets Path to the assets folder where all of the program required dir_usr_inst The program's install folder in which to place files required path_cfg_inst Path to the file that contains the current install required path_cfg_uninst Path to the currently installed program's required dir_venv The path to the venv folder to create required path_reqs Path to the requirements.txt file to add requirements to required file_desk Path to the .desktop file (if GUI) (default: None) None file_desk_icon Path to the .desktop file icon (if GUI) (default: None Runs the install operation. Source code in install/install.py def main( self, dir_assets, dir_usr_inst, path_cfg_inst, path_cfg_uninst, dir_venv, path_reqs, file_desk=None, file_desk_icon=None, ): \"\"\" Install the program Args: dir_assets: Path to the assets folder where all of the program files are put in dist. This is the base source path to use when copying files to the user's computer dir_usr_inst: The program's install folder in which to place files path_cfg_inst: Path to the file that contains the current install dict info path_cfg_uninst: Path to the currently installed program's uninstall dict info dir_venv: The path to the venv folder to create path_reqs: Path to the requirements.txt file to add requirements to the venv file_desk: Path to the .desktop file (if GUI) (default: None) file_desk_icon: Path to the .desktop file icon (if GUI) (default: None) Runs the install operation. \"\"\" # set props from params if dir_assets: dir_assets = Path(dir_assets) if not dir_assets.is_absolute(): # make abs rel to self dir_assets = P_DIR_PRJ / dir_assets self._dir_assets = dir_assets if dir_usr_inst: dir_usr_inst = Path(dir_usr_inst) if not dir_usr_inst.is_absolute(): # make abs rel to self dir_usr_inst = self._dir_assets / dir_usr_inst self._dir_usr_inst = dir_usr_inst if path_cfg_inst: path_cfg_inst = Path(path_cfg_inst) if not path_cfg_inst.is_absolute(): # make abs rel to self path_cfg_inst = self._dir_assets / path_cfg_inst self._path_cfg_inst = path_cfg_inst if path_cfg_uninst: path_cfg_uninst = Path(path_cfg_uninst) if not path_cfg_uninst.is_absolute(): # make abs rel to self path_cfg_uninst = self._dir_assets / path_cfg_uninst self._path_cfg_uninst = path_cfg_uninst if dir_venv: dir_venv = Path(dir_venv) if not dir_venv.is_absolute(): # make abs rel to self dir_venv = self._dir_assets / dir_venv self._dir_venv = dir_venv if path_reqs: path_reqs = Path(path_reqs) if not path_reqs.is_absolute(): # make abs rel to self path_reqs = self._dir_assets / path_reqs self._path_reqs = path_reqs if file_desk: file_desk = Path(file_desk) if not file_desk.is_absolute(): # make abs rel to self file_desk = self._dir_assets / file_desk self._file_desk = file_desk if file_desk_icon: file_desk_icon = Path(file_desk_icon) if not file_desk_icon.is_absolute(): # make abs rel to self file_desk_icon = self._dir_assets / file_desk_icon self._file_desk_icon = file_desk_icon # ---------------------------------------------------------------------- # do setup self._setup() # parse cmd line and get args self._do_cmd_line() # get prj info from cfg self._get_project_info() # check for existing/old version self._check_ver() # make the venv on the user's comp self._make_venv() # install reqs self._install_reqs() # fix desktop file if present self._fix_desktop_file() # move content self._install_content() # wind down self._teardown()","title":"install.py"},{"location":"API/install/install/#installpy","text":"The install script for this project THis module installs the project, copying its files and folders to the appropriate locations on the user's computer. This file is real ugly b/c we can't access the venv, so we do it manually.","title":"install.py"},{"location":"API/install/install/#install.install.CNFormatter","text":"Bases: RawTextHelpFormatter , RawDescriptionHelpFormatter A dummy class to combine multiple argparse formatters Parameters: Name Type Description Default RawTextHelpFormatter Maintains whitespace for all sorts of help text, required RawDescriptionHelpFormatter Indicates that description and epilog are required A dummy class to combine multiple argparse formatters. Source code in install/install.py class CNFormatter( argparse.RawTextHelpFormatter, argparse.RawDescriptionHelpFormatter ): \"\"\" A dummy class to combine multiple argparse formatters Args: RawTextHelpFormatter: Maintains whitespace for all sorts of help text, including argument descriptions. RawDescriptionHelpFormatter: Indicates that description and epilog are already correctly formatted and should not be line-wrapped. A dummy class to combine multiple argparse formatters. \"\"\"","title":"CNFormatter"},{"location":"API/install/install/#install.install.CNInstall","text":"The class to use for installing a PyPlate program This class performs the install operation. Source code in install/install.py class CNInstall: \"\"\" The class to use for installing a PyPlate program This class performs the install operation. \"\"\" # -------------------------------------------------------------------------- # Class constants # -------------------------------------------------------------------------- # keys S_KEY_INST_NAME = \"INST_NAME\" S_KEY_INST_VER = \"INST_VER\" S_KEY_INST_DESK = \"INST_DESK\" S_KEY_INST_CONT = \"INST_CONT\" # short description # NB: MUST BE ALL ON ONE LINE!!! # I18N: short desc in installer S_PP_SHORT_DESC = _(\"foobar\") # version string # NB: MUST BE ALL ON ONE LINE!!! S_PP_VERSION = \"0.0.3\" # debug option strings S_ARG_DRY_OPTION = \"-d\" S_ARG_DRY_ACTION = \"store_true\" S_ARG_DRY_DEST = \"DRY_DEST\" # I18N help string for debug cmd line option S_ARG_DRY_HELP = _(\"enable dry run mode\") # config option strings S_ARG_HLP_OPTION = \"-h\" S_ARG_HLP_ACTION = \"store_true\" S_ARG_HLP_DEST = \"HLP_DEST\" # I18N: help option help S_ARG_HLP_HELP = _(\"show this help message and exit\") # about string (to be set by subclass) S_ABOUT = ( \"\\n\" \"PyPlate\\n\" f\"{S_PP_SHORT_DESC}\\n\" f\"{S_PP_VERSION}\\n\" \"https://github.com/cyclopticnerve/PyPlate\\n\" ) # I18N if using argparse, add help at end of about S_ABOUT_HELP = _(\"Use -h for help\") # cmd line instructions string S_EPILOG = \"\" # -------------------------------------------------------------------------- # messages # NB: format params are prog_name and prog_version # I18N: install the program S_MSG_INST_START = _(\"Installing {} Version {}\") # NB: format param is prog_name # I18N: done installing S_MSG_INST_END = _(\"{} installed\") # I18N: done with step S_MSG_DONE = _(\"Done\") # I18N: step failed S_MSG_FAIL = _(\"Fail\") # I18N: show the copy step S_MSG_COPY_START = _(\"Copying files... \") # I18N: show the venv step S_MSG_VENV_START = _(\"Making venv folder... \") # I18N: show the reqs step S_MSG_REQS_START = _(\"Installing requirements... \") # I18N: show desktop step S_MSG_DSK_START = _(\"Fixing .desktop file... \") # I18N: install aborted S_MSG_ABORT = _(\"Installation aborted\") # questions # I18N: ask to overwrite same version S_ASK_VER_INST = _(\"The current version of this program will be installed.\\nDo you want to continue? [Y/n] \") # I18N: ask to overwrite same version S_ASK_VER_SAME = _(\"The current version of this program is already installed.\\nDo you want to overwrite? [y/N] \") # I18N: ask to overwrite newer version S_ASK_VER_OLDER = _(\"A newer version of this program is currently installed.\\nDo you want to overwrite? [y/N] \") # I18N: confirm overwrite install S_ASK_CONFIRM = _(\"y\") # errors # NB: format param is file path # I18N: config file not found S_ERR_NOT_FOUND = _(\"File {} not found\") # NB: format param is file path # I18N: config file is not valid json S_ERR_NOT_JSON = _(\"File {} is not a JSON file\") # I18N: version numbers invalid S_ERR_VERSION = _(\"One or both version numbers are invalid\") # NB: format param is source path # I18N: src path invalid S_ERR_SRC_PATH = _(\"Source path can not be {}\") # NB: format param is dest path # I18N: dst path invalid S_ERR_DST_PATH = _(\"Destination path can not be {}\") # dry run messages S_DRY_VENV = \"\\nvenv cmd:\" S_DRY_REQS = \"\\nreqs cmd:\" # NB: format params are source and destination file/dir S_DRY_COPY = \"\\ncopy\\n{}\\nto\\n{}\" # NB: format param is path to icon S_DRY_DESK_ICON = \"set desktop icon: {}\" # commands # NB: format param is dir_venv S_CMD_CREATE = \"python -m venv {}\" # NB: format params are path to prj, path to venv, and path to reqs file S_CMD_INSTALL = \"cd {};. {}/bin/activate;python -m pip install -r {}\" # regex # regex to compare version numbers R_VERSION = r\"(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(.*)$\" R_VERSION_GROUP_MAJ = 1 R_VERSION_GROUP_MIN = 2 R_VERSION_GROUP_REV = 3 # regex for adding user's home to icon path R_ICON_SCH = r\"^(Icon=)(.*)$\" R_ICON_REP = r\"\\g<1>{}\" # Icon=<home/__PP_IMG_DESK__> # -------------------------------------------------------------------------- # Class methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Initialize the class # -------------------------------------------------------------------------- def __init__(self): \"\"\" Initialize the class Creates a new instance of the object and initializes its properties. \"\"\" # set arg properties self._dict_args = {} self._dry_run = False # project stuff # NB: set to path objects to avoid comparing to None self._dir_assets = Path() self._dir_usr_inst = Path() self._path_cfg_inst = Path() self._path_cfg_uninst = Path() self._dir_venv = Path() self._path_reqs = Path() self._file_desk = Path() self._file_desk_icon = Path() # config stuff self._dict_cfg = {} # cmd line stuff # NB: placeholder to avoid comparing to None self._parser = argparse.ArgumentParser() # -------------------------------------------------------------------------- # Install the program # -------------------------------------------------------------------------- def main( self, dir_assets, dir_usr_inst, path_cfg_inst, path_cfg_uninst, dir_venv, path_reqs, file_desk=None, file_desk_icon=None, ): \"\"\" Install the program Args: dir_assets: Path to the assets folder where all of the program files are put in dist. This is the base source path to use when copying files to the user's computer dir_usr_inst: The program's install folder in which to place files path_cfg_inst: Path to the file that contains the current install dict info path_cfg_uninst: Path to the currently installed program's uninstall dict info dir_venv: The path to the venv folder to create path_reqs: Path to the requirements.txt file to add requirements to the venv file_desk: Path to the .desktop file (if GUI) (default: None) file_desk_icon: Path to the .desktop file icon (if GUI) (default: None) Runs the install operation. \"\"\" # set props from params if dir_assets: dir_assets = Path(dir_assets) if not dir_assets.is_absolute(): # make abs rel to self dir_assets = P_DIR_PRJ / dir_assets self._dir_assets = dir_assets if dir_usr_inst: dir_usr_inst = Path(dir_usr_inst) if not dir_usr_inst.is_absolute(): # make abs rel to self dir_usr_inst = self._dir_assets / dir_usr_inst self._dir_usr_inst = dir_usr_inst if path_cfg_inst: path_cfg_inst = Path(path_cfg_inst) if not path_cfg_inst.is_absolute(): # make abs rel to self path_cfg_inst = self._dir_assets / path_cfg_inst self._path_cfg_inst = path_cfg_inst if path_cfg_uninst: path_cfg_uninst = Path(path_cfg_uninst) if not path_cfg_uninst.is_absolute(): # make abs rel to self path_cfg_uninst = self._dir_assets / path_cfg_uninst self._path_cfg_uninst = path_cfg_uninst if dir_venv: dir_venv = Path(dir_venv) if not dir_venv.is_absolute(): # make abs rel to self dir_venv = self._dir_assets / dir_venv self._dir_venv = dir_venv if path_reqs: path_reqs = Path(path_reqs) if not path_reqs.is_absolute(): # make abs rel to self path_reqs = self._dir_assets / path_reqs self._path_reqs = path_reqs if file_desk: file_desk = Path(file_desk) if not file_desk.is_absolute(): # make abs rel to self file_desk = self._dir_assets / file_desk self._file_desk = file_desk if file_desk_icon: file_desk_icon = Path(file_desk_icon) if not file_desk_icon.is_absolute(): # make abs rel to self file_desk_icon = self._dir_assets / file_desk_icon self._file_desk_icon = file_desk_icon # ---------------------------------------------------------------------- # do setup self._setup() # parse cmd line and get args self._do_cmd_line() # get prj info from cfg self._get_project_info() # check for existing/old version self._check_ver() # make the venv on the user's comp self._make_venv() # install reqs self._install_reqs() # fix desktop file if present self._fix_desktop_file() # move content self._install_content() # wind down self._teardown() # -------------------------------------------------------------------------- # Private methods # -------------------------------------------------------------------------- # NB: these are the main steps, called in order from main() # -------------------------------------------------------------------------- # Boilerplate to use at the start of main # -------------------------------------------------------------------------- def _setup(self): \"\"\" Boilerplate to use at the start of main Perform some mundane stuff like setting properties. \"\"\" # print default about text print(self.S_ABOUT) # create a parser object in case we need it self._parser = argparse.ArgumentParser( add_help=False, epilog=self.S_EPILOG, formatter_class=CNFormatter, ) # add help text to about block print(self.S_ABOUT_HELP) # add help option self._parser.add_argument( self.S_ARG_HLP_OPTION, dest=self.S_ARG_HLP_DEST, help=self.S_ARG_HLP_HELP, action=self.S_ARG_HLP_ACTION, ) # add dry run option self._parser.add_argument( self.S_ARG_DRY_OPTION, dest=self.S_ARG_DRY_DEST, help=self.S_ARG_DRY_HELP, action=self.S_ARG_DRY_ACTION, ) # -------------------------------------------------------------------------- # Parse the arguments from the command line # -------------------------------------------------------------------------- def _do_cmd_line(self): \"\"\" Parse the arguments from the command line Parse the arguments from the command line, after the parser has been set up. \"\"\" # get namespace object args = self._parser.parse_args() # convert namespace to dict self._dict_args = vars(args) # if -h passed, this will print and exit if self._dict_args.get(self.S_ARG_HLP_DEST, False): self._parser.print_help() sys.exit() # no -h, print epilog print(self.S_EPILOG) # ---------------------------------------------------------------------- # get the args self._dry_run = self._dict_args.get(self.S_ARG_DRY_DEST, False) # -------------------------------------------------------------------------- # Get project info # -------------------------------------------------------------------------- def _get_project_info(self): \"\"\" Get project info Get the install info from the config file. \"\"\" # get project info self._dict_cfg = self._get_dict_from_file(self._path_cfg_inst) # get prg name/version prog_name = self._dict_cfg[self.S_KEY_INST_NAME] prog_version = self._dict_cfg[self.S_KEY_INST_VER] # print start msg print(self.S_MSG_INST_START.format(prog_name, prog_version)) # -------------------------------------------------------------------------- # Check version info # -------------------------------------------------------------------------- def _check_ver(self): \"\"\" Check version info Get the version info from the new config file and the old config file (if present), compare the two values, and either continue or abort. \"\"\" # if we did pass an old conf, it must exist (if it doesn't, this could # be the first install but we will want to check on later updates) if self._path_cfg_uninst and Path(self._path_cfg_uninst).exists(): # get info from old cfg dict_cfg_old = self._get_dict_from_file(self._path_cfg_uninst) # check versions ver_old = dict_cfg_old[self.S_KEY_INST_VER] ver_new = self._dict_cfg[self.S_KEY_INST_VER] res = self._do_compare_versions(ver_old, ver_new) # same version is installed if res == 0: # ask to install same version str_ask = input(self.S_ASK_VER_SAME) # user hit enter or typed anything else except \"y\" if ( len(str_ask) == 0 or str_ask.lower()[0] != self.S_ASK_CONFIRM ): print(self.S_MSG_ABORT) sys.exit() # newer version is installed elif res == -1: # ask to install old version over newer str_ask = input(self.S_ASK_VER_OLDER) # user hit enter or typed anything else except \"y\" if ( len(str_ask) == 0 or str_ask.lower()[0] != self.S_ASK_CONFIRM ): print(self.S_MSG_ABORT) sys.exit() # fresh install else: # ask to install old version over newer str_ask = input(self.S_ASK_VER_INST) # user hit \"y\" or \"Enter\" if len(str_ask) == 0 or str_ask.lower()[0] == self.S_ASK_CONFIRM: pass else: print(self.S_MSG_ABORT) sys.exit() # -------------------------------------------------------------------------- # Make venv for this program on user's computer # -------------------------------------------------------------------------- def _make_venv(self): \"\"\" Make venv for this program on user's computer Raises: subprocess.CalledProcessError if the venv creation fails Makes a .venv-XXX folder on the user's computer. \"\"\" # show progress print(self.S_MSG_VENV_START, flush=True, end=\"\") # the command to create a venv cmd = self.S_CMD_CREATE.format(self._dir_venv) # if it's a dry run, don't make venv if self._dry_run: print(self.S_DRY_VENV, cmd) print(self.S_MSG_DONE) return # the cmd to create the venv try: subprocess.run(cmd, shell=True, check=True) print(self.S_MSG_DONE) except Exception as e: print(self.S_MSG_FAIL) raise e # -------------------------------------------------------------------------- # Install requirements.txt # -------------------------------------------------------------------------- def _install_reqs(self): \"\"\" Install requirements.txt Raises: subprocess.CalledProcessError if the reqs install fails Installs the contents of a requirements.txt file into the program's venv. \"\"\" # show progress print(self.S_MSG_REQS_START, end=\"\", flush=True) # the command to install packages to venv from reqs cmd = self.S_CMD_INSTALL.format( self._dir_venv.parent, self._dir_venv.name, self._path_reqs ) # if it's a dry run, don't install if self._dry_run: print(self.S_DRY_REQS, cmd) print(self.S_MSG_DONE) return # the cmd to install the reqs try: # NB: hide output subprocess.run( cmd, shell=True, check=True, stdout=subprocess.DEVNULL ) print(self.S_MSG_DONE) except Exception as e: print(self.S_MSG_FAIL) raise e # -------------------------------------------------------------------------- # Fix .desktop file, for paths and such # -------------------------------------------------------------------------- def _fix_desktop_file(self): \"\"\" Fix .desktop file, for paths and such Raises: OSError if one of both of the files does not exist Fixes entries in the .desktop file (absolute paths, etc.) Currently only fixes absolute path to icon. \"\"\" # make sure we even care about desktop use_desk = self._dict_cfg.get(self.S_KEY_INST_DESK, False) if not use_desk: return # check both files for None and exist if not self._file_desk or not self._file_desk.exists(): raise OSError(self.S_ERR_NOT_FOUND.format(self._file_desk)) if not self._file_desk_icon or not self._file_desk_icon.exists(): raise OSError(self.S_ERR_NOT_FOUND.format(self._file_desk_icon)) # print info print(self.S_MSG_DSK_START, end=\"\", flush=True) # don't mess with file if self._dry_run: print(self.S_DRY_DESK_ICON.format(self._file_desk_icon)) print(self.S_MSG_DONE) return # open file text = \"\" with open(self._file_desk, \"r\", encoding=\"UTF-8\") as a_file: text = a_file.read() # find icon line and fix res = re.search(self.R_ICON_SCH, text, flags=re.M) if res: # get user's home and path to icon rel to prj path_icon = Path.home() / self._file_desk_icon # fix abs path to icon r_icon_rep = self.R_ICON_REP.format(path_icon) text = re.sub(self.R_ICON_SCH, r_icon_rep, text, flags=re.M) # ------------------------------------------------------------------ # write fixed text back to file with open(self._file_desk, \"w\", encoding=\"UTF-8\") as a_file: a_file.write(text) # show some info print(self.S_MSG_DONE) # -------------------------------------------------------------------------- # Copy source files/folders # -------------------------------------------------------------------------- def _install_content(self): \"\"\" Copy source files/folders This method copies files and folders from the assets folder of the source to their final locations in the user's folder structure. \"\"\" # show some info print(self.S_MSG_COPY_START, flush=True, end=\"\") # content list from dict content = self._dict_cfg.get(self.S_KEY_INST_CONT, {}) # for each key, value for k, v in content.items(): # get full paths of source / destination src = self._dir_assets / k dst = Path.home() / v / src.name # debug may omit certain assets if not src.exists(): continue # check for dry run if self._dry_run: print(self.S_DRY_COPY.format(src, dst)) else: # if the source is a dir if src.is_dir(): shutil.copytree(src, dst, dirs_exist_ok=True) # if the src is a file else: shutil.copy(src, dst) # show some info print(self.S_MSG_DONE) # -------------------------------------------------------------------------- # Boilerplate to use at the end of main # -------------------------------------------------------------------------- def _teardown(self): \"\"\" Boilerplate to use at the end of main Perform some mundane stuff like saving config files. \"\"\" # just show we are done prog_name = self._dict_cfg[self.S_KEY_INST_NAME] print(self.S_MSG_INST_END.format(prog_name)) # -------------------------------------------------------------------------- # These are the minor steps, called from major steps for support # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Get a dict from a file # -------------------------------------------------------------------------- def _get_dict_from_file(self, a_file): \"\"\" Get a dict from a file Args: a_file: The file to load the dict from Raises: OSError if the file cannot be found or is not a valid JSON file Returns: The dict found in the file Get a dict from a file, checking if the file exists and is a valid JSON file \"\"\" # default result a_dict = {} # get dict from file try: with open(a_file, \"r\", encoding=\"UTF-8\") as a_file: a_dict = json.load(a_file) # file not found except FileNotFoundError as e: raise OSError(self.S_ERR_NOT_FOUND.format(a_file)) from e # not valid json in file except json.JSONDecodeError as e: raise OSError(self.S_ERR_NOT_JSON.format(a_file)) from e # return result return a_dict # -------------------------------------------------------------------------- # Compare two version strings for relativity # -------------------------------------------------------------------------- def _do_compare_versions(self, ver_old, ver_new): \"\"\" Compare two version strings for relativity Args: ver_old: Old version string ver_new: New version string Returns: An integer representing the relativity of the two version strings. 0 means the two versions are equal, 1 means new_ver is newer than old_ver (or there is no old_ver), and -1 means new_ver is older than old_ver. This method compares two version strings and determines which is older, which is newer, or if they are equal. Note that this method converts only the first three parts of a semantic version string (https://semver.org/). \"\"\" # test for new install (don't try to regex) if ver_old == \"\": return 1 # test for equal (just save some cpu cycles) if ver_old == ver_new: return 0 # compare version string parts (only x.x.x) res_old = re.search(self.R_VERSION, ver_old) res_new = re.search(self.R_VERSION, ver_new) # if both version strings are valid if res_old and res_new: # make a list of groups to check lst_groups = [ self.R_VERSION_GROUP_MAJ, self.R_VERSION_GROUP_MIN, self.R_VERSION_GROUP_REV, ] # for each part as int for group in lst_groups: old_val = int(res_old.group(group)) new_val = int(res_new.group(group)) # slide out at the first difference if old_val < new_val: return 1 elif old_val > new_val: return -1 else: continue else: raise OSError(self.S_ERR_VERSION) # return 0 if equal return 0","title":"CNInstall"},{"location":"API/install/install/#install.install.CNInstall.__init__","text":"Initialize the class Creates a new instance of the object and initializes its properties. Source code in install/install.py def __init__(self): \"\"\" Initialize the class Creates a new instance of the object and initializes its properties. \"\"\" # set arg properties self._dict_args = {} self._dry_run = False # project stuff # NB: set to path objects to avoid comparing to None self._dir_assets = Path() self._dir_usr_inst = Path() self._path_cfg_inst = Path() self._path_cfg_uninst = Path() self._dir_venv = Path() self._path_reqs = Path() self._file_desk = Path() self._file_desk_icon = Path() # config stuff self._dict_cfg = {} # cmd line stuff # NB: placeholder to avoid comparing to None self._parser = argparse.ArgumentParser()","title":"__init__"},{"location":"API/install/install/#install.install.CNInstall.main","text":"Install the program Parameters: Name Type Description Default dir_assets Path to the assets folder where all of the program required dir_usr_inst The program's install folder in which to place files required path_cfg_inst Path to the file that contains the current install required path_cfg_uninst Path to the currently installed program's required dir_venv The path to the venv folder to create required path_reqs Path to the requirements.txt file to add requirements to required file_desk Path to the .desktop file (if GUI) (default: None) None file_desk_icon Path to the .desktop file icon (if GUI) (default: None Runs the install operation. Source code in install/install.py def main( self, dir_assets, dir_usr_inst, path_cfg_inst, path_cfg_uninst, dir_venv, path_reqs, file_desk=None, file_desk_icon=None, ): \"\"\" Install the program Args: dir_assets: Path to the assets folder where all of the program files are put in dist. This is the base source path to use when copying files to the user's computer dir_usr_inst: The program's install folder in which to place files path_cfg_inst: Path to the file that contains the current install dict info path_cfg_uninst: Path to the currently installed program's uninstall dict info dir_venv: The path to the venv folder to create path_reqs: Path to the requirements.txt file to add requirements to the venv file_desk: Path to the .desktop file (if GUI) (default: None) file_desk_icon: Path to the .desktop file icon (if GUI) (default: None) Runs the install operation. \"\"\" # set props from params if dir_assets: dir_assets = Path(dir_assets) if not dir_assets.is_absolute(): # make abs rel to self dir_assets = P_DIR_PRJ / dir_assets self._dir_assets = dir_assets if dir_usr_inst: dir_usr_inst = Path(dir_usr_inst) if not dir_usr_inst.is_absolute(): # make abs rel to self dir_usr_inst = self._dir_assets / dir_usr_inst self._dir_usr_inst = dir_usr_inst if path_cfg_inst: path_cfg_inst = Path(path_cfg_inst) if not path_cfg_inst.is_absolute(): # make abs rel to self path_cfg_inst = self._dir_assets / path_cfg_inst self._path_cfg_inst = path_cfg_inst if path_cfg_uninst: path_cfg_uninst = Path(path_cfg_uninst) if not path_cfg_uninst.is_absolute(): # make abs rel to self path_cfg_uninst = self._dir_assets / path_cfg_uninst self._path_cfg_uninst = path_cfg_uninst if dir_venv: dir_venv = Path(dir_venv) if not dir_venv.is_absolute(): # make abs rel to self dir_venv = self._dir_assets / dir_venv self._dir_venv = dir_venv if path_reqs: path_reqs = Path(path_reqs) if not path_reqs.is_absolute(): # make abs rel to self path_reqs = self._dir_assets / path_reqs self._path_reqs = path_reqs if file_desk: file_desk = Path(file_desk) if not file_desk.is_absolute(): # make abs rel to self file_desk = self._dir_assets / file_desk self._file_desk = file_desk if file_desk_icon: file_desk_icon = Path(file_desk_icon) if not file_desk_icon.is_absolute(): # make abs rel to self file_desk_icon = self._dir_assets / file_desk_icon self._file_desk_icon = file_desk_icon # ---------------------------------------------------------------------- # do setup self._setup() # parse cmd line and get args self._do_cmd_line() # get prj info from cfg self._get_project_info() # check for existing/old version self._check_ver() # make the venv on the user's comp self._make_venv() # install reqs self._install_reqs() # fix desktop file if present self._fix_desktop_file() # move content self._install_content() # wind down self._teardown()","title":"main"},{"location":"API/install/uninstall/","text":"uninstall.py The uninstall script for this project THis module uninstalls the project, removing its files and folders to the appropriate locations on the user's computer. This file is real ugly b/c we can't access the venv, so we do it manually. CNFormatter Bases: RawTextHelpFormatter , RawDescriptionHelpFormatter A dummy class to combine multiple argparse formatters Parameters: Name Type Description Default RawTextHelpFormatter Maintains whitespace for all sorts of help text, required RawDescriptionHelpFormatter Indicates that description and epilog are required A dummy class to combine multiple argparse formatters. Source code in install/uninstall.py class CNFormatter( argparse.RawTextHelpFormatter, argparse.RawDescriptionHelpFormatter ): \"\"\" A dummy class to combine multiple argparse formatters Args: RawTextHelpFormatter: Maintains whitespace for all sorts of help text, including argument descriptions. RawDescriptionHelpFormatter: Indicates that description and epilog are already correctly formatted and should not be line-wrapped. A dummy class to combine multiple argparse formatters. \"\"\" CNUninstall The class to use for uninstalling This class performs the uninstall operation. Source code in install/uninstall.py class CNUninstall: \"\"\" The class to use for uninstalling This class performs the uninstall operation. \"\"\" # -------------------------------------------------------------------------- # Class constants # -------------------------------------------------------------------------- # keys S_KEY_INST_NAME = \"INST_NAME\" S_KEY_INST_VER = \"INST_VER\" S_KEY_INST_DESK = \"INST_DESK\" S_KEY_INST_CONT = \"INST_CONT\" # short description # NB: MUST BE ALL ON ONE LINE!!! # I18N: short desc in installer S_PP_SHORT_DESC = _(\"foobar\") # version string # NB: MUST BE ALL ON ONE LINE!!! S_PP_VERSION = \"0.0.3\" # debug option strings S_ARG_DRY_OPTION = \"-d\" S_ARG_DRY_ACTION = \"store_true\" S_ARG_DRY_DEST = \"DRY_DEST\" # I18N help string for debug cmd line option S_ARG_DRY_HELP = _(\"enable dry run mode\") # config option strings S_ARG_HLP_OPTION = \"-h\" S_ARG_HLP_ACTION = \"store_true\" S_ARG_HLP_DEST = \"HLP_DEST\" # I18N: help option help S_ARG_HLP_HELP = _(\"show this help message and exit\") # about string (to be set by subclass) S_ABOUT = ( \"\\n\" \"PyPlate\\n\" f\"{S_PP_SHORT_DESC}\\n\" f\"{S_PP_VERSION}\\n\" \"https://github.com/cyclopticnerve/PyPlate\\n\" ) # I18N if using argparse, add help at end of about S_ABOUT_HELP = _(\"Use -h for help\") # cmd line instructions string (to be set by subclass) S_EPILOG = \"\" # -------------------------------------------------------------------------- # messages # NB: format param is prog_name # I18N: uninstall the program S_MSG_UNINST_START = _(\"Uninstalling {}\") # NB: format param is prog_name # I18N: done uninstalling S_MSG_UNINST_END = _(\"{} uninstalled\") # I18N: done with step S_MSG_DONE = _(\"Done\") # I18N: step failed S_MSG_FAIL = _(\"Fail\") # I18N: show the copy step S_MSG_DEL_START = _(\"Deleting files... \") # I18N: uninstall aborted S_MSG_ABORT = _(\"Uninstallation aborted\") # questions # NB: format parma is prog name # I18N: ask to overwrite same version S_ASK_UNINST = _(\"This will uninstall {}.\\nDo you want to continue? [y/N] \") # I18N: confirm overwrite install S_ASK_CONFIRM = _(\"y\") # errors # NB: format param is file path # I18N: config file not found S_ERR_NOT_FOUND = _(\"File {} not found\") # NB: format param is file path # I18N: config file is not valid json S_ERR_NOT_JSON = _(\"File {} is not a JSON file\") # dry run messages # NB: format param is file or dir path S_DRY_REMOVE = \"\\nremove\\n{}\" # -------------------------------------------------------------------------- # Class methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Initialize the class # -------------------------------------------------------------------------- def __init__(self): \"\"\" Initialize the class Creates a new instance of the object and initializes its properties. \"\"\" # set arg properties self._dict_args = {} self._dry_run = False # project stuff self._dir_usr_inst = Path() self._path_cfg_uninst = Path() # config stuff self._dict_cfg = {} # cmd line stuff # NB: placeholder to avoid comparing to None self._parser = argparse.ArgumentParser() # ------------------------------------------------------------------------------ # Uninstall the program # ------------------------------------------------------------------------------ def main(self, dir_usr_inst, path_cfg_uninst): \"\"\" Uninstall the program Args: dir_usr_inst: The program's install folder in which files are placed path_cfg_uninst: Path to the currently installed program's uninstall dict info Runs the uninstall operation. \"\"\" # set props from params if dir_usr_inst: dir_usr_inst = Path(dir_usr_inst) if not dir_usr_inst.is_absolute(): # make abs rel to self dir_usr_inst = P_DIR_PRJ / dir_usr_inst self._dir_usr_inst = dir_usr_inst if path_cfg_uninst: path_cfg_uninst = Path(path_cfg_uninst) if not path_cfg_uninst.is_absolute(): # make abs rel to self path_cfg_uninst = P_DIR_PRJ / path_cfg_uninst self._path_cfg_uninst = path_cfg_uninst # do setup self._setup() # parse cmd line and get args self._do_cmd_line() # get prj info from cfg self._get_project_info() # create an instance of the class self._uninstall_content() # wind down self._teardown() # -------------------------------------------------------------------------- # Private methods # -------------------------------------------------------------------------- # NB: these are the main steps, called in order from main() # -------------------------------------------------------------------------- # Boilerplate to use at the start of main # -------------------------------------------------------------------------- def _setup(self): \"\"\" Boilerplate to use at the start of main Perform some mundane stuff like setting properties. \"\"\" # print default about text print(self.S_ABOUT) # create a parser object in case we need it self._parser = argparse.ArgumentParser( add_help=False, epilog=self.S_EPILOG, formatter_class=CNFormatter, ) # add help text to about block print(self.S_ABOUT_HELP) # add help option self._parser.add_argument( self.S_ARG_HLP_OPTION, dest=self.S_ARG_HLP_DEST, help=self.S_ARG_HLP_HELP, action=self.S_ARG_HLP_ACTION, ) # add dry run option self._parser.add_argument( self.S_ARG_DRY_OPTION, dest=self.S_ARG_DRY_DEST, help=self.S_ARG_DRY_HELP, action=self.S_ARG_DRY_ACTION, ) # -------------------------------------------------------------------------- # Parse the arguments from the command line # -------------------------------------------------------------------------- def _do_cmd_line(self): \"\"\" Parse the arguments from the command line Parse the arguments from the command line, after the parser has been set up. \"\"\" # get namespace object args = self._parser.parse_args() # convert namespace to dict self._dict_args = vars(args) # if -h passed, this will print and exit if self._dict_args.get(self.S_ARG_HLP_DEST, False): self._parser.print_help() sys.exit() # no -h, print epilog print(self.S_EPILOG) # ---------------------------------------------------------------------- # get the args self._dry_run = self._dict_args.get(self.S_ARG_DRY_DEST, False) # -------------------------------------------------------------------------- # Get project info # -------------------------------------------------------------------------- def _get_project_info(self): \"\"\" Get project info Get the install info from the config file. \"\"\" # get project info self._dict_cfg = self._get_dict_from_file(self._path_cfg_uninst) # get prg name/version prog_name = self._dict_cfg[self.S_KEY_INST_NAME] # ask to install same version str_ask = input(self.S_ASK_UNINST.format(prog_name)) # user hit enter or typed anything else except \"y\" if len(str_ask) == 0 or str_ask.lower()[0] != self.S_ASK_CONFIRM: print(self.S_MSG_ABORT) sys.exit() # print start msg print(self.S_MSG_UNINST_START.format(prog_name)) # uninstall # -------------------------------------------------------------------------- # Uninstall the program # -------------------------------------------------------------------------- def _uninstall_content(self): \"\"\" Uninstall the program Runs the uninstall operation. \"\"\" # uninstall # show some info print(self.S_MSG_DEL_START, flush=True, end=\"\") # content list from dict content = self._dict_cfg.get(self.S_KEY_INST_CONT, []) # for each key, value for item in content: # get full path of destination src = Path.home() / item # debug may omit certain assets if not src.exists(): continue # (maybe) do delete if self._dry_run: print(self.S_DRY_REMOVE.format(item)) else: # if the source is a dir if src.is_dir(): # remove dir shutil.rmtree(src) # if the source is a file else: # copy file src.unlink() # show some info print(self.S_MSG_DONE) # -------------------------------------------------------------------------- # Boilerplate to use at the end of main # -------------------------------------------------------------------------- def _teardown(self): \"\"\" Boilerplate to use at the end of main Perform some mundane stuff like saving config files. \"\"\" # just show we are done prog_name = self._dict_cfg[self.S_KEY_INST_NAME] print(self.S_MSG_UNINST_END.format(prog_name)) # -------------------------------------------------------------------------- # These are the minor steps, called from major steps for support # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Get a dict from a file # -------------------------------------------------------------------------- def _get_dict_from_file(self, a_file): \"\"\" Get a dict from a file Args: a_file: The file to load the dict from Raises: OSError if the file cannot be found or is not a valid JSON file Returns: The dict found in the file Get a dict from a file, checking if the file exists and is a valid JSON file \"\"\" # default result a_dict = {} # get dict from file try: with open(a_file, \"r\", encoding=\"UTF-8\") as a_file: a_dict = json.load(a_file) # file not found except FileNotFoundError as e: raise OSError(self.S_ERR_NOT_FOUND.format(a_file)) from e # not valid json in file except json.JSONDecodeError as e: raise OSError(self.S_ERR_NOT_JSON.format(a_file)) from e # return result return a_dict __init__() Initialize the class Creates a new instance of the object and initializes its properties. Source code in install/uninstall.py def __init__(self): \"\"\" Initialize the class Creates a new instance of the object and initializes its properties. \"\"\" # set arg properties self._dict_args = {} self._dry_run = False # project stuff self._dir_usr_inst = Path() self._path_cfg_uninst = Path() # config stuff self._dict_cfg = {} # cmd line stuff # NB: placeholder to avoid comparing to None self._parser = argparse.ArgumentParser() main(dir_usr_inst, path_cfg_uninst) Uninstall the program Parameters: Name Type Description Default dir_usr_inst The program's install folder in which files are required path_cfg_uninst Path to the currently installed program's required Runs the uninstall operation. Source code in install/uninstall.py def main(self, dir_usr_inst, path_cfg_uninst): \"\"\" Uninstall the program Args: dir_usr_inst: The program's install folder in which files are placed path_cfg_uninst: Path to the currently installed program's uninstall dict info Runs the uninstall operation. \"\"\" # set props from params if dir_usr_inst: dir_usr_inst = Path(dir_usr_inst) if not dir_usr_inst.is_absolute(): # make abs rel to self dir_usr_inst = P_DIR_PRJ / dir_usr_inst self._dir_usr_inst = dir_usr_inst if path_cfg_uninst: path_cfg_uninst = Path(path_cfg_uninst) if not path_cfg_uninst.is_absolute(): # make abs rel to self path_cfg_uninst = P_DIR_PRJ / path_cfg_uninst self._path_cfg_uninst = path_cfg_uninst # do setup self._setup() # parse cmd line and get args self._do_cmd_line() # get prj info from cfg self._get_project_info() # create an instance of the class self._uninstall_content() # wind down self._teardown()","title":"uninstall.py"},{"location":"API/install/uninstall/#uninstallpy","text":"The uninstall script for this project THis module uninstalls the project, removing its files and folders to the appropriate locations on the user's computer. This file is real ugly b/c we can't access the venv, so we do it manually.","title":"uninstall.py"},{"location":"API/install/uninstall/#install.uninstall.CNFormatter","text":"Bases: RawTextHelpFormatter , RawDescriptionHelpFormatter A dummy class to combine multiple argparse formatters Parameters: Name Type Description Default RawTextHelpFormatter Maintains whitespace for all sorts of help text, required RawDescriptionHelpFormatter Indicates that description and epilog are required A dummy class to combine multiple argparse formatters. Source code in install/uninstall.py class CNFormatter( argparse.RawTextHelpFormatter, argparse.RawDescriptionHelpFormatter ): \"\"\" A dummy class to combine multiple argparse formatters Args: RawTextHelpFormatter: Maintains whitespace for all sorts of help text, including argument descriptions. RawDescriptionHelpFormatter: Indicates that description and epilog are already correctly formatted and should not be line-wrapped. A dummy class to combine multiple argparse formatters. \"\"\"","title":"CNFormatter"},{"location":"API/install/uninstall/#install.uninstall.CNUninstall","text":"The class to use for uninstalling This class performs the uninstall operation. Source code in install/uninstall.py class CNUninstall: \"\"\" The class to use for uninstalling This class performs the uninstall operation. \"\"\" # -------------------------------------------------------------------------- # Class constants # -------------------------------------------------------------------------- # keys S_KEY_INST_NAME = \"INST_NAME\" S_KEY_INST_VER = \"INST_VER\" S_KEY_INST_DESK = \"INST_DESK\" S_KEY_INST_CONT = \"INST_CONT\" # short description # NB: MUST BE ALL ON ONE LINE!!! # I18N: short desc in installer S_PP_SHORT_DESC = _(\"foobar\") # version string # NB: MUST BE ALL ON ONE LINE!!! S_PP_VERSION = \"0.0.3\" # debug option strings S_ARG_DRY_OPTION = \"-d\" S_ARG_DRY_ACTION = \"store_true\" S_ARG_DRY_DEST = \"DRY_DEST\" # I18N help string for debug cmd line option S_ARG_DRY_HELP = _(\"enable dry run mode\") # config option strings S_ARG_HLP_OPTION = \"-h\" S_ARG_HLP_ACTION = \"store_true\" S_ARG_HLP_DEST = \"HLP_DEST\" # I18N: help option help S_ARG_HLP_HELP = _(\"show this help message and exit\") # about string (to be set by subclass) S_ABOUT = ( \"\\n\" \"PyPlate\\n\" f\"{S_PP_SHORT_DESC}\\n\" f\"{S_PP_VERSION}\\n\" \"https://github.com/cyclopticnerve/PyPlate\\n\" ) # I18N if using argparse, add help at end of about S_ABOUT_HELP = _(\"Use -h for help\") # cmd line instructions string (to be set by subclass) S_EPILOG = \"\" # -------------------------------------------------------------------------- # messages # NB: format param is prog_name # I18N: uninstall the program S_MSG_UNINST_START = _(\"Uninstalling {}\") # NB: format param is prog_name # I18N: done uninstalling S_MSG_UNINST_END = _(\"{} uninstalled\") # I18N: done with step S_MSG_DONE = _(\"Done\") # I18N: step failed S_MSG_FAIL = _(\"Fail\") # I18N: show the copy step S_MSG_DEL_START = _(\"Deleting files... \") # I18N: uninstall aborted S_MSG_ABORT = _(\"Uninstallation aborted\") # questions # NB: format parma is prog name # I18N: ask to overwrite same version S_ASK_UNINST = _(\"This will uninstall {}.\\nDo you want to continue? [y/N] \") # I18N: confirm overwrite install S_ASK_CONFIRM = _(\"y\") # errors # NB: format param is file path # I18N: config file not found S_ERR_NOT_FOUND = _(\"File {} not found\") # NB: format param is file path # I18N: config file is not valid json S_ERR_NOT_JSON = _(\"File {} is not a JSON file\") # dry run messages # NB: format param is file or dir path S_DRY_REMOVE = \"\\nremove\\n{}\" # -------------------------------------------------------------------------- # Class methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Initialize the class # -------------------------------------------------------------------------- def __init__(self): \"\"\" Initialize the class Creates a new instance of the object and initializes its properties. \"\"\" # set arg properties self._dict_args = {} self._dry_run = False # project stuff self._dir_usr_inst = Path() self._path_cfg_uninst = Path() # config stuff self._dict_cfg = {} # cmd line stuff # NB: placeholder to avoid comparing to None self._parser = argparse.ArgumentParser() # ------------------------------------------------------------------------------ # Uninstall the program # ------------------------------------------------------------------------------ def main(self, dir_usr_inst, path_cfg_uninst): \"\"\" Uninstall the program Args: dir_usr_inst: The program's install folder in which files are placed path_cfg_uninst: Path to the currently installed program's uninstall dict info Runs the uninstall operation. \"\"\" # set props from params if dir_usr_inst: dir_usr_inst = Path(dir_usr_inst) if not dir_usr_inst.is_absolute(): # make abs rel to self dir_usr_inst = P_DIR_PRJ / dir_usr_inst self._dir_usr_inst = dir_usr_inst if path_cfg_uninst: path_cfg_uninst = Path(path_cfg_uninst) if not path_cfg_uninst.is_absolute(): # make abs rel to self path_cfg_uninst = P_DIR_PRJ / path_cfg_uninst self._path_cfg_uninst = path_cfg_uninst # do setup self._setup() # parse cmd line and get args self._do_cmd_line() # get prj info from cfg self._get_project_info() # create an instance of the class self._uninstall_content() # wind down self._teardown() # -------------------------------------------------------------------------- # Private methods # -------------------------------------------------------------------------- # NB: these are the main steps, called in order from main() # -------------------------------------------------------------------------- # Boilerplate to use at the start of main # -------------------------------------------------------------------------- def _setup(self): \"\"\" Boilerplate to use at the start of main Perform some mundane stuff like setting properties. \"\"\" # print default about text print(self.S_ABOUT) # create a parser object in case we need it self._parser = argparse.ArgumentParser( add_help=False, epilog=self.S_EPILOG, formatter_class=CNFormatter, ) # add help text to about block print(self.S_ABOUT_HELP) # add help option self._parser.add_argument( self.S_ARG_HLP_OPTION, dest=self.S_ARG_HLP_DEST, help=self.S_ARG_HLP_HELP, action=self.S_ARG_HLP_ACTION, ) # add dry run option self._parser.add_argument( self.S_ARG_DRY_OPTION, dest=self.S_ARG_DRY_DEST, help=self.S_ARG_DRY_HELP, action=self.S_ARG_DRY_ACTION, ) # -------------------------------------------------------------------------- # Parse the arguments from the command line # -------------------------------------------------------------------------- def _do_cmd_line(self): \"\"\" Parse the arguments from the command line Parse the arguments from the command line, after the parser has been set up. \"\"\" # get namespace object args = self._parser.parse_args() # convert namespace to dict self._dict_args = vars(args) # if -h passed, this will print and exit if self._dict_args.get(self.S_ARG_HLP_DEST, False): self._parser.print_help() sys.exit() # no -h, print epilog print(self.S_EPILOG) # ---------------------------------------------------------------------- # get the args self._dry_run = self._dict_args.get(self.S_ARG_DRY_DEST, False) # -------------------------------------------------------------------------- # Get project info # -------------------------------------------------------------------------- def _get_project_info(self): \"\"\" Get project info Get the install info from the config file. \"\"\" # get project info self._dict_cfg = self._get_dict_from_file(self._path_cfg_uninst) # get prg name/version prog_name = self._dict_cfg[self.S_KEY_INST_NAME] # ask to install same version str_ask = input(self.S_ASK_UNINST.format(prog_name)) # user hit enter or typed anything else except \"y\" if len(str_ask) == 0 or str_ask.lower()[0] != self.S_ASK_CONFIRM: print(self.S_MSG_ABORT) sys.exit() # print start msg print(self.S_MSG_UNINST_START.format(prog_name)) # uninstall # -------------------------------------------------------------------------- # Uninstall the program # -------------------------------------------------------------------------- def _uninstall_content(self): \"\"\" Uninstall the program Runs the uninstall operation. \"\"\" # uninstall # show some info print(self.S_MSG_DEL_START, flush=True, end=\"\") # content list from dict content = self._dict_cfg.get(self.S_KEY_INST_CONT, []) # for each key, value for item in content: # get full path of destination src = Path.home() / item # debug may omit certain assets if not src.exists(): continue # (maybe) do delete if self._dry_run: print(self.S_DRY_REMOVE.format(item)) else: # if the source is a dir if src.is_dir(): # remove dir shutil.rmtree(src) # if the source is a file else: # copy file src.unlink() # show some info print(self.S_MSG_DONE) # -------------------------------------------------------------------------- # Boilerplate to use at the end of main # -------------------------------------------------------------------------- def _teardown(self): \"\"\" Boilerplate to use at the end of main Perform some mundane stuff like saving config files. \"\"\" # just show we are done prog_name = self._dict_cfg[self.S_KEY_INST_NAME] print(self.S_MSG_UNINST_END.format(prog_name)) # -------------------------------------------------------------------------- # These are the minor steps, called from major steps for support # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Get a dict from a file # -------------------------------------------------------------------------- def _get_dict_from_file(self, a_file): \"\"\" Get a dict from a file Args: a_file: The file to load the dict from Raises: OSError if the file cannot be found or is not a valid JSON file Returns: The dict found in the file Get a dict from a file, checking if the file exists and is a valid JSON file \"\"\" # default result a_dict = {} # get dict from file try: with open(a_file, \"r\", encoding=\"UTF-8\") as a_file: a_dict = json.load(a_file) # file not found except FileNotFoundError as e: raise OSError(self.S_ERR_NOT_FOUND.format(a_file)) from e # not valid json in file except json.JSONDecodeError as e: raise OSError(self.S_ERR_NOT_JSON.format(a_file)) from e # return result return a_dict","title":"CNUninstall"},{"location":"API/install/uninstall/#install.uninstall.CNUninstall.__init__","text":"Initialize the class Creates a new instance of the object and initializes its properties. Source code in install/uninstall.py def __init__(self): \"\"\" Initialize the class Creates a new instance of the object and initializes its properties. \"\"\" # set arg properties self._dict_args = {} self._dry_run = False # project stuff self._dir_usr_inst = Path() self._path_cfg_uninst = Path() # config stuff self._dict_cfg = {} # cmd line stuff # NB: placeholder to avoid comparing to None self._parser = argparse.ArgumentParser()","title":"__init__"},{"location":"API/install/uninstall/#install.uninstall.CNUninstall.main","text":"Uninstall the program Parameters: Name Type Description Default dir_usr_inst The program's install folder in which files are required path_cfg_uninst Path to the currently installed program's required Runs the uninstall operation. Source code in install/uninstall.py def main(self, dir_usr_inst, path_cfg_uninst): \"\"\" Uninstall the program Args: dir_usr_inst: The program's install folder in which files are placed path_cfg_uninst: Path to the currently installed program's uninstall dict info Runs the uninstall operation. \"\"\" # set props from params if dir_usr_inst: dir_usr_inst = Path(dir_usr_inst) if not dir_usr_inst.is_absolute(): # make abs rel to self dir_usr_inst = P_DIR_PRJ / dir_usr_inst self._dir_usr_inst = dir_usr_inst if path_cfg_uninst: path_cfg_uninst = Path(path_cfg_uninst) if not path_cfg_uninst.is_absolute(): # make abs rel to self path_cfg_uninst = P_DIR_PRJ / path_cfg_uninst self._path_cfg_uninst = path_cfg_uninst # do setup self._setup() # parse cmd line and get args self._do_cmd_line() # get prj info from cfg self._get_project_info() # create an instance of the class self._uninstall_content() # wind down self._teardown()","title":"main"},{"location":"API/src/pybaker/","text":"pybaker.py A program to change the metadata of a PyPlate project and create a dist This module sets the project metadata in each of the files, according to the data present in the conf files. It then sets up the dist folder with all necessary files to create a complete distribution of the project. Run pybaker -h for more options. PyBaker Bases: PyPlate The main class, responsible for the operation of the program Public methods main: The main method of the program This class implements all the needed functionality of PyBaker, to create a distribution from a PyPlate project. Source code in src/pybaker.py class PyBaker(PyPlate): \"\"\" The main class, responsible for the operation of the program Public methods: main: The main method of the program This class implements all the needed functionality of PyBaker, to create a distribution from a PyPlate project. \"\"\" # -------------------------------------------------------------------------- # Class constants # -------------------------------------------------------------------------- # ide option strings S_ARG_IDE_OPTION = \"-i\" S_ARG_IDE_ACTION = \"store_true\" S_ARG_IDE_DEST = \"IDE_DEST\" # I18N help string for ide cmd line option S_ARG_IDE_HELP = _(\"ask for project folder when running in IDE\") # about string S_ABOUT = ( \"\\n\" f\"{'PyPlate/PyBaker'}\\n\" f\"{PyPlate.S_PP_SHORT_DESC}\\n\" f\"{PyPlate.S_PP_VERSION}\\n\" f\"https://github.com/cyclopticnerve/PyPlate\\n\" ) # I18N cmd line instructions string S_EPILOG = _(\"Run this program from the parent directory of the project you want to build.\") # -------------------------------------------------------------------------- # Instance methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Initialize the new object # -------------------------------------------------------------------------- def __init__(self): \"\"\" Initialize the new object Initializes a new instance of the class, setting the default values of its properties, and any other code that needs to run to create a new object. \"\"\" # do super init super().__init__() # set the initial values of properties self._ide = False # -------------------------------------------------------------------------- # Public methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # The main method of the program # -------------------------------------------------------------------------- def main(self): \"\"\" The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. \"\"\" # do super main super().main() # do any fixing up of dicts (like meta keywords, etc) self._do_before_fix() # do replacements in final project location self._do_fix() # do extra stuff to final dir after fix self._do_after_fix() # do any fixing up of dicts (like meta keywords, etc) self._do_before_dist() # copy project files into dist folder self._do_dist() # do any fixing up of dicts (like meta keywords, etc) self._do_after_dist() # -------------------------------------------------------------------------- # Private methods # -------------------------------------------------------------------------- # NB: these are the main steps, called in order from main # -------------------------------------------------------------------------- # Boilerplate to use at the start of main # -------------------------------------------------------------------------- def _setup(self): \"\"\" Boilerplate to use at the start of main Perform some mundane stuff like setting properties. \"\"\" # do setup super()._setup() # add ide option self._parser.add_argument( self.S_ARG_IDE_OPTION, dest=self.S_ARG_IDE_DEST, help=self.S_ARG_IDE_HELP, action=self.S_ARG_IDE_ACTION, ) # parse command line self._do_cmd_line() if self._debug: self._dict_debug = C.D_DBG_PB # get ide flag from cmd line self._ide = self._dict_args.get(self.S_ARG_IDE_DEST, False) # if ide=yes, ask for prj name if self._ide: # ask for prj name rel to cwd in_str = C.S_ASK_IDE.format(self._dir_prj) while True: prj_name = input(in_str) if prj_name == \"\": continue # if running in ide, cwd is pyplate prj dir, so move up and down tmp_dir = Path(self._dir_prj / prj_name).resolve() # check if project exists if not tmp_dir.exists(): e_str = C.S_ERR_NOT_EXIST.format(tmp_dir) print(e_str) continue # set project dir and exit loop self._dir_prj = tmp_dir print() break # -------------------------------------------------------------------------- # Get project info # -------------------------------------------------------------------------- def _get_project_info(self): \"\"\" Get project info Check that the PyPlate data is present and correct, so we don't crash looking for non-existent files. \"\"\" # check if dir_prj has pyplate folder for a valid prj path_pyplate = self._dir_prj / C.S_PRJ_PP_DIR if not path_pyplate.exists(): print(C.S_ERR_NOT_PRJ) sys.exit() # check if data files exist path_prv = self._dir_prj / C.S_PRJ_PRV_CFG path_pub = self._dir_prj / C.S_PRJ_PUB_CFG if not path_prv.exists() or not path_pub.exists(): print(C.S_ERR_PP_MISSING) sys.exit() # check if files are valid json try: # get global and calculated settings dicts in private.json self._dict_prv = F.load_dicts([path_prv], {}) # get individual dicts in project.json self._dict_pub = F.load_dicts([path_pub], {}) # reload dict pointers after dict change self._reload_dicts() except OSError: print(C.S_ERR_PP_INVALID) sys.exit() # -------------------------------------------------------------------------- # Do any work before making dist # -------------------------------------------------------------------------- def _do_before_dist(self): \"\"\" Do any work before making dist Do any work on the dist folder before it is created. This method is called after _do_after_fix, and before _do_dist. \"\"\" C.do_before_dist( self._dir_prj, self._dict_prv, self._dict_pub, self._dict_debug ) # -------------------------------------------------------------------------- # Copy fixed files to final location # -------------------------------------------------------------------------- def _do_dist(self): \"\"\" Copy fixed files to final location Gets dirs/files from project and copies them to the dist/assets dir. \"\"\" # print info print(C.S_ACTION_DIST, end=\"\", flush=True) # ---------------------------------------------------------------------- # do common dist stuff # find old dist? nuke it from orbit! it's the only way to be sure! a_dist = self._dir_prj / C.S_DIR_DIST if a_dist.is_dir(): shutil.rmtree(a_dist) # make child dir in case we nuked name_fmt = self._dict_prv_prj[\"__PP_DIST_DIR__\"] p_dist = a_dist / name_fmt p_dist.mkdir(parents=True) # for each key, val (type, dict) for key, val in self._dict_pub_dist.items(): # get src/dst rel to prj dir/dist dir src = self._dir_prj / key dst = p_dist / val if not dst.exists(): dst.mkdir(parents=True) dst = dst / src.name # do the copy if src.exists() and src.is_dir(): shutil.copytree(src, dst, dirs_exist_ok=True) elif src.exists() and src.is_file(): shutil.copy2(src, dst) # done copying project files print(C.S_ACTION_DONE) # -------------------------------------------------------------------------- # Do any work after making dist # -------------------------------------------------------------------------- def _do_after_dist(self): \"\"\" Do any work after making dist Do any work on the dist folder after it is created. This method is called after _do_dist. Currently, this method purges any \"ABOUT\" file used as placeholders for github syncing. It also tars the source folder if it is a package, making for one (or two) less steps in the user's install process. \"\"\" C.do_after_dist( self._dir_prj, self._dict_prv, self._dict_pub, self._dict_debug ) __init__() Initialize the new object Initializes a new instance of the class, setting the default values of its properties, and any other code that needs to run to create a new object. Source code in src/pybaker.py def __init__(self): \"\"\" Initialize the new object Initializes a new instance of the class, setting the default values of its properties, and any other code that needs to run to create a new object. \"\"\" # do super init super().__init__() # set the initial values of properties self._ide = False main() The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. Source code in src/pybaker.py def main(self): \"\"\" The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. \"\"\" # do super main super().main() # do any fixing up of dicts (like meta keywords, etc) self._do_before_fix() # do replacements in final project location self._do_fix() # do extra stuff to final dir after fix self._do_after_fix() # do any fixing up of dicts (like meta keywords, etc) self._do_before_dist() # copy project files into dist folder self._do_dist() # do any fixing up of dicts (like meta keywords, etc) self._do_after_dist()","title":"pybaker.py"},{"location":"API/src/pybaker/#pybakerpy","text":"A program to change the metadata of a PyPlate project and create a dist This module sets the project metadata in each of the files, according to the data present in the conf files. It then sets up the dist folder with all necessary files to create a complete distribution of the project. Run pybaker -h for more options.","title":"pybaker.py"},{"location":"API/src/pybaker/#src.pybaker.PyBaker","text":"Bases: PyPlate The main class, responsible for the operation of the program Public methods main: The main method of the program This class implements all the needed functionality of PyBaker, to create a distribution from a PyPlate project. Source code in src/pybaker.py class PyBaker(PyPlate): \"\"\" The main class, responsible for the operation of the program Public methods: main: The main method of the program This class implements all the needed functionality of PyBaker, to create a distribution from a PyPlate project. \"\"\" # -------------------------------------------------------------------------- # Class constants # -------------------------------------------------------------------------- # ide option strings S_ARG_IDE_OPTION = \"-i\" S_ARG_IDE_ACTION = \"store_true\" S_ARG_IDE_DEST = \"IDE_DEST\" # I18N help string for ide cmd line option S_ARG_IDE_HELP = _(\"ask for project folder when running in IDE\") # about string S_ABOUT = ( \"\\n\" f\"{'PyPlate/PyBaker'}\\n\" f\"{PyPlate.S_PP_SHORT_DESC}\\n\" f\"{PyPlate.S_PP_VERSION}\\n\" f\"https://github.com/cyclopticnerve/PyPlate\\n\" ) # I18N cmd line instructions string S_EPILOG = _(\"Run this program from the parent directory of the project you want to build.\") # -------------------------------------------------------------------------- # Instance methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Initialize the new object # -------------------------------------------------------------------------- def __init__(self): \"\"\" Initialize the new object Initializes a new instance of the class, setting the default values of its properties, and any other code that needs to run to create a new object. \"\"\" # do super init super().__init__() # set the initial values of properties self._ide = False # -------------------------------------------------------------------------- # Public methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # The main method of the program # -------------------------------------------------------------------------- def main(self): \"\"\" The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. \"\"\" # do super main super().main() # do any fixing up of dicts (like meta keywords, etc) self._do_before_fix() # do replacements in final project location self._do_fix() # do extra stuff to final dir after fix self._do_after_fix() # do any fixing up of dicts (like meta keywords, etc) self._do_before_dist() # copy project files into dist folder self._do_dist() # do any fixing up of dicts (like meta keywords, etc) self._do_after_dist() # -------------------------------------------------------------------------- # Private methods # -------------------------------------------------------------------------- # NB: these are the main steps, called in order from main # -------------------------------------------------------------------------- # Boilerplate to use at the start of main # -------------------------------------------------------------------------- def _setup(self): \"\"\" Boilerplate to use at the start of main Perform some mundane stuff like setting properties. \"\"\" # do setup super()._setup() # add ide option self._parser.add_argument( self.S_ARG_IDE_OPTION, dest=self.S_ARG_IDE_DEST, help=self.S_ARG_IDE_HELP, action=self.S_ARG_IDE_ACTION, ) # parse command line self._do_cmd_line() if self._debug: self._dict_debug = C.D_DBG_PB # get ide flag from cmd line self._ide = self._dict_args.get(self.S_ARG_IDE_DEST, False) # if ide=yes, ask for prj name if self._ide: # ask for prj name rel to cwd in_str = C.S_ASK_IDE.format(self._dir_prj) while True: prj_name = input(in_str) if prj_name == \"\": continue # if running in ide, cwd is pyplate prj dir, so move up and down tmp_dir = Path(self._dir_prj / prj_name).resolve() # check if project exists if not tmp_dir.exists(): e_str = C.S_ERR_NOT_EXIST.format(tmp_dir) print(e_str) continue # set project dir and exit loop self._dir_prj = tmp_dir print() break # -------------------------------------------------------------------------- # Get project info # -------------------------------------------------------------------------- def _get_project_info(self): \"\"\" Get project info Check that the PyPlate data is present and correct, so we don't crash looking for non-existent files. \"\"\" # check if dir_prj has pyplate folder for a valid prj path_pyplate = self._dir_prj / C.S_PRJ_PP_DIR if not path_pyplate.exists(): print(C.S_ERR_NOT_PRJ) sys.exit() # check if data files exist path_prv = self._dir_prj / C.S_PRJ_PRV_CFG path_pub = self._dir_prj / C.S_PRJ_PUB_CFG if not path_prv.exists() or not path_pub.exists(): print(C.S_ERR_PP_MISSING) sys.exit() # check if files are valid json try: # get global and calculated settings dicts in private.json self._dict_prv = F.load_dicts([path_prv], {}) # get individual dicts in project.json self._dict_pub = F.load_dicts([path_pub], {}) # reload dict pointers after dict change self._reload_dicts() except OSError: print(C.S_ERR_PP_INVALID) sys.exit() # -------------------------------------------------------------------------- # Do any work before making dist # -------------------------------------------------------------------------- def _do_before_dist(self): \"\"\" Do any work before making dist Do any work on the dist folder before it is created. This method is called after _do_after_fix, and before _do_dist. \"\"\" C.do_before_dist( self._dir_prj, self._dict_prv, self._dict_pub, self._dict_debug ) # -------------------------------------------------------------------------- # Copy fixed files to final location # -------------------------------------------------------------------------- def _do_dist(self): \"\"\" Copy fixed files to final location Gets dirs/files from project and copies them to the dist/assets dir. \"\"\" # print info print(C.S_ACTION_DIST, end=\"\", flush=True) # ---------------------------------------------------------------------- # do common dist stuff # find old dist? nuke it from orbit! it's the only way to be sure! a_dist = self._dir_prj / C.S_DIR_DIST if a_dist.is_dir(): shutil.rmtree(a_dist) # make child dir in case we nuked name_fmt = self._dict_prv_prj[\"__PP_DIST_DIR__\"] p_dist = a_dist / name_fmt p_dist.mkdir(parents=True) # for each key, val (type, dict) for key, val in self._dict_pub_dist.items(): # get src/dst rel to prj dir/dist dir src = self._dir_prj / key dst = p_dist / val if not dst.exists(): dst.mkdir(parents=True) dst = dst / src.name # do the copy if src.exists() and src.is_dir(): shutil.copytree(src, dst, dirs_exist_ok=True) elif src.exists() and src.is_file(): shutil.copy2(src, dst) # done copying project files print(C.S_ACTION_DONE) # -------------------------------------------------------------------------- # Do any work after making dist # -------------------------------------------------------------------------- def _do_after_dist(self): \"\"\" Do any work after making dist Do any work on the dist folder after it is created. This method is called after _do_dist. Currently, this method purges any \"ABOUT\" file used as placeholders for github syncing. It also tars the source folder if it is a package, making for one (or two) less steps in the user's install process. \"\"\" C.do_after_dist( self._dir_prj, self._dict_prv, self._dict_pub, self._dict_debug )","title":"PyBaker"},{"location":"API/src/pybaker/#src.pybaker.PyBaker.__init__","text":"Initialize the new object Initializes a new instance of the class, setting the default values of its properties, and any other code that needs to run to create a new object. Source code in src/pybaker.py def __init__(self): \"\"\" Initialize the new object Initializes a new instance of the class, setting the default values of its properties, and any other code that needs to run to create a new object. \"\"\" # do super init super().__init__() # set the initial values of properties self._ide = False","title":"__init__"},{"location":"API/src/pybaker/#src.pybaker.PyBaker.main","text":"The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. Source code in src/pybaker.py def main(self): \"\"\" The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. \"\"\" # do super main super().main() # do any fixing up of dicts (like meta keywords, etc) self._do_before_fix() # do replacements in final project location self._do_fix() # do extra stuff to final dir after fix self._do_after_fix() # do any fixing up of dicts (like meta keywords, etc) self._do_before_dist() # copy project files into dist folder self._do_dist() # do any fixing up of dicts (like meta keywords, etc) self._do_after_dist()","title":"main"},{"location":"API/src/pymaker/","text":"pymaker.py A program to create a PyPlate project from a few variables This module gets the project type, the project's destination dir, copies the required dirs/files for the project type from the template to the specified destination, and performs some initial fixes/replacements of text and path names in the resulting files. Run pymaker -h for more options. PyMaker Bases: PyPlate The main class, responsible for the operation of the program Public methods main: The main method of the program This class implements all the needed functionality of PyMaker, to create a PyPlate project from a template. Source code in src/pymaker.py class PyMaker(PyPlate): \"\"\" The main class, responsible for the operation of the program Public methods: main: The main method of the program This class implements all the needed functionality of PyMaker, to create a PyPlate project from a template. \"\"\" # -------------------------------------------------------------------------- # Class constants # -------------------------------------------------------------------------- # about string S_ABOUT = ( \"\\n\" f\"{'PyPlate/PyMaker'}\\n\" f\"{PyPlate.S_PP_SHORT_DESC}\\n\" f\"{PyPlate.S_PP_VERSION}\\n\" f\"https://github.com/cyclopticnerve/PyPlate\\n\" ) # I18N cmd line instructions string S_EPILOG = _(\"Run this program from the directory where you want to create a project.\") # -------------------------------------------------------------------------- # Public methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # The main method of the program # -------------------------------------------------------------------------- def main(self): \"\"\" The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. \"\"\" # do super main super().main() # do before template self._do_before_template() # copy template self._do_template() # do before template self._do_after_template() # do any fixing up of dicts (like meta keywords, etc) self._do_before_fix() # do replacements in final project location self._do_fix() # do extra stuff to final dir after fix self._do_after_fix() # -------------------------------------------------------------------------- # Private methods # -------------------------------------------------------------------------- # NB: these are the main steps, called in order from main # -------------------------------------------------------------------------- # Boilerplate to use at the start of main # -------------------------------------------------------------------------- def _setup(self): \"\"\" Boilerplate to use at the start of main Perform some mundane stuff like setting properties. \"\"\" # do parent setup super()._setup() # parse command line self._do_cmd_line() if self._debug: self._dict_debug = C.D_DBG_PM # do not run pymaker in pyplate dir if self._dir_prj.is_relative_to(self.P_DIR_PP): print(C.S_ERR_PRJ_DIR_IS_PP) sys.exit() # -------------------------------------------------------------------------- # Get project info # -------------------------------------------------------------------------- def _get_project_info(self): \"\"\" Get project info Asks the user for project info, such as type and name, to be saved to self._dict_prv_prj. \"\"\" # ---------------------------------------------------------------------- # first question is type # NB: this makes the string to display in terminal # sanity check prj_type = \"\" # build the input question types = [] for item in C.L_TYPES: s = C.S_ASK_TYPE_FMT.format(item[0], item[1]) types.append(s) str_types = C.S_ASK_TYPE_JOIN.join(types) # format the question in_type = C.S_ASK_TYPE.format(str_types) # loop forever until we get a valid type while True: # ask for type of project (single letter) prj_type = input(in_type) # check for valid type if self._check_type(prj_type): prj_type = prj_type[0].lower() # at this point, type is valid so exit loop break # ---------------------------------------------------------------------- # next question is name # sanity check cwd = Path.cwd() # if in debug mode if self._debug: # get long name for item in C.L_TYPES: if item[0] == prj_type: # get debug name of project name_prj = f\"{item[1]} DEBUG\" break # dir name, no spaces name_prj_big = name_prj.replace(\" \", \"_\") # set up for existence check tmp_dir = cwd / name_prj_big # check if project already exists if tmp_dir.exists(): # if it does exist, \"nuke it from orbit! it's the only way to # be sure!\" # NB: yes i know ive used this joke more than once... FUCK YOU # ITS FUNNY shutil.rmtree(tmp_dir) # not debug else: # loop forever until we get a valid name that does not exist while True: # ask for name of project name_prj = input(C.S_ASK_NAME) name_prj = name_prj.strip(\" \") # check for valid name if self._check_name(name_prj): # dir name, no spaces name_prj_big = name_prj.replace(\" \", \"_\") # set up for existence check tmp_dir = cwd / name_prj_big # check if project already exists if tmp_dir.exists(): # tell the user that the old name exists print(C.S_ERR_EXIST.format(name_prj_big)) else: break # save global property self._dir_prj = tmp_dir # save other names name_prj_small = name_prj_big.lower() name_prj_pascal = F.pascal_case(name_prj_small) # ---------------------------------------------------------------------- # here we figure out the binary/package/window name for a project # NB: for a cli, the binary name is the project name lowercased # for a gui we should ask for the main window class name # for a package we should ask for the module name name_sec = \"\" name_sec_big = \"\" name_sec_small = \"\" name_sec_pascal = \"\" # do we need a second name? if prj_type in C.D_NAME_SEC: # dup prj names if debug if self._debug: name_sec = name_prj name_sec_big = name_prj_big name_sec_small = name_prj_small name_sec_pascal = name_prj_pascal # if not debug, if need second name, ask for it else: # format question for second name s_sec_ask = C.D_NAME_SEC[prj_type] s_sec_ask_fmt = s_sec_ask.format(name_prj_small) # loop forever until we get a valid name or empty string while True: # ask for second name name_sec = input(s_sec_ask_fmt) name_sec = name_sec.strip(\" \") # empty, keep default if name_sec == \"\": name_sec = name_prj_small # check for valid name if self._check_name(name_sec): name_sec_big = name_sec.replace(\" \", \"_\") break # save other names name_sec_small = name_sec_big.lower() name_sec_pascal = F.pascal_case(name_sec_small) # ---------------------------------------------------------------------- # create global and calculated settings dicts in private.json self._dict_prv = { C.S_KEY_PRV_ALL: C.D_PRV_ALL, C.S_KEY_PRV_PRJ: C.D_PRV_PRJ, } # create individual dicts in pyplate.py self._dict_pub = { C.S_KEY_PUB_BL: C.D_PUB_BL, C.S_KEY_PUB_DBG: C.D_PUB_DBG, C.S_KEY_PUB_DOCS: C.D_PUB_DOCS[prj_type], # NB: placeholder until we get prj type C.S_KEY_PUB_DIST: {}, C.S_KEY_PUB_I18N: C.D_PUB_I18N, C.S_KEY_PUB_META: C.D_PUB_META, } # reload dicts after modify # NB: VERY IMPORTANT!!! self._reload_dicts() # ---------------------------------------------------------------------- # calculate dunder values now that we have project info # save project stuff self._dict_prv_prj[\"__PP_TYPE_PRJ__\"] = prj_type self._dict_prv_prj[\"__PP_NAME_PRJ__\"] = name_prj self._dict_prv_prj[\"__PP_NAME_PRJ_BIG__\"] = name_prj_big self._dict_prv_prj[\"__PP_NAME_PRJ_SMALL__\"] = name_prj_small self._dict_prv_prj[\"__PP_NAME_PRJ_PASCAL__\"] = name_prj_pascal self._dict_prv_prj[\"__PP_NAME_SEC_BIG__\"] = name_sec_big self._dict_prv_prj[\"__PP_NAME_SEC_SMALL__\"] = name_sec_small self._dict_prv_prj[\"__PP_NAME_SEC_PASCAL__\"] = name_sec_pascal self._dict_prv_prj[\"__PP_NAME_VENV__\"] = C.S_VENV_FMT_NAME.format( name_prj_small ) self._dict_prv_prj[\"__PP_FILE_APP__\"] = C.S_APP_FILE_FMT.format( name_prj_small ) self._dict_prv_prj[\"__PP_CLASS_APP__\"] = name_prj_pascal self._dict_prv_prj[\"__PP_FILE_WIN__\"] = C.S_WIN_FILE_FMT.format( name_sec_small ) self._dict_prv_prj[\"__PP_CLASS_WIN__\"] = name_sec_pascal # add dist stuff self._dict_pub[C.S_KEY_PUB_DIST] = C.D_PUB_DIST[prj_type].copy() # ---------------------------------------------------------------------- # remove home dir from PyPlate path h = str(Path.home()) p = str(self.P_DIR_PP) p = p.lstrip(h).strip(\"/\") p = p.lstrip(h).strip(\"\\\\\") # NB: change global val self._dict_prv_prj[\"__PP_DEV_PP__\"] = p # reload dicts after modify self._reload_dicts() # blank line before printing progress print() # -------------------------------------------------------------------------- # Do any work before template copy # -------------------------------------------------------------------------- def _do_before_template(self): \"\"\" Do any work before template copy Do any work before copying the template. This method is called just before _do_template, before any files have been copied.\\n It is mostly used to make final adjustments to the 'dict_prv' and 'dict_pub' dicts before any copying occurs. \"\"\" C.do_before_template( self._dir_prj, self._dict_prv, self._dict_pub, self._dict_debug ) # -------------------------------------------------------------------------- # Copy template files to final location # -------------------------------------------------------------------------- def _do_template(self): \"\"\" Copy template files to final location Gets dirs/files from template and copies them to the project dir. \"\"\" # show info print(C.S_ACTION_COPY, end=\"\", flush=True) # ---------------------------------------------------------------------- # do template/all # copy template/all src = self.P_DIR_PP / C.S_DIR_TEMPLATE / C.S_DIR_ALL dst = self._dir_prj shutil.copytree(src, dst, dirs_exist_ok=True) # ---------------------------------------------------------------------- # copy template/type # get some paths prj_type_short = self._dict_prv_prj[\"__PP_TYPE_PRJ__\"] prj_type_long = \"\" # get long type of project for item in C.L_TYPES: if item[0] == prj_type_short: prj_type_long = item[2] break # get the src dir in the template dir src = self.P_DIR_PP / C.S_DIR_TEMPLATE / prj_type_long dst = self._dir_prj shutil.copytree(src, dst, dirs_exist_ok=True) # ---------------------------------------------------------------------- # do stuff outside template all/type # copy linked files for key, val in C.D_COPY.items(): # get src/dst src = self.P_DIR_PP / key dst = self._dir_prj / val # copy dir/file if src.is_dir(): shutil.copytree(src, dst) elif src.is_file(): shutil.copy2(src, dst) # ---------------------------------------------------------------------- # merge reqs # merge reqs files from all and prj self._merge_reqs(prj_type_long) # ---------------------------------------------------------------------- # done print(C.S_ACTION_DONE) # -------------------------------------------------------------------------- # Do any work after template copy # -------------------------------------------------------------------------- def _do_after_template(self): \"\"\" Do any work after template copy Do any work after copying the template. This method is called after _do_template, and before _do_before_fix. \"\"\" C.do_after_template( self._dir_prj, self._dict_prv, self._dict_pub, self._dict_debug ) main() The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. Source code in src/pymaker.py def main(self): \"\"\" The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. \"\"\" # do super main super().main() # do before template self._do_before_template() # copy template self._do_template() # do before template self._do_after_template() # do any fixing up of dicts (like meta keywords, etc) self._do_before_fix() # do replacements in final project location self._do_fix() # do extra stuff to final dir after fix self._do_after_fix()","title":"pymaker.py"},{"location":"API/src/pymaker/#pymakerpy","text":"A program to create a PyPlate project from a few variables This module gets the project type, the project's destination dir, copies the required dirs/files for the project type from the template to the specified destination, and performs some initial fixes/replacements of text and path names in the resulting files. Run pymaker -h for more options.","title":"pymaker.py"},{"location":"API/src/pymaker/#src.pymaker.PyMaker","text":"Bases: PyPlate The main class, responsible for the operation of the program Public methods main: The main method of the program This class implements all the needed functionality of PyMaker, to create a PyPlate project from a template. Source code in src/pymaker.py class PyMaker(PyPlate): \"\"\" The main class, responsible for the operation of the program Public methods: main: The main method of the program This class implements all the needed functionality of PyMaker, to create a PyPlate project from a template. \"\"\" # -------------------------------------------------------------------------- # Class constants # -------------------------------------------------------------------------- # about string S_ABOUT = ( \"\\n\" f\"{'PyPlate/PyMaker'}\\n\" f\"{PyPlate.S_PP_SHORT_DESC}\\n\" f\"{PyPlate.S_PP_VERSION}\\n\" f\"https://github.com/cyclopticnerve/PyPlate\\n\" ) # I18N cmd line instructions string S_EPILOG = _(\"Run this program from the directory where you want to create a project.\") # -------------------------------------------------------------------------- # Public methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # The main method of the program # -------------------------------------------------------------------------- def main(self): \"\"\" The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. \"\"\" # do super main super().main() # do before template self._do_before_template() # copy template self._do_template() # do before template self._do_after_template() # do any fixing up of dicts (like meta keywords, etc) self._do_before_fix() # do replacements in final project location self._do_fix() # do extra stuff to final dir after fix self._do_after_fix() # -------------------------------------------------------------------------- # Private methods # -------------------------------------------------------------------------- # NB: these are the main steps, called in order from main # -------------------------------------------------------------------------- # Boilerplate to use at the start of main # -------------------------------------------------------------------------- def _setup(self): \"\"\" Boilerplate to use at the start of main Perform some mundane stuff like setting properties. \"\"\" # do parent setup super()._setup() # parse command line self._do_cmd_line() if self._debug: self._dict_debug = C.D_DBG_PM # do not run pymaker in pyplate dir if self._dir_prj.is_relative_to(self.P_DIR_PP): print(C.S_ERR_PRJ_DIR_IS_PP) sys.exit() # -------------------------------------------------------------------------- # Get project info # -------------------------------------------------------------------------- def _get_project_info(self): \"\"\" Get project info Asks the user for project info, such as type and name, to be saved to self._dict_prv_prj. \"\"\" # ---------------------------------------------------------------------- # first question is type # NB: this makes the string to display in terminal # sanity check prj_type = \"\" # build the input question types = [] for item in C.L_TYPES: s = C.S_ASK_TYPE_FMT.format(item[0], item[1]) types.append(s) str_types = C.S_ASK_TYPE_JOIN.join(types) # format the question in_type = C.S_ASK_TYPE.format(str_types) # loop forever until we get a valid type while True: # ask for type of project (single letter) prj_type = input(in_type) # check for valid type if self._check_type(prj_type): prj_type = prj_type[0].lower() # at this point, type is valid so exit loop break # ---------------------------------------------------------------------- # next question is name # sanity check cwd = Path.cwd() # if in debug mode if self._debug: # get long name for item in C.L_TYPES: if item[0] == prj_type: # get debug name of project name_prj = f\"{item[1]} DEBUG\" break # dir name, no spaces name_prj_big = name_prj.replace(\" \", \"_\") # set up for existence check tmp_dir = cwd / name_prj_big # check if project already exists if tmp_dir.exists(): # if it does exist, \"nuke it from orbit! it's the only way to # be sure!\" # NB: yes i know ive used this joke more than once... FUCK YOU # ITS FUNNY shutil.rmtree(tmp_dir) # not debug else: # loop forever until we get a valid name that does not exist while True: # ask for name of project name_prj = input(C.S_ASK_NAME) name_prj = name_prj.strip(\" \") # check for valid name if self._check_name(name_prj): # dir name, no spaces name_prj_big = name_prj.replace(\" \", \"_\") # set up for existence check tmp_dir = cwd / name_prj_big # check if project already exists if tmp_dir.exists(): # tell the user that the old name exists print(C.S_ERR_EXIST.format(name_prj_big)) else: break # save global property self._dir_prj = tmp_dir # save other names name_prj_small = name_prj_big.lower() name_prj_pascal = F.pascal_case(name_prj_small) # ---------------------------------------------------------------------- # here we figure out the binary/package/window name for a project # NB: for a cli, the binary name is the project name lowercased # for a gui we should ask for the main window class name # for a package we should ask for the module name name_sec = \"\" name_sec_big = \"\" name_sec_small = \"\" name_sec_pascal = \"\" # do we need a second name? if prj_type in C.D_NAME_SEC: # dup prj names if debug if self._debug: name_sec = name_prj name_sec_big = name_prj_big name_sec_small = name_prj_small name_sec_pascal = name_prj_pascal # if not debug, if need second name, ask for it else: # format question for second name s_sec_ask = C.D_NAME_SEC[prj_type] s_sec_ask_fmt = s_sec_ask.format(name_prj_small) # loop forever until we get a valid name or empty string while True: # ask for second name name_sec = input(s_sec_ask_fmt) name_sec = name_sec.strip(\" \") # empty, keep default if name_sec == \"\": name_sec = name_prj_small # check for valid name if self._check_name(name_sec): name_sec_big = name_sec.replace(\" \", \"_\") break # save other names name_sec_small = name_sec_big.lower() name_sec_pascal = F.pascal_case(name_sec_small) # ---------------------------------------------------------------------- # create global and calculated settings dicts in private.json self._dict_prv = { C.S_KEY_PRV_ALL: C.D_PRV_ALL, C.S_KEY_PRV_PRJ: C.D_PRV_PRJ, } # create individual dicts in pyplate.py self._dict_pub = { C.S_KEY_PUB_BL: C.D_PUB_BL, C.S_KEY_PUB_DBG: C.D_PUB_DBG, C.S_KEY_PUB_DOCS: C.D_PUB_DOCS[prj_type], # NB: placeholder until we get prj type C.S_KEY_PUB_DIST: {}, C.S_KEY_PUB_I18N: C.D_PUB_I18N, C.S_KEY_PUB_META: C.D_PUB_META, } # reload dicts after modify # NB: VERY IMPORTANT!!! self._reload_dicts() # ---------------------------------------------------------------------- # calculate dunder values now that we have project info # save project stuff self._dict_prv_prj[\"__PP_TYPE_PRJ__\"] = prj_type self._dict_prv_prj[\"__PP_NAME_PRJ__\"] = name_prj self._dict_prv_prj[\"__PP_NAME_PRJ_BIG__\"] = name_prj_big self._dict_prv_prj[\"__PP_NAME_PRJ_SMALL__\"] = name_prj_small self._dict_prv_prj[\"__PP_NAME_PRJ_PASCAL__\"] = name_prj_pascal self._dict_prv_prj[\"__PP_NAME_SEC_BIG__\"] = name_sec_big self._dict_prv_prj[\"__PP_NAME_SEC_SMALL__\"] = name_sec_small self._dict_prv_prj[\"__PP_NAME_SEC_PASCAL__\"] = name_sec_pascal self._dict_prv_prj[\"__PP_NAME_VENV__\"] = C.S_VENV_FMT_NAME.format( name_prj_small ) self._dict_prv_prj[\"__PP_FILE_APP__\"] = C.S_APP_FILE_FMT.format( name_prj_small ) self._dict_prv_prj[\"__PP_CLASS_APP__\"] = name_prj_pascal self._dict_prv_prj[\"__PP_FILE_WIN__\"] = C.S_WIN_FILE_FMT.format( name_sec_small ) self._dict_prv_prj[\"__PP_CLASS_WIN__\"] = name_sec_pascal # add dist stuff self._dict_pub[C.S_KEY_PUB_DIST] = C.D_PUB_DIST[prj_type].copy() # ---------------------------------------------------------------------- # remove home dir from PyPlate path h = str(Path.home()) p = str(self.P_DIR_PP) p = p.lstrip(h).strip(\"/\") p = p.lstrip(h).strip(\"\\\\\") # NB: change global val self._dict_prv_prj[\"__PP_DEV_PP__\"] = p # reload dicts after modify self._reload_dicts() # blank line before printing progress print() # -------------------------------------------------------------------------- # Do any work before template copy # -------------------------------------------------------------------------- def _do_before_template(self): \"\"\" Do any work before template copy Do any work before copying the template. This method is called just before _do_template, before any files have been copied.\\n It is mostly used to make final adjustments to the 'dict_prv' and 'dict_pub' dicts before any copying occurs. \"\"\" C.do_before_template( self._dir_prj, self._dict_prv, self._dict_pub, self._dict_debug ) # -------------------------------------------------------------------------- # Copy template files to final location # -------------------------------------------------------------------------- def _do_template(self): \"\"\" Copy template files to final location Gets dirs/files from template and copies them to the project dir. \"\"\" # show info print(C.S_ACTION_COPY, end=\"\", flush=True) # ---------------------------------------------------------------------- # do template/all # copy template/all src = self.P_DIR_PP / C.S_DIR_TEMPLATE / C.S_DIR_ALL dst = self._dir_prj shutil.copytree(src, dst, dirs_exist_ok=True) # ---------------------------------------------------------------------- # copy template/type # get some paths prj_type_short = self._dict_prv_prj[\"__PP_TYPE_PRJ__\"] prj_type_long = \"\" # get long type of project for item in C.L_TYPES: if item[0] == prj_type_short: prj_type_long = item[2] break # get the src dir in the template dir src = self.P_DIR_PP / C.S_DIR_TEMPLATE / prj_type_long dst = self._dir_prj shutil.copytree(src, dst, dirs_exist_ok=True) # ---------------------------------------------------------------------- # do stuff outside template all/type # copy linked files for key, val in C.D_COPY.items(): # get src/dst src = self.P_DIR_PP / key dst = self._dir_prj / val # copy dir/file if src.is_dir(): shutil.copytree(src, dst) elif src.is_file(): shutil.copy2(src, dst) # ---------------------------------------------------------------------- # merge reqs # merge reqs files from all and prj self._merge_reqs(prj_type_long) # ---------------------------------------------------------------------- # done print(C.S_ACTION_DONE) # -------------------------------------------------------------------------- # Do any work after template copy # -------------------------------------------------------------------------- def _do_after_template(self): \"\"\" Do any work after template copy Do any work after copying the template. This method is called after _do_template, and before _do_before_fix. \"\"\" C.do_after_template( self._dir_prj, self._dict_prv, self._dict_pub, self._dict_debug )","title":"PyMaker"},{"location":"API/src/pymaker/#src.pymaker.PyMaker.main","text":"The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. Source code in src/pymaker.py def main(self): \"\"\" The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. \"\"\" # do super main super().main() # do before template self._do_before_template() # copy template self._do_template() # do before template self._do_after_template() # do any fixing up of dicts (like meta keywords, etc) self._do_before_fix() # do replacements in final project location self._do_fix() # do extra stuff to final dir after fix self._do_after_fix()","title":"main"},{"location":"API/src/pyplate/","text":"pyplate.py A class to be the base for pymaker/pybaker This module gets the project type, the project's destination dir, copies the required dirs/files for the project type from the template to the specified destination, and performs some initial fixes/replacements of text and path names in the resulting files. Run pymaker -h for more options. CNFormatter Bases: RawTextHelpFormatter , RawDescriptionHelpFormatter A dummy class to combine multiple argparse formatters Parameters: Name Type Description Default RawTextHelpFormatter Maintains whitespace for all sorts of help text, required RawDescriptionHelpFormatter Indicates that description and epilog are required A dummy class to combine multiple argparse formatters. Source code in src/pyplate.py class CNFormatter( argparse.RawTextHelpFormatter, argparse.RawDescriptionHelpFormatter ): \"\"\" A dummy class to combine multiple argparse formatters Args: RawTextHelpFormatter: Maintains whitespace for all sorts of help text, including argument descriptions. RawDescriptionHelpFormatter: Indicates that description and epilog are already correctly formatted and should not be line-wrapped. A dummy class to combine multiple argparse formatters. \"\"\" PyPlate The main class, responsible for the operation of the program Public methods main: The main method of the program This class implements all the needed functionality of PyMaker, to create a PyPlate project from a template. Source code in src/pyplate.py class PyPlate: \"\"\" The main class, responsible for the operation of the program Public methods: main: The main method of the program This class implements all the needed functionality of PyMaker, to create a PyPlate project from a template. \"\"\" # -------------------------------------------------------------------------- # Class constants # -------------------------------------------------------------------------- # find path to pyplate project P_DIR_PP = Path(__file__).parents[1].resolve() # pyplate: replace=True # short description # NB: MUST BE ALL ON ONE LINE!!! # pylint: disable=line-too-long # I18N: short description of parent class S_PP_SHORT_DESC = _(\"foobar\") # S_PP_SHORT_DESC = _(\"A program for creating and building CLI/GUI/Packages in Python from a template\") # pylint: enable=line-too-long # version string (to be set by subclass) # NB: MUST BE ALL ON ONE LINE!!! S_PP_VERSION = \"0.0.3\" # pyplate: replace=False # config option strings S_ARG_HLP_OPTION = \"-h\" S_ARG_HLP_ACTION = \"store_true\" S_ARG_HLP_DEST = \"HLP_DEST\" # I18N: help option help S_ARG_HLP_HELP = _(\"show this help message and exit\") # debug option strings S_ARG_DBG_OPTION = \"-d\" S_ARG_DBG_ACTION = \"store_true\" S_ARG_DBG_DEST = \"DBG_DEST\" # I18N help string for debug cmd line option S_ARG_DBG_HELP = _(\"enable debugging mode\") # about string (to be set by subclass) S_ABOUT = \"\" # I18N if using argparse, add help at end of about S_ABOUT_HELP = _(\"Use -h for help\") + \"\\n\" # cmd line instructions string (to be set by subclass) S_EPILOG = \"\" # -------------------------------------------------------------------------- # Instance methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Initialize the new object # -------------------------------------------------------------------------- def __init__(self): \"\"\" Initialize the new object Initializes a new instance of the class, setting the default values of its properties, and any other code that needs to run to create a new object. \"\"\" # set the initial values of properties # command line options self._debug = False # internal props self._dir_prj = Path() self._dict_rep = {} self._dict_type_rules = {} self._dict_sw_block = {} self._dict_sw_line = {} # private.json dicts self._dict_prv = {} self._dict_prv_all = {} self._dict_prv_prj = {} # project.json dicts self._dict_pub = {} self._dict_pub_bl = {} self._dict_pub_dbg = {} self._dict_pub_dist = {} self._dict_pub_docs = {} self._dict_pub_i18n = {} self._dict_pub_meta = {} # dictionary to hold current debug settings self._dict_debug = {} # cmd line stuff # NB: placeholder to avoid comparing to None (to be set by subclass) self._parser = argparse.ArgumentParser() self._dict_args = {} # -------------------------------------------------------------------------- # Public methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # The main method of the program # -------------------------------------------------------------------------- def main(self): \"\"\" The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. \"\"\" # call boilerplate code self._setup() # ask user for project info self._get_project_info() # -------------------------------------------------------------------------- # Private methods # -------------------------------------------------------------------------- # NB: these are the main steps, called in order from main() # -------------------------------------------------------------------------- # Boilerplate to use at the start of main # -------------------------------------------------------------------------- def _setup(self): \"\"\" Boilerplate to use at the start of main Perform some mundane stuff like setting properties. \"\"\" # print default about text print(self.S_ABOUT) # ---------------------------------------------------------------------- # use cmd line # create a parser object in case we need it self._parser = argparse.ArgumentParser( add_help=False, epilog=self.S_EPILOG, formatter_class=CNFormatter, ) # add help text to about block print(self.S_ABOUT_HELP) # add help option self._parser.add_argument( self.S_ARG_HLP_OPTION, dest=self.S_ARG_HLP_DEST, help=self.S_ARG_HLP_HELP, action=self.S_ARG_HLP_ACTION, ) # add debug option self._parser.add_argument( self.S_ARG_DBG_OPTION, dest=self.S_ARG_DBG_DEST, help=self.S_ARG_DBG_HELP, action=self.S_ARG_DBG_ACTION, ) # -------------------------------------------------------------------------- # Parse the arguments from the command line # -------------------------------------------------------------------------- def _do_cmd_line(self): \"\"\" Parse the arguments from the command line Parse the arguments from the command line, after the parser has been set up. \"\"\" # get namespace object args = self._parser.parse_args() # convert namespace to dict self._dict_args = vars(args) # if -h passed, this will print and exit if self._dict_args.get(self.S_ARG_HLP_DEST, False): self._parser.print_help() sys.exit() # no -h, print epilog print(self.S_EPILOG) print() # ---------------------------------------------------------------------- # get the args self._debug = self._dict_args.get(self.S_ARG_DBG_DEST, False) # set global prop in conf C.B_DEBUG = self._debug # debug turns off some post processing to speed up processing # NB: changing values in self._dict_pub_dbg (through the functions in # pyplate.py) will not affect the current session when running pymaker # in debug mode. to do that, change the values of D_DBG_PM in # pyplate.py self._dict_debug = self._dict_pub_dbg # ---------------------------------------------------------------------- # maybe yell if self._debug: # yup, yell print(C.S_MSG_DEBUG) # ---------------------------------------------------------------------- # set self._dir_prj # assume we are running in the project dir # this is used in a lot of places, so just shorthand it self._dir_prj = Path.cwd() # ---------------------------------------------------------------------- # set switch dicts to defaults self._dict_sw_block = dict(C.D_SWITCH_DEF) self._dict_sw_line = dict(self._dict_sw_block) # -------------------------------------------------------------------------- # Get project info # -------------------------------------------------------------------------- def _get_project_info(self): \"\"\" Get project info The implementation of this function in the superclass is just a dummy placeholder. The real work should be done in the subclass. \"\"\" # -------------------------------------------------------------------------- # Do any work before fix # -------------------------------------------------------------------------- def _do_before_fix(self): \"\"\" Do any work before fix Do any work before fix. This method is called just before _do_fix, after all dunders have been configured, but before any files have been modified.\\n It is mostly used to make final adjustments to the 'dict_prv' and 'dict_pub' dicts before any replacement occurs. \"\"\" C.do_before_fix( self._dir_prj, self._dict_prv, self._dict_pub, self._dict_debug ) # -------------------------------------------------------------------------- # Scan dirs/files in the project for replacing text # -------------------------------------------------------------------------- def _do_fix(self): \"\"\" Scan dirs/files in the project for replacing text Scans for dirs/files under the project's location. For each dir/file it encounters, it passes the path to a filter to determine if the file needs fixing based on its appearance in the blacklist. \"\"\" # print info print(C.S_ACTION_FIX, end=\"\", flush=True) # check version before we start version = self._dict_pub_meta[C.S_KEY_META_VERSION] if not self._check_sem_ver(version): res = input(C.S_ERR_SEM_VER).strip() if res in [\"\", C.S_ERR_SEM_VER_N]: sys.exit() # combine dicts for string replacement self._dict_rep = F.combine_dicts( [self._dict_prv_all, self._dict_prv_prj] ) # save private.json and project.json after all fixes have been done self._save_project_info() # make sure pyplate in in skip_all skip_all = self._dict_pub_bl[C.S_KEY_SKIP_ALL] if not C.S_PRJ_PP_DIR in skip_all: skip_all.append(C.S_PRJ_PP_DIR) # fix up blacklist and convert relative or glob paths to absolute Path # objects self._fix_blacklist_paths(self._dict_pub_bl) # just shorten the names skip_all = self._dict_pub_bl[C.S_KEY_SKIP_ALL] skip_contents = self._dict_pub_bl[C.S_KEY_SKIP_CONTENTS] skip_header = self._dict_pub_bl[C.S_KEY_SKIP_HEADER] skip_code = self._dict_pub_bl[C.S_KEY_SKIP_CODE] skip_path = self._dict_pub_bl[C.S_KEY_SKIP_PATH] # ---------------------------------------------------------------------- # do the fixes # NB: root is a full path, dirs and files are relative to root for root, root_dirs, root_files in self._dir_prj.walk(): # handle dirs in skip_all if root in skip_all: # NB: don't recurse into subfolders root_dirs.clear() continue # convert files into Paths files = [root / f for f in root_files] # for each file item for item in files: # for each new file, reset block and line switches to def # NB: line switches always default to current block switches self._dict_sw_block = dict(C.D_SWITCH_DEF) self._dict_sw_line = dict(self._dict_sw_block) # handle files in skip_all if item in skip_all: continue # handle dirs/files in skip_contents if not root in skip_contents and not item in skip_contents: # handle dirs/files in skip_header bl_hdr = root in skip_header or item in skip_header # handle dirs/files in skip_code bl_code = root in skip_code or item in skip_code # fix content with appropriate dict self._fix_contents(item, bl_hdr, bl_code) # handle files in skip_path if not item in skip_path: self._fix_path(item) # handle dirs in skip_path if not root in skip_path: self._fix_path(root) # done print(C.S_ACTION_DONE) # -------------------------------------------------------------------------- # Do any work after fix # -------------------------------------------------------------------------- def _do_after_fix(self): \"\"\" Do any work after fix Do any work after fix. This method is called just after _do_after_fix, after all files have been modified.\\n It is mostly used to tweak files once all the normal fixes have been applied. \"\"\" C.do_after_fix( self._dir_prj, self._dict_prv, self._dict_pub, self._dict_debug ) # -------------------------------------------------------------------------- # These are minor steps called from the main steps # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Convert items in blacklist to absolute Path objects # -------------------------------------------------------------------------- def _fix_blacklist_paths(self, dict_bl): \"\"\" Convert items in blacklist to absolute Path objects Get absolute paths for all entries in the blacklist. \"\"\" # make a copy and remove path separators in one shot # NB: this is mostly for glob support, as globs cannot end in path # separators for key in dict_bl: dict_bl[key] = [item.rstrip(\"/\") for item in dict_bl[key]] # support for absolute/relative/glob # NB: taken from cntree.py # for each section of blacklist for key, val in dict_bl.items(): # convert all items in list to Path objects paths = [Path(item) for item in val] # move absolute paths to one list abs_paths = [item for item in paths if item.is_absolute()] # move relative/glob paths to another list other_paths = [item for item in paths if not item.is_absolute()] # convert relative/glob paths back to strings other_strings = [str(item) for item in other_paths] # get glob results as generators glob_results = [self._dir_prj.glob(item) for item in other_strings] # start with absolutes result = abs_paths # for each generator for item in glob_results: # add results as whole shebang result += list(item) # set the list as the result list dict_bl[key] = result # -------------------------------------------------------------------------- # Fix header or code for each line in a file # -------------------------------------------------------------------------- def _fix_contents(self, path, bl_hdr=False, bl_code=False): \"\"\" Fix header or code for each line in a file Args: path: Path for replacing text bl_hdr: Whether the file is blacklisted for header lines (default: False) bl_code: Whether the file is blacklisted for code lines (default: False) For the given file, loop through each line, checking to see if it is a header line or a code line. Ignore blank lines and comment-only lines. \"\"\" # check for unknown file types self._dict_type_rules = get_type_rules(path) if not self._dict_type_rules or len(self._dict_type_rules) == 0: # do the basic replace (file got here after skip_all/skip_contents # BUT NOT skip_bl/skip/code) self._fix_text(path) return # default lines lines = [] # open and read file with open(path, \"r\", encoding=C.S_ENCODING) as a_file: lines = a_file.readlines() # for each line in array for index, line in enumerate(lines): # ------------------------------------------------------------------ # skip blank lines if line.strip() == \"\": continue # ------------------------------------------------------------------ # split the line into code and comm # we will split the line into two parts # NB: assume code is whole line (i.e. no trailing comment) split_pos = 0 code = line comm = \"\" # find split sequence split_sch = self._dict_type_rules.get(C.S_KEY_SPLIT, None) split_grp = self._dict_type_rules.get(C.S_KEY_SPLIT_COMM, None) # only process files with split if split_sch and split_grp: # there may be multiple matches per line (ignore quoted markers) matches = re.finditer(split_sch, line) # only use matches that have the right group matches = [ match for match in matches if match.group(split_grp) ] for match in matches: # split the line into code and comment (include delimiter) split_pos = match.start(split_grp) code = line[:split_pos] comm = line[split_pos:] # ------------------------------------------------------------------ # check for switches # reset line switch values to block switch values self._dict_sw_line = dict(self._dict_sw_block) # check switches check_switches( code, comm, self._dict_type_rules, self._dict_sw_block, self._dict_sw_line, ) # check for block or line replace switch repl = False if ( self._dict_sw_block[C.S_SW_REPLACE] is True and self._dict_sw_line[C.S_SW_REPLACE] is True ) or self._dict_sw_line[C.S_SW_REPLACE] is True: repl = True # switch says no, gtfo if not repl: continue # ------------------------------------------------------------------ # check for header # check if blacklisted for headers if not bl_hdr: # check if it matches header pattern str_pattern = self._dict_type_rules[C.S_KEY_HDR_SCH] res = re.search(str_pattern, line) if res: # fix it lines[index] = self._fix_header(line) # no more processing for header line continue # ------------------------------------------------------------------ # not a blank, header or switch, must be code # check if blacklisted for code if not bl_code: # fix dunders in real code lines code = self._fix_code(code) # -------------------------------------------------------------- # put the line back together lines[index] = code + comm # open and write file with open(path, \"w\", encoding=C.S_ENCODING) as a_file: a_file.writelines(lines) # -------------------------------------------------------------------------- # Replace dunders inside a file header # -------------------------------------------------------------------------- def _fix_header(self, line): \"\"\" Replace dunders inside a file header Args: line: The header line of the file in which to replace text Returns: The new header line Replaces text inside a header line, using a regex to match specific lines. Given a line, it replaces the found pattern with the replacement as it goes. \"\"\" # break apart header line # NB: gotta do this again, can't pass res param str_pattern = self._dict_type_rules[C.S_KEY_HDR_SCH] res = re.search(str_pattern, line) if not res: return line # pull out lead, val, and pad using group match values from M lead = res.group(self._dict_type_rules[C.S_KEY_LEAD]) val = res.group(self._dict_type_rules[C.S_KEY_VAL]) pad = res.group(self._dict_type_rules[C.S_KEY_PAD]) # this is a complicated function to get the length of the spaces # between the key/val pair and the RAT (right-aligned text) tmp_val = str(val) old_val_len = len(tmp_val) for key2, val2 in self._dict_rep.items(): if isinstance(val2, str): tmp_val = tmp_val.replace(key2, val2) new_val_len = len(tmp_val) val_diff = new_val_len - old_val_len # get new padding value based in diff key/val length tmp_pad = str(pad) tmp_rat = tmp_pad.lstrip() len_pad = len(tmp_pad) - len(tmp_rat) - val_diff pad = \" \" * len_pad # put the header line back together, adjusting for the pad len line = lead + tmp_val + pad + tmp_rat + \"\\n\" # return return line # -------------------------------------------------------------------------- # Replace dunders inside a file's contents # -------------------------------------------------------------------------- def _fix_code(self, code): \"\"\" Replace dunders inside a file's contents Args: code: The code portion of the line to replace text in Returns: The new line of code Replaces text inside the code portion of a line. Given a line, replaces dunders as it goes. When it is done, it returns the new line. This replaces the __PP dunders inside the file, excluding blank lines, headers, and flag switches (all of which are previously handled in _fix_contents). \"\"\" # replace content using current flag setting for key, val in self._dict_rep.items(): if isinstance(val, str): code = code.replace(key, val) # return the (maybe replaced) line return code # -------------------------------------------------------------------------- # Replace dunders inside a file's contents # -------------------------------------------------------------------------- def _fix_text(self, path): \"\"\" Replace dunders inside a file's contents Args: path: The path to the file to fix text Returns: The new line of code Replaces text inside the a file. This is a qnd function to replace any dunder in any file, regardless of D_TYPE_RULES. Think of it as an oubliette for fi;es you just want to 'undunderize'. \"\"\" # default lines lines = [] # open and read file with open(path, \"r\", encoding=C.S_ENCODING) as a_file: lines = a_file.readlines() # for each line in array for index, line in enumerate(lines): # ------------------------------------------------------------------ # skip blank lines if line.strip() == \"\": continue # replace content using current flag setting for key, val in self._dict_rep.items(): if isinstance(val, str): line = line.replace(key, val) # put new line back in file lines[index] = line # open and write file with open(path, \"w\", encoding=C.S_ENCODING) as a_file: a_file.writelines(lines) # -------------------------------------------------------------------------- # Rename dirs/files in the project # -------------------------------------------------------------------------- def _fix_path(self, path): \"\"\" Rename dirs/files in the project Args: path: Path for dir/file to be renamed Rename dirs/files. Given a path, it renames the dir/file by replacing dunders in the path with their appropriate replacements from self._dict_rep. \"\"\" # sanity check path = Path(path) # first get the path name (we only want to change the last component) last_part = path.name # # replace dunders in last path component for key, val in self._dict_rep.items(): if isinstance(val, str): last_part = last_part.replace(key, val) # replace the name path_new = path.parent / last_part # if it hasn't changed, skip to avoid overhead if path_new == path: return # do rename path.rename(path_new) # -------------------------------------------------------------------------- # Check project type for allowed characters # -------------------------------------------------------------------------- def _check_sem_ver(self, version): \"\"\" Check if new version number is semantic Args: version: New version number to check Returns: True if a valid version is found, False otherwise This method checks to see if the version string passed is valid for semantic versioning. \"\"\" # match semantic version from start of string pattern = C.S_SEM_VER_VALID return re.search(pattern, version) # -------------------------------------------------------------------------- # Reload dicts after any outside changes # -------------------------------------------------------------------------- def _reload_dicts(self): \"\"\" Reload dicts after any outside changes This function is called when a dict is passed to another function, in order to keep it synced with the internal dict. \"\"\" # update individual dicts in dict_prv self._dict_prv_all = self._dict_prv[C.S_KEY_PRV_ALL] self._dict_prv_prj = self._dict_prv[C.S_KEY_PRV_PRJ] # update individual dicts in dict_pub self._dict_pub_bl = self._dict_pub[C.S_KEY_PUB_BL] self._dict_pub_dbg = self._dict_pub[C.S_KEY_PUB_DBG] self._dict_pub_dist = self._dict_pub[C.S_KEY_PUB_DIST] self._dict_pub_docs = self._dict_pub[C.S_KEY_PUB_DOCS] self._dict_pub_i18n = self._dict_pub[C.S_KEY_PUB_I18N] self._dict_pub_meta = self._dict_pub[C.S_KEY_PUB_META] # update debug dict if not self._debug: self._dict_debug = self._dict_pub_dbg # -------------------------------------------------------------------------- # Save project info before fix # -------------------------------------------------------------------------- def _save_project_info(self): \"\"\" Save project info before fix Saves the private.json and project.json files after all modifications, and reloads them to use in _do_fix. \"\"\" # ---------------------------------------------------------------------- # save project settings # create private settings dict_prv = { C.S_KEY_PRV_ALL: self._dict_prv_all, C.S_KEY_PRV_PRJ: self._dict_prv_prj, } # save private settings path_prv = self._dir_prj / C.S_PRJ_PRV_CFG F.save_dict(dict_prv, [path_prv]) # create public settings dict_pub = { C.S_KEY_PUB_BL: self._dict_pub_bl, C.S_KEY_PUB_DBG: self._dict_pub_dbg, C.S_KEY_PUB_DIST: self._dict_pub_dist, C.S_KEY_PUB_DOCS: self._dict_pub_docs, C.S_KEY_PUB_I18N: self._dict_pub_i18n, C.S_KEY_PUB_META: self._dict_pub_meta, } # save public settings path_pub = self._dir_prj / C.S_PRJ_PUB_CFG F.save_dict(dict_pub, [path_pub]) # ---------------------------------------------------------------------- # fix dunders in dict_pub w/o _dict_rep (project.json) self._fix_contents(path_pub) # reload dict from fixed file dict_pub = F.load_dicts([path_pub]) # reload dict pointers after dict change self._reload_dicts() # -------------------------------------------------------------------------- # These are minor steps called from the main steps # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Check project type for allowed characters # -------------------------------------------------------------------------- def _check_type(self, prj_type): \"\"\" Check project type for allowed characters Args: prj_type: Type to check for allowed characters Returns: Whether the type is valid to use Checks the passed type to see if it is one of the allowed project types. \"\"\" # sanity check if len(prj_type) == 1: # get first char and lower case it first_char = prj_type[0].lower() # check if it's one of ours first_char_test = [item[0] for item in C.L_TYPES] if first_char in first_char_test: return True # nope, fail types = [] s = \"\" for item in C.L_TYPES: types.append(item[0]) s = \", \".join(types) print(C.S_ERR_TYPE.format(s)) return False # -------------------------------------------------------------------------- # Check project name for allowed characters # -------------------------------------------------------------------------- def _check_name(self, name_prj): \"\"\" Check project name for allowed characters Args: name_prj: Name to check for allowed characters Returns: Whether the name is valid to use Checks the passed name for these criteria: 1. longer than 1 char 2. starts with an alpha char 3. ends with an alphanumeric char 4. contains only alphanumeric chars and/or dash(-) or underscore(_) \"\"\" # NB: there is an easier way to do this with regex: # ^([a-zA-Z]+[a-zA-Z\\d\\-_ ]*[a-zA-Z\\d]+)$ AND OMG DID IT TAKE A LONG # TIME TO FIND IT! in case you were looking for it. It will give you a # quick yes-no answer. I don't use it here because I want to give the # user as much feedback as possible, so I break down the regex into # steps where each step explains which part of the name is wrong. # check for name length if len(name_prj.strip(\" \")) < 2: print(C.S_ERR_LEN) return False # match start or return false pattern = C.D_NAME[C.S_KEY_NAME_START] res = re.search(pattern, name_prj) if not res: print(C.S_ERR_START) return False # match end or return false pattern = C.D_NAME[C.S_KEY_NAME_END] res = re.search(pattern, name_prj) if not res: print(C.S_ERR_END) return False # match middle or return false pattern = C.D_NAME[C.S_KEY_NAME_MID] res = re.search(pattern, name_prj) if not res: print(C.S_ERR_MID) return False # if we made it this far, return true return True # -------------------------------------------------------------------------- # Combine reqs from template/all and template/prj_type # -------------------------------------------------------------------------- def _merge_reqs(self, prj_type_long): \"\"\" Combine reqs from template/all and template/prj_type Args: prj_type_long: the folder in template for the current project type This method combines reqs from the all dir used by all projects, and those used by specific project type (gui needs pygobject, etc). \"\"\" # get sources and filter out sources that don't exist reqs_prj = C.S_FILE_REQS_TYPE.format(prj_type_long) src = [ self.P_DIR_PP / C.S_FILE_REQS_ALL, self.P_DIR_PP / reqs_prj, ] src = [str(item) for item in src if item.exists()] # get dst to put file lines dst = self._dir_prj / C.S_FILE_REQS # # the new set of lines for requirements.txt new_file = [] # read reqs files and put in result for item in src: with open(item, \"r\", encoding=C.S_ENCODING) as a_file: old_file = a_file.readlines() old_file = [line.rstrip() for line in old_file] uniq = set(new_file + old_file) new_file = list(uniq) # put combined reqs into final file joint = \"\\n\".join(new_file) with open(dst, \"w\", encoding=C.S_ENCODING) as a_file: a_file.writelines(joint) __init__() Initialize the new object Initializes a new instance of the class, setting the default values of its properties, and any other code that needs to run to create a new object. Source code in src/pyplate.py def __init__(self): \"\"\" Initialize the new object Initializes a new instance of the class, setting the default values of its properties, and any other code that needs to run to create a new object. \"\"\" # set the initial values of properties # command line options self._debug = False # internal props self._dir_prj = Path() self._dict_rep = {} self._dict_type_rules = {} self._dict_sw_block = {} self._dict_sw_line = {} # private.json dicts self._dict_prv = {} self._dict_prv_all = {} self._dict_prv_prj = {} # project.json dicts self._dict_pub = {} self._dict_pub_bl = {} self._dict_pub_dbg = {} self._dict_pub_dist = {} self._dict_pub_docs = {} self._dict_pub_i18n = {} self._dict_pub_meta = {} # dictionary to hold current debug settings self._dict_debug = {} # cmd line stuff # NB: placeholder to avoid comparing to None (to be set by subclass) self._parser = argparse.ArgumentParser() self._dict_args = {} main() The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. Source code in src/pyplate.py def main(self): \"\"\" The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. \"\"\" # call boilerplate code self._setup() # ask user for project info self._get_project_info() check_switches(code, comm, dict_type_rules, dict_sw_block, dict_sw_line) Check if line or trailing comment is a switch Parameters: Name Type Description Default comm The comment part of a line to check for switches required dict_type_rules Dictionary containing the regex to look for required dict_sw Dictionary of switch values for either block or line required This method checks to see if a line or trailing comment contains a valid switch for the values in dict_type_rules. If a valid switch is found, it sets the appropriate flag in either dict_sw_block or dict_sw_line. Source code in src/pyplate.py def check_switches(code, comm, dict_type_rules, dict_sw_block, dict_sw_line): \"\"\" Check if line or trailing comment is a switch Args: comm: The comment part of a line to check for switches dict_type_rules: Dictionary containing the regex to look for dict_sw: Dictionary of switch values for either block or line switches This method checks to see if a line or trailing comment contains a valid switch for the values in dict_type_rules. If a valid switch is found, it sets the appropriate flag in either dict_sw_block or dict_sw_line. \"\"\" # switch does not appear anywhere in line res = re.search(dict_type_rules[C.S_KEY_SW_SCH], comm) if not res: return # find all matches (case insensitive) matches = re.finditer(dict_type_rules[C.S_KEY_SW_SCH], comm, flags=re.I) # for each match for match in matches: # get key/val of switch key = match.group(dict_type_rules[C.S_KEY_SW_KEY]) val = match.group(dict_type_rules[C.S_KEY_SW_VAL]) # try a bool conversion # NB: in honor of John Valby (ddg him!) val_b = val.lower() if val_b == \"true\": val = True elif val_b == \"false\": val = False # pick a dict based on if there is preceding code if code.strip() == \"\": dict_sw_block[key] = val else: dict_sw_line[key] = val get_type_rules(path) Get the filetype-specific regexes (headers, comments. switches) Parameters: Name Type Description Default path Path of the file to get the dict of regexes for required Returns: Type Description The dict of regexes for this file type Source code in src/pyplate.py def get_type_rules(path): \"\"\" Get the filetype-specific regexes (headers, comments. switches) Args: path: Path of the file to get the dict of regexes for Returns: The dict of regexes for this file type \"\"\" # iterate over reps for _key, val in C.D_TYPE_RULES.items(): # fix ets if necessary exts = val[C.S_KEY_RULES_EXT] # # if we match ext, return only rep stuff if is_path_in_list(path, exts): return val[C.S_KEY_RULES_REP] # default result is py rep return {} is_path_in_list(path, lst) Check if a file is in a list of file extensions Parameters: Name Type Description Default path The file to find required lst The list to look in required Returns: Type Description Whether the file exists in the list Source code in src/pyplate.py def is_path_in_list(path, lst): \"\"\" Check if a file is in a list of file extensions Args: path: The file to find lst: The list to look in Returns: Whether the file exists in the list \"\"\" # lowercase the list l_ext = [item.lower() for item in lst] # add dots l_ext = [ f\".{item}\" if not item.startswith(\".\") else item for item in l_ext ] # check if the suffix or the filename (for dot files) matches # NB: also checks for dot files return path.suffix.lower() in l_ext or path.name.lower() in l_ext","title":"pyplate.py"},{"location":"API/src/pyplate/#pyplatepy","text":"A class to be the base for pymaker/pybaker This module gets the project type, the project's destination dir, copies the required dirs/files for the project type from the template to the specified destination, and performs some initial fixes/replacements of text and path names in the resulting files. Run pymaker -h for more options.","title":"pyplate.py"},{"location":"API/src/pyplate/#src.pyplate.CNFormatter","text":"Bases: RawTextHelpFormatter , RawDescriptionHelpFormatter A dummy class to combine multiple argparse formatters Parameters: Name Type Description Default RawTextHelpFormatter Maintains whitespace for all sorts of help text, required RawDescriptionHelpFormatter Indicates that description and epilog are required A dummy class to combine multiple argparse formatters. Source code in src/pyplate.py class CNFormatter( argparse.RawTextHelpFormatter, argparse.RawDescriptionHelpFormatter ): \"\"\" A dummy class to combine multiple argparse formatters Args: RawTextHelpFormatter: Maintains whitespace for all sorts of help text, including argument descriptions. RawDescriptionHelpFormatter: Indicates that description and epilog are already correctly formatted and should not be line-wrapped. A dummy class to combine multiple argparse formatters. \"\"\"","title":"CNFormatter"},{"location":"API/src/pyplate/#src.pyplate.PyPlate","text":"The main class, responsible for the operation of the program Public methods main: The main method of the program This class implements all the needed functionality of PyMaker, to create a PyPlate project from a template. Source code in src/pyplate.py class PyPlate: \"\"\" The main class, responsible for the operation of the program Public methods: main: The main method of the program This class implements all the needed functionality of PyMaker, to create a PyPlate project from a template. \"\"\" # -------------------------------------------------------------------------- # Class constants # -------------------------------------------------------------------------- # find path to pyplate project P_DIR_PP = Path(__file__).parents[1].resolve() # pyplate: replace=True # short description # NB: MUST BE ALL ON ONE LINE!!! # pylint: disable=line-too-long # I18N: short description of parent class S_PP_SHORT_DESC = _(\"foobar\") # S_PP_SHORT_DESC = _(\"A program for creating and building CLI/GUI/Packages in Python from a template\") # pylint: enable=line-too-long # version string (to be set by subclass) # NB: MUST BE ALL ON ONE LINE!!! S_PP_VERSION = \"0.0.3\" # pyplate: replace=False # config option strings S_ARG_HLP_OPTION = \"-h\" S_ARG_HLP_ACTION = \"store_true\" S_ARG_HLP_DEST = \"HLP_DEST\" # I18N: help option help S_ARG_HLP_HELP = _(\"show this help message and exit\") # debug option strings S_ARG_DBG_OPTION = \"-d\" S_ARG_DBG_ACTION = \"store_true\" S_ARG_DBG_DEST = \"DBG_DEST\" # I18N help string for debug cmd line option S_ARG_DBG_HELP = _(\"enable debugging mode\") # about string (to be set by subclass) S_ABOUT = \"\" # I18N if using argparse, add help at end of about S_ABOUT_HELP = _(\"Use -h for help\") + \"\\n\" # cmd line instructions string (to be set by subclass) S_EPILOG = \"\" # -------------------------------------------------------------------------- # Instance methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Initialize the new object # -------------------------------------------------------------------------- def __init__(self): \"\"\" Initialize the new object Initializes a new instance of the class, setting the default values of its properties, and any other code that needs to run to create a new object. \"\"\" # set the initial values of properties # command line options self._debug = False # internal props self._dir_prj = Path() self._dict_rep = {} self._dict_type_rules = {} self._dict_sw_block = {} self._dict_sw_line = {} # private.json dicts self._dict_prv = {} self._dict_prv_all = {} self._dict_prv_prj = {} # project.json dicts self._dict_pub = {} self._dict_pub_bl = {} self._dict_pub_dbg = {} self._dict_pub_dist = {} self._dict_pub_docs = {} self._dict_pub_i18n = {} self._dict_pub_meta = {} # dictionary to hold current debug settings self._dict_debug = {} # cmd line stuff # NB: placeholder to avoid comparing to None (to be set by subclass) self._parser = argparse.ArgumentParser() self._dict_args = {} # -------------------------------------------------------------------------- # Public methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # The main method of the program # -------------------------------------------------------------------------- def main(self): \"\"\" The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. \"\"\" # call boilerplate code self._setup() # ask user for project info self._get_project_info() # -------------------------------------------------------------------------- # Private methods # -------------------------------------------------------------------------- # NB: these are the main steps, called in order from main() # -------------------------------------------------------------------------- # Boilerplate to use at the start of main # -------------------------------------------------------------------------- def _setup(self): \"\"\" Boilerplate to use at the start of main Perform some mundane stuff like setting properties. \"\"\" # print default about text print(self.S_ABOUT) # ---------------------------------------------------------------------- # use cmd line # create a parser object in case we need it self._parser = argparse.ArgumentParser( add_help=False, epilog=self.S_EPILOG, formatter_class=CNFormatter, ) # add help text to about block print(self.S_ABOUT_HELP) # add help option self._parser.add_argument( self.S_ARG_HLP_OPTION, dest=self.S_ARG_HLP_DEST, help=self.S_ARG_HLP_HELP, action=self.S_ARG_HLP_ACTION, ) # add debug option self._parser.add_argument( self.S_ARG_DBG_OPTION, dest=self.S_ARG_DBG_DEST, help=self.S_ARG_DBG_HELP, action=self.S_ARG_DBG_ACTION, ) # -------------------------------------------------------------------------- # Parse the arguments from the command line # -------------------------------------------------------------------------- def _do_cmd_line(self): \"\"\" Parse the arguments from the command line Parse the arguments from the command line, after the parser has been set up. \"\"\" # get namespace object args = self._parser.parse_args() # convert namespace to dict self._dict_args = vars(args) # if -h passed, this will print and exit if self._dict_args.get(self.S_ARG_HLP_DEST, False): self._parser.print_help() sys.exit() # no -h, print epilog print(self.S_EPILOG) print() # ---------------------------------------------------------------------- # get the args self._debug = self._dict_args.get(self.S_ARG_DBG_DEST, False) # set global prop in conf C.B_DEBUG = self._debug # debug turns off some post processing to speed up processing # NB: changing values in self._dict_pub_dbg (through the functions in # pyplate.py) will not affect the current session when running pymaker # in debug mode. to do that, change the values of D_DBG_PM in # pyplate.py self._dict_debug = self._dict_pub_dbg # ---------------------------------------------------------------------- # maybe yell if self._debug: # yup, yell print(C.S_MSG_DEBUG) # ---------------------------------------------------------------------- # set self._dir_prj # assume we are running in the project dir # this is used in a lot of places, so just shorthand it self._dir_prj = Path.cwd() # ---------------------------------------------------------------------- # set switch dicts to defaults self._dict_sw_block = dict(C.D_SWITCH_DEF) self._dict_sw_line = dict(self._dict_sw_block) # -------------------------------------------------------------------------- # Get project info # -------------------------------------------------------------------------- def _get_project_info(self): \"\"\" Get project info The implementation of this function in the superclass is just a dummy placeholder. The real work should be done in the subclass. \"\"\" # -------------------------------------------------------------------------- # Do any work before fix # -------------------------------------------------------------------------- def _do_before_fix(self): \"\"\" Do any work before fix Do any work before fix. This method is called just before _do_fix, after all dunders have been configured, but before any files have been modified.\\n It is mostly used to make final adjustments to the 'dict_prv' and 'dict_pub' dicts before any replacement occurs. \"\"\" C.do_before_fix( self._dir_prj, self._dict_prv, self._dict_pub, self._dict_debug ) # -------------------------------------------------------------------------- # Scan dirs/files in the project for replacing text # -------------------------------------------------------------------------- def _do_fix(self): \"\"\" Scan dirs/files in the project for replacing text Scans for dirs/files under the project's location. For each dir/file it encounters, it passes the path to a filter to determine if the file needs fixing based on its appearance in the blacklist. \"\"\" # print info print(C.S_ACTION_FIX, end=\"\", flush=True) # check version before we start version = self._dict_pub_meta[C.S_KEY_META_VERSION] if not self._check_sem_ver(version): res = input(C.S_ERR_SEM_VER).strip() if res in [\"\", C.S_ERR_SEM_VER_N]: sys.exit() # combine dicts for string replacement self._dict_rep = F.combine_dicts( [self._dict_prv_all, self._dict_prv_prj] ) # save private.json and project.json after all fixes have been done self._save_project_info() # make sure pyplate in in skip_all skip_all = self._dict_pub_bl[C.S_KEY_SKIP_ALL] if not C.S_PRJ_PP_DIR in skip_all: skip_all.append(C.S_PRJ_PP_DIR) # fix up blacklist and convert relative or glob paths to absolute Path # objects self._fix_blacklist_paths(self._dict_pub_bl) # just shorten the names skip_all = self._dict_pub_bl[C.S_KEY_SKIP_ALL] skip_contents = self._dict_pub_bl[C.S_KEY_SKIP_CONTENTS] skip_header = self._dict_pub_bl[C.S_KEY_SKIP_HEADER] skip_code = self._dict_pub_bl[C.S_KEY_SKIP_CODE] skip_path = self._dict_pub_bl[C.S_KEY_SKIP_PATH] # ---------------------------------------------------------------------- # do the fixes # NB: root is a full path, dirs and files are relative to root for root, root_dirs, root_files in self._dir_prj.walk(): # handle dirs in skip_all if root in skip_all: # NB: don't recurse into subfolders root_dirs.clear() continue # convert files into Paths files = [root / f for f in root_files] # for each file item for item in files: # for each new file, reset block and line switches to def # NB: line switches always default to current block switches self._dict_sw_block = dict(C.D_SWITCH_DEF) self._dict_sw_line = dict(self._dict_sw_block) # handle files in skip_all if item in skip_all: continue # handle dirs/files in skip_contents if not root in skip_contents and not item in skip_contents: # handle dirs/files in skip_header bl_hdr = root in skip_header or item in skip_header # handle dirs/files in skip_code bl_code = root in skip_code or item in skip_code # fix content with appropriate dict self._fix_contents(item, bl_hdr, bl_code) # handle files in skip_path if not item in skip_path: self._fix_path(item) # handle dirs in skip_path if not root in skip_path: self._fix_path(root) # done print(C.S_ACTION_DONE) # -------------------------------------------------------------------------- # Do any work after fix # -------------------------------------------------------------------------- def _do_after_fix(self): \"\"\" Do any work after fix Do any work after fix. This method is called just after _do_after_fix, after all files have been modified.\\n It is mostly used to tweak files once all the normal fixes have been applied. \"\"\" C.do_after_fix( self._dir_prj, self._dict_prv, self._dict_pub, self._dict_debug ) # -------------------------------------------------------------------------- # These are minor steps called from the main steps # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Convert items in blacklist to absolute Path objects # -------------------------------------------------------------------------- def _fix_blacklist_paths(self, dict_bl): \"\"\" Convert items in blacklist to absolute Path objects Get absolute paths for all entries in the blacklist. \"\"\" # make a copy and remove path separators in one shot # NB: this is mostly for glob support, as globs cannot end in path # separators for key in dict_bl: dict_bl[key] = [item.rstrip(\"/\") for item in dict_bl[key]] # support for absolute/relative/glob # NB: taken from cntree.py # for each section of blacklist for key, val in dict_bl.items(): # convert all items in list to Path objects paths = [Path(item) for item in val] # move absolute paths to one list abs_paths = [item for item in paths if item.is_absolute()] # move relative/glob paths to another list other_paths = [item for item in paths if not item.is_absolute()] # convert relative/glob paths back to strings other_strings = [str(item) for item in other_paths] # get glob results as generators glob_results = [self._dir_prj.glob(item) for item in other_strings] # start with absolutes result = abs_paths # for each generator for item in glob_results: # add results as whole shebang result += list(item) # set the list as the result list dict_bl[key] = result # -------------------------------------------------------------------------- # Fix header or code for each line in a file # -------------------------------------------------------------------------- def _fix_contents(self, path, bl_hdr=False, bl_code=False): \"\"\" Fix header or code for each line in a file Args: path: Path for replacing text bl_hdr: Whether the file is blacklisted for header lines (default: False) bl_code: Whether the file is blacklisted for code lines (default: False) For the given file, loop through each line, checking to see if it is a header line or a code line. Ignore blank lines and comment-only lines. \"\"\" # check for unknown file types self._dict_type_rules = get_type_rules(path) if not self._dict_type_rules or len(self._dict_type_rules) == 0: # do the basic replace (file got here after skip_all/skip_contents # BUT NOT skip_bl/skip/code) self._fix_text(path) return # default lines lines = [] # open and read file with open(path, \"r\", encoding=C.S_ENCODING) as a_file: lines = a_file.readlines() # for each line in array for index, line in enumerate(lines): # ------------------------------------------------------------------ # skip blank lines if line.strip() == \"\": continue # ------------------------------------------------------------------ # split the line into code and comm # we will split the line into two parts # NB: assume code is whole line (i.e. no trailing comment) split_pos = 0 code = line comm = \"\" # find split sequence split_sch = self._dict_type_rules.get(C.S_KEY_SPLIT, None) split_grp = self._dict_type_rules.get(C.S_KEY_SPLIT_COMM, None) # only process files with split if split_sch and split_grp: # there may be multiple matches per line (ignore quoted markers) matches = re.finditer(split_sch, line) # only use matches that have the right group matches = [ match for match in matches if match.group(split_grp) ] for match in matches: # split the line into code and comment (include delimiter) split_pos = match.start(split_grp) code = line[:split_pos] comm = line[split_pos:] # ------------------------------------------------------------------ # check for switches # reset line switch values to block switch values self._dict_sw_line = dict(self._dict_sw_block) # check switches check_switches( code, comm, self._dict_type_rules, self._dict_sw_block, self._dict_sw_line, ) # check for block or line replace switch repl = False if ( self._dict_sw_block[C.S_SW_REPLACE] is True and self._dict_sw_line[C.S_SW_REPLACE] is True ) or self._dict_sw_line[C.S_SW_REPLACE] is True: repl = True # switch says no, gtfo if not repl: continue # ------------------------------------------------------------------ # check for header # check if blacklisted for headers if not bl_hdr: # check if it matches header pattern str_pattern = self._dict_type_rules[C.S_KEY_HDR_SCH] res = re.search(str_pattern, line) if res: # fix it lines[index] = self._fix_header(line) # no more processing for header line continue # ------------------------------------------------------------------ # not a blank, header or switch, must be code # check if blacklisted for code if not bl_code: # fix dunders in real code lines code = self._fix_code(code) # -------------------------------------------------------------- # put the line back together lines[index] = code + comm # open and write file with open(path, \"w\", encoding=C.S_ENCODING) as a_file: a_file.writelines(lines) # -------------------------------------------------------------------------- # Replace dunders inside a file header # -------------------------------------------------------------------------- def _fix_header(self, line): \"\"\" Replace dunders inside a file header Args: line: The header line of the file in which to replace text Returns: The new header line Replaces text inside a header line, using a regex to match specific lines. Given a line, it replaces the found pattern with the replacement as it goes. \"\"\" # break apart header line # NB: gotta do this again, can't pass res param str_pattern = self._dict_type_rules[C.S_KEY_HDR_SCH] res = re.search(str_pattern, line) if not res: return line # pull out lead, val, and pad using group match values from M lead = res.group(self._dict_type_rules[C.S_KEY_LEAD]) val = res.group(self._dict_type_rules[C.S_KEY_VAL]) pad = res.group(self._dict_type_rules[C.S_KEY_PAD]) # this is a complicated function to get the length of the spaces # between the key/val pair and the RAT (right-aligned text) tmp_val = str(val) old_val_len = len(tmp_val) for key2, val2 in self._dict_rep.items(): if isinstance(val2, str): tmp_val = tmp_val.replace(key2, val2) new_val_len = len(tmp_val) val_diff = new_val_len - old_val_len # get new padding value based in diff key/val length tmp_pad = str(pad) tmp_rat = tmp_pad.lstrip() len_pad = len(tmp_pad) - len(tmp_rat) - val_diff pad = \" \" * len_pad # put the header line back together, adjusting for the pad len line = lead + tmp_val + pad + tmp_rat + \"\\n\" # return return line # -------------------------------------------------------------------------- # Replace dunders inside a file's contents # -------------------------------------------------------------------------- def _fix_code(self, code): \"\"\" Replace dunders inside a file's contents Args: code: The code portion of the line to replace text in Returns: The new line of code Replaces text inside the code portion of a line. Given a line, replaces dunders as it goes. When it is done, it returns the new line. This replaces the __PP dunders inside the file, excluding blank lines, headers, and flag switches (all of which are previously handled in _fix_contents). \"\"\" # replace content using current flag setting for key, val in self._dict_rep.items(): if isinstance(val, str): code = code.replace(key, val) # return the (maybe replaced) line return code # -------------------------------------------------------------------------- # Replace dunders inside a file's contents # -------------------------------------------------------------------------- def _fix_text(self, path): \"\"\" Replace dunders inside a file's contents Args: path: The path to the file to fix text Returns: The new line of code Replaces text inside the a file. This is a qnd function to replace any dunder in any file, regardless of D_TYPE_RULES. Think of it as an oubliette for fi;es you just want to 'undunderize'. \"\"\" # default lines lines = [] # open and read file with open(path, \"r\", encoding=C.S_ENCODING) as a_file: lines = a_file.readlines() # for each line in array for index, line in enumerate(lines): # ------------------------------------------------------------------ # skip blank lines if line.strip() == \"\": continue # replace content using current flag setting for key, val in self._dict_rep.items(): if isinstance(val, str): line = line.replace(key, val) # put new line back in file lines[index] = line # open and write file with open(path, \"w\", encoding=C.S_ENCODING) as a_file: a_file.writelines(lines) # -------------------------------------------------------------------------- # Rename dirs/files in the project # -------------------------------------------------------------------------- def _fix_path(self, path): \"\"\" Rename dirs/files in the project Args: path: Path for dir/file to be renamed Rename dirs/files. Given a path, it renames the dir/file by replacing dunders in the path with their appropriate replacements from self._dict_rep. \"\"\" # sanity check path = Path(path) # first get the path name (we only want to change the last component) last_part = path.name # # replace dunders in last path component for key, val in self._dict_rep.items(): if isinstance(val, str): last_part = last_part.replace(key, val) # replace the name path_new = path.parent / last_part # if it hasn't changed, skip to avoid overhead if path_new == path: return # do rename path.rename(path_new) # -------------------------------------------------------------------------- # Check project type for allowed characters # -------------------------------------------------------------------------- def _check_sem_ver(self, version): \"\"\" Check if new version number is semantic Args: version: New version number to check Returns: True if a valid version is found, False otherwise This method checks to see if the version string passed is valid for semantic versioning. \"\"\" # match semantic version from start of string pattern = C.S_SEM_VER_VALID return re.search(pattern, version) # -------------------------------------------------------------------------- # Reload dicts after any outside changes # -------------------------------------------------------------------------- def _reload_dicts(self): \"\"\" Reload dicts after any outside changes This function is called when a dict is passed to another function, in order to keep it synced with the internal dict. \"\"\" # update individual dicts in dict_prv self._dict_prv_all = self._dict_prv[C.S_KEY_PRV_ALL] self._dict_prv_prj = self._dict_prv[C.S_KEY_PRV_PRJ] # update individual dicts in dict_pub self._dict_pub_bl = self._dict_pub[C.S_KEY_PUB_BL] self._dict_pub_dbg = self._dict_pub[C.S_KEY_PUB_DBG] self._dict_pub_dist = self._dict_pub[C.S_KEY_PUB_DIST] self._dict_pub_docs = self._dict_pub[C.S_KEY_PUB_DOCS] self._dict_pub_i18n = self._dict_pub[C.S_KEY_PUB_I18N] self._dict_pub_meta = self._dict_pub[C.S_KEY_PUB_META] # update debug dict if not self._debug: self._dict_debug = self._dict_pub_dbg # -------------------------------------------------------------------------- # Save project info before fix # -------------------------------------------------------------------------- def _save_project_info(self): \"\"\" Save project info before fix Saves the private.json and project.json files after all modifications, and reloads them to use in _do_fix. \"\"\" # ---------------------------------------------------------------------- # save project settings # create private settings dict_prv = { C.S_KEY_PRV_ALL: self._dict_prv_all, C.S_KEY_PRV_PRJ: self._dict_prv_prj, } # save private settings path_prv = self._dir_prj / C.S_PRJ_PRV_CFG F.save_dict(dict_prv, [path_prv]) # create public settings dict_pub = { C.S_KEY_PUB_BL: self._dict_pub_bl, C.S_KEY_PUB_DBG: self._dict_pub_dbg, C.S_KEY_PUB_DIST: self._dict_pub_dist, C.S_KEY_PUB_DOCS: self._dict_pub_docs, C.S_KEY_PUB_I18N: self._dict_pub_i18n, C.S_KEY_PUB_META: self._dict_pub_meta, } # save public settings path_pub = self._dir_prj / C.S_PRJ_PUB_CFG F.save_dict(dict_pub, [path_pub]) # ---------------------------------------------------------------------- # fix dunders in dict_pub w/o _dict_rep (project.json) self._fix_contents(path_pub) # reload dict from fixed file dict_pub = F.load_dicts([path_pub]) # reload dict pointers after dict change self._reload_dicts() # -------------------------------------------------------------------------- # These are minor steps called from the main steps # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Check project type for allowed characters # -------------------------------------------------------------------------- def _check_type(self, prj_type): \"\"\" Check project type for allowed characters Args: prj_type: Type to check for allowed characters Returns: Whether the type is valid to use Checks the passed type to see if it is one of the allowed project types. \"\"\" # sanity check if len(prj_type) == 1: # get first char and lower case it first_char = prj_type[0].lower() # check if it's one of ours first_char_test = [item[0] for item in C.L_TYPES] if first_char in first_char_test: return True # nope, fail types = [] s = \"\" for item in C.L_TYPES: types.append(item[0]) s = \", \".join(types) print(C.S_ERR_TYPE.format(s)) return False # -------------------------------------------------------------------------- # Check project name for allowed characters # -------------------------------------------------------------------------- def _check_name(self, name_prj): \"\"\" Check project name for allowed characters Args: name_prj: Name to check for allowed characters Returns: Whether the name is valid to use Checks the passed name for these criteria: 1. longer than 1 char 2. starts with an alpha char 3. ends with an alphanumeric char 4. contains only alphanumeric chars and/or dash(-) or underscore(_) \"\"\" # NB: there is an easier way to do this with regex: # ^([a-zA-Z]+[a-zA-Z\\d\\-_ ]*[a-zA-Z\\d]+)$ AND OMG DID IT TAKE A LONG # TIME TO FIND IT! in case you were looking for it. It will give you a # quick yes-no answer. I don't use it here because I want to give the # user as much feedback as possible, so I break down the regex into # steps where each step explains which part of the name is wrong. # check for name length if len(name_prj.strip(\" \")) < 2: print(C.S_ERR_LEN) return False # match start or return false pattern = C.D_NAME[C.S_KEY_NAME_START] res = re.search(pattern, name_prj) if not res: print(C.S_ERR_START) return False # match end or return false pattern = C.D_NAME[C.S_KEY_NAME_END] res = re.search(pattern, name_prj) if not res: print(C.S_ERR_END) return False # match middle or return false pattern = C.D_NAME[C.S_KEY_NAME_MID] res = re.search(pattern, name_prj) if not res: print(C.S_ERR_MID) return False # if we made it this far, return true return True # -------------------------------------------------------------------------- # Combine reqs from template/all and template/prj_type # -------------------------------------------------------------------------- def _merge_reqs(self, prj_type_long): \"\"\" Combine reqs from template/all and template/prj_type Args: prj_type_long: the folder in template for the current project type This method combines reqs from the all dir used by all projects, and those used by specific project type (gui needs pygobject, etc). \"\"\" # get sources and filter out sources that don't exist reqs_prj = C.S_FILE_REQS_TYPE.format(prj_type_long) src = [ self.P_DIR_PP / C.S_FILE_REQS_ALL, self.P_DIR_PP / reqs_prj, ] src = [str(item) for item in src if item.exists()] # get dst to put file lines dst = self._dir_prj / C.S_FILE_REQS # # the new set of lines for requirements.txt new_file = [] # read reqs files and put in result for item in src: with open(item, \"r\", encoding=C.S_ENCODING) as a_file: old_file = a_file.readlines() old_file = [line.rstrip() for line in old_file] uniq = set(new_file + old_file) new_file = list(uniq) # put combined reqs into final file joint = \"\\n\".join(new_file) with open(dst, \"w\", encoding=C.S_ENCODING) as a_file: a_file.writelines(joint)","title":"PyPlate"},{"location":"API/src/pyplate/#src.pyplate.PyPlate.__init__","text":"Initialize the new object Initializes a new instance of the class, setting the default values of its properties, and any other code that needs to run to create a new object. Source code in src/pyplate.py def __init__(self): \"\"\" Initialize the new object Initializes a new instance of the class, setting the default values of its properties, and any other code that needs to run to create a new object. \"\"\" # set the initial values of properties # command line options self._debug = False # internal props self._dir_prj = Path() self._dict_rep = {} self._dict_type_rules = {} self._dict_sw_block = {} self._dict_sw_line = {} # private.json dicts self._dict_prv = {} self._dict_prv_all = {} self._dict_prv_prj = {} # project.json dicts self._dict_pub = {} self._dict_pub_bl = {} self._dict_pub_dbg = {} self._dict_pub_dist = {} self._dict_pub_docs = {} self._dict_pub_i18n = {} self._dict_pub_meta = {} # dictionary to hold current debug settings self._dict_debug = {} # cmd line stuff # NB: placeholder to avoid comparing to None (to be set by subclass) self._parser = argparse.ArgumentParser() self._dict_args = {}","title":"__init__"},{"location":"API/src/pyplate/#src.pyplate.PyPlate.main","text":"The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. Source code in src/pyplate.py def main(self): \"\"\" The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. \"\"\" # call boilerplate code self._setup() # ask user for project info self._get_project_info()","title":"main"},{"location":"API/src/pyplate/#src.pyplate.check_switches","text":"Check if line or trailing comment is a switch Parameters: Name Type Description Default comm The comment part of a line to check for switches required dict_type_rules Dictionary containing the regex to look for required dict_sw Dictionary of switch values for either block or line required This method checks to see if a line or trailing comment contains a valid switch for the values in dict_type_rules. If a valid switch is found, it sets the appropriate flag in either dict_sw_block or dict_sw_line. Source code in src/pyplate.py def check_switches(code, comm, dict_type_rules, dict_sw_block, dict_sw_line): \"\"\" Check if line or trailing comment is a switch Args: comm: The comment part of a line to check for switches dict_type_rules: Dictionary containing the regex to look for dict_sw: Dictionary of switch values for either block or line switches This method checks to see if a line or trailing comment contains a valid switch for the values in dict_type_rules. If a valid switch is found, it sets the appropriate flag in either dict_sw_block or dict_sw_line. \"\"\" # switch does not appear anywhere in line res = re.search(dict_type_rules[C.S_KEY_SW_SCH], comm) if not res: return # find all matches (case insensitive) matches = re.finditer(dict_type_rules[C.S_KEY_SW_SCH], comm, flags=re.I) # for each match for match in matches: # get key/val of switch key = match.group(dict_type_rules[C.S_KEY_SW_KEY]) val = match.group(dict_type_rules[C.S_KEY_SW_VAL]) # try a bool conversion # NB: in honor of John Valby (ddg him!) val_b = val.lower() if val_b == \"true\": val = True elif val_b == \"false\": val = False # pick a dict based on if there is preceding code if code.strip() == \"\": dict_sw_block[key] = val else: dict_sw_line[key] = val","title":"check_switches"},{"location":"API/src/pyplate/#src.pyplate.get_type_rules","text":"Get the filetype-specific regexes (headers, comments. switches) Parameters: Name Type Description Default path Path of the file to get the dict of regexes for required Returns: Type Description The dict of regexes for this file type Source code in src/pyplate.py def get_type_rules(path): \"\"\" Get the filetype-specific regexes (headers, comments. switches) Args: path: Path of the file to get the dict of regexes for Returns: The dict of regexes for this file type \"\"\" # iterate over reps for _key, val in C.D_TYPE_RULES.items(): # fix ets if necessary exts = val[C.S_KEY_RULES_EXT] # # if we match ext, return only rep stuff if is_path_in_list(path, exts): return val[C.S_KEY_RULES_REP] # default result is py rep return {}","title":"get_type_rules"},{"location":"API/src/pyplate/#src.pyplate.is_path_in_list","text":"Check if a file is in a list of file extensions Parameters: Name Type Description Default path The file to find required lst The list to look in required Returns: Type Description Whether the file exists in the list Source code in src/pyplate.py def is_path_in_list(path, lst): \"\"\" Check if a file is in a list of file extensions Args: path: The file to find lst: The list to look in Returns: Whether the file exists in the list \"\"\" # lowercase the list l_ext = [item.lower() for item in lst] # add dots l_ext = [ f\".{item}\" if not item.startswith(\".\") else item for item in l_ext ] # check if the suffix or the filename (for dot files) matches # NB: also checks for dot files return path.suffix.lower() in l_ext or path.name.lower() in l_ext","title":"is_path_in_list"}]}