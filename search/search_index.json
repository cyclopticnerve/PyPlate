{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"PyPlate \"It mostly works\" \u2122\u00a9\u00ae A program for creating and building CLI/GUI/Packages in Python from a template Version 1.1.1 Table of Contents Requirements Downloading Installing Usage Uninstalling Documentation Developing Notes Requirements Python 3.10+ Downloading There are two ways to get the code: Download the latest release (the 'Source code (zip)' file should work an all platforms). Or you can clone the git repo to get the latest (and often broken) code from the main branch: $ git clone https://github.com/cyclopticnerve/PyPlate Installing If you downloaded the zip file, extract it and go to the 'install' directory: $ cd ~/Downloads/PyPlate-<version>/install where \\<version> is the version number of the file you downloaded. If you cloned the repo, just go to the 'install' directory: $ cd ~/Downloads/PyPlate/install Either way, run the install script: $ ./install.py Usage Read the full documentation . PyPlate consists of two main programs, 'pymaker' and 'pybaker'. The first is used to create the project, and the second is used to build an existing project as its development continues. Let us start with 'pymaker'. PyMaker - Create the project Before you do anything, you should take a look at the 'conf.py' file in '~/.local/share/pyplate/conf'. This file contains A LOT of information that is used when creating/building a project. Most of these are string values and file/folder names used in the program, which you are free to change. PyPlate does not yet support i18n/l10n for itself (meaning any strings in this file will not be i18n'ed), but that may be included at a later date. This file also contains some functions that are run at various times during creating/building the project, such as before/after creating a project, before/after building a project, etc. These functions have been extended to the config file so you don't have to do a lot of mucking around in the source code, but be sure to take a look at those too. Now run the script from the command line, in the directory where you want to create the project: $ cd ~/Projects/Python $ pymaker Enter the required information, and 'pymaker' will create the required files and folders in a subdirectory of the current directory. That's it! From there you are free to modify the projects in your favorite IDE. PyBaker - Build the project Once you have created a project, you can use 'pybaker' in the project's directory to update metadata in the project's files and create a 'dist' folder. If you are using VSCode, you can select 'Terminal/Run Build Task...' from the menu bar or press 'Ctrl+Shift+B'. 'pybaker' is a program which will replace certain values in the project directory. These values are read/written in the 'project.json' file in your project's 'pyplate/project.json' file. Things like version number, short description, and other values that might change during a project's lifecycle are placed here. The values in the 'pyplate/project.json' file can be edited at any time, followed by re-running 'pybaker'. Note that if you are running pybaker from VSCode, it will ask for the name of the project (since it may not know the current directory). Give it the name of the project's directory as it was created by pymaker, relative to the current dir in VSCode's terminal. Documenting you project You can document your project using either pdoc3 or MkDocs. Step 1: - Create your project using pymaker - Publish your repo to GitHub Step 2: - To use pdoc3, you have to: - Open you GitHub repo in a browser - Go to the repo's Settings/Pages - Set the source to your main branch / docs folder To use MkDocs, you have to: run 'pybaker' from your project directory Wait a minute or two, and your docs should appear at https://\\<username>.github.io/\\<repo_name> Uninstalling Go to the source folder for PyPlate and run the uninstaller: $ cd ~/.local/share/pyplate $ ./uninstall.py Documentation See the full documentation Developing If you are developing this project, make sure you run the \"develop.py\" script first to create the proper virtual environment (venv). Notes If you have any sort of spellchecker in your IDE, FOR GOD'S SAKE TURN IT OFF! It would brick a fucking quantum computer. On the other hand, I'm about to use an Oxford comma, so \\/ jog on. If you make any changes to this template to better suit your own style/setup, please let me know or send a pull request. I will take a look and see if I can incorporate your changes to make them user, system, and/or IDE agnostic. This way the template can hopefully become more customizable to suit everyone's needs. PyPlate currently uses MkDocs for documentation, because pdoc3 is TOO SIMPLE and sphinx is TOO COMPLEX! -)","title":"Home"},{"location":"#pyplate","text":"","title":"PyPlate"},{"location":"#it-mostly-works-tm","text":"A program for creating and building CLI/GUI/Packages in Python from a template Version 1.1.1","title":"\"It mostly works\" \u2122\u00a9\u00ae"},{"location":"#table-of-contents","text":"Requirements Downloading Installing Usage Uninstalling Documentation Developing Notes","title":"Table of Contents"},{"location":"#requirements","text":"Python 3.10+","title":"Requirements"},{"location":"#downloading","text":"There are two ways to get the code: Download the latest release (the 'Source code (zip)' file should work an all platforms). Or you can clone the git repo to get the latest (and often broken) code from the main branch: $ git clone https://github.com/cyclopticnerve/PyPlate","title":"Downloading"},{"location":"#installing","text":"If you downloaded the zip file, extract it and go to the 'install' directory: $ cd ~/Downloads/PyPlate-<version>/install where \\<version> is the version number of the file you downloaded. If you cloned the repo, just go to the 'install' directory: $ cd ~/Downloads/PyPlate/install Either way, run the install script: $ ./install.py","title":"Installing"},{"location":"#usage","text":"Read the full documentation . PyPlate consists of two main programs, 'pymaker' and 'pybaker'. The first is used to create the project, and the second is used to build an existing project as its development continues. Let us start with 'pymaker'.","title":"Usage"},{"location":"#pymaker-create-the-project","text":"Before you do anything, you should take a look at the 'conf.py' file in '~/.local/share/pyplate/conf'. This file contains A LOT of information that is used when creating/building a project. Most of these are string values and file/folder names used in the program, which you are free to change. PyPlate does not yet support i18n/l10n for itself (meaning any strings in this file will not be i18n'ed), but that may be included at a later date. This file also contains some functions that are run at various times during creating/building the project, such as before/after creating a project, before/after building a project, etc. These functions have been extended to the config file so you don't have to do a lot of mucking around in the source code, but be sure to take a look at those too. Now run the script from the command line, in the directory where you want to create the project: $ cd ~/Projects/Python $ pymaker Enter the required information, and 'pymaker' will create the required files and folders in a subdirectory of the current directory. That's it! From there you are free to modify the projects in your favorite IDE.","title":"PyMaker - Create the project"},{"location":"#pybaker-build-the-project","text":"Once you have created a project, you can use 'pybaker' in the project's directory to update metadata in the project's files and create a 'dist' folder. If you are using VSCode, you can select 'Terminal/Run Build Task...' from the menu bar or press 'Ctrl+Shift+B'. 'pybaker' is a program which will replace certain values in the project directory. These values are read/written in the 'project.json' file in your project's 'pyplate/project.json' file. Things like version number, short description, and other values that might change during a project's lifecycle are placed here. The values in the 'pyplate/project.json' file can be edited at any time, followed by re-running 'pybaker'. Note that if you are running pybaker from VSCode, it will ask for the name of the project (since it may not know the current directory). Give it the name of the project's directory as it was created by pymaker, relative to the current dir in VSCode's terminal.","title":"PyBaker - Build the project"},{"location":"#documenting-you-project","text":"You can document your project using either pdoc3 or MkDocs. Step 1: - Create your project using pymaker - Publish your repo to GitHub Step 2: - To use pdoc3, you have to: - Open you GitHub repo in a browser - Go to the repo's Settings/Pages - Set the source to your main branch / docs folder To use MkDocs, you have to: run 'pybaker' from your project directory Wait a minute or two, and your docs should appear at https://\\<username>.github.io/\\<repo_name>","title":"Documenting you project"},{"location":"#uninstalling","text":"Go to the source folder for PyPlate and run the uninstaller: $ cd ~/.local/share/pyplate $ ./uninstall.py","title":"Uninstalling"},{"location":"#documentation","text":"See the full documentation","title":"Documentation"},{"location":"#developing","text":"If you are developing this project, make sure you run the \"develop.py\" script first to create the proper virtual environment (venv).","title":"Developing"},{"location":"#notes","text":"If you have any sort of spellchecker in your IDE, FOR GOD'S SAKE TURN IT OFF! It would brick a fucking quantum computer. On the other hand, I'm about to use an Oxford comma, so \\/ jog on. If you make any changes to this template to better suit your own style/setup, please let me know or send a pull request. I will take a look and see if I can incorporate your changes to make them user, system, and/or IDE agnostic. This way the template can hopefully become more customizable to suit everyone's needs. PyPlate currently uses MkDocs for documentation, because pdoc3 is TOO SIMPLE and sphinx is TOO COMPLEX! -)","title":"Notes"},{"location":"API/src/pybaker/","text":"pybaker.py A program to change the metadata of a PyPlate project and create a dist This module sets the project metadata in each of the files, according to the data present in the conf files. It then sets up the dist folder with all necessary files to create a complete distribution of the project. Run pybaker -h for more options. PyBaker Bases: PyPlate The main class, responsible for the operation of the program Public methods main: The main method of the program This class implements all the needed functionality of PyBaker, to create a distribution from a PyPlate project. Source code in src/pybaker.py class PyBaker(PyPlate): \"\"\" The main class, responsible for the operation of the program Public methods: main: The main method of the program This class implements all the needed functionality of PyBaker, to create a distribution from a PyPlate project. \"\"\" # -------------------------------------------------------------------------- # Class constants # -------------------------------------------------------------------------- # ide option strings S_ARG_IDE_OPTION = \"-i\" S_ARG_IDE_ACTION = \"store_true\" S_ARG_IDE_DEST = \"IDE_DEST\" # I18N help string for ide cmd line option S_ARG_IDE_HELP = _(\"ask for project folder when running in IDE\") # lang option strings S_ARG_LANG_OPTION = \"-l\" S_ARG_LANG_DEST = \"LANG_DEST\" # I18N: lang option help S_ARG_LANG_HELP = _(\"add a language (*.po) file\") # I18N: lang file source S_ARG_LANG_METAVAR = _(\"FILE\") # ide option strings S_ARG_VER_OPTION = \"-v\" S_ARG_VER_DEST = \"VER_DEST\" # I18N help string for version cmd line option S_ARG_VER_HELP = _( \"set the new version of the project\\n(if used, -l is ignored)\" ) # I18N: config file dest S_ARG_VER_METAVAR = _(\"VERSION\") # about string S_ABOUT = ( \"\\n\" f\"{'PyPlate/PyBaker'}\\n\" f\"{PyPlate.S_PP_SHORT_DESC}\\n\" f\"{PyPlate.S_PP_VERSION}\\n\" f\"https://github.com/cyclopticnerve/PyPlate\\n\" ) # I18N cmd line instructions string S_EPILOG = _( \"Run this program from the directory of the project you want to build.\" ) # error strings # I18N: language already exists in project.json and i18n folder S_ERR_LANG_EXIST = _(\"Language file {} already exists\") S_ERR_NO_LANG = _(\"Could not get language code from {}\") # messages # bake msg # NB: param is name of project folder S_MSG_BAKE = _(\"Baking {}\") # NB: format param is file name # I18N: add language at cmd line S_MSG_LANG_ADD = _(\"Adding language file {}...\") # questions # # I18N: answer yes # S_ASK_YES = _(\"y\") # # I18N: answer no # S_ASK_NO = _(\"N\") # NB: format param is file name # I18N: ask to overwrite S_ASK_OVER = _(\"The file {} already exists. Do you want to overwrite it?\") # -------------------------------------------------------------------------- # Instance methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Initialize the new object # -------------------------------------------------------------------------- # def __init__(self): # \"\"\" # Initialize the new object # Initializes a new instance of the class, setting the default values # of its properties, and any other code that needs to run to create a # new object. # \"\"\" # # do super init # super().__init__() # -------------------------------------------------------------------------- # Public methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # The main method of the program # -------------------------------------------------------------------------- def main(self): \"\"\" The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. \"\"\" # call boilerplate code self._setup() # ---------------------------------------------------------------------- # main stuff # get project info self._get_project_info() # do any fixing up of dicts (like meta keywords, etc) self._do_before_fix() # do replacements in final project location self._do_fix() # do extra stuff to final dir after fix self._do_after_fix() # do any fixing up of dicts (like meta keywords, etc) self._do_before_dist() # copy project files into dist folder self._do_dist() # do any fixing up of dicts (like meta keywords, etc) self._do_after_dist() # ---------------------------------------------------------------------- # teardown # call boilerplate code self._teardown() # -------------------------------------------------------------------------- # Private methods # -------------------------------------------------------------------------- # NB: these are the main steps, called in order from main # -------------------------------------------------------------------------- # Boilerplate to use at the start of main # -------------------------------------------------------------------------- def _setup(self): \"\"\" Boilerplate to use at the start of main Perform some mundane stuff like setting properties. \"\"\" # add ide option self._parser.add_argument( self.S_ARG_IDE_OPTION, dest=self.S_ARG_IDE_DEST, help=self.S_ARG_IDE_HELP, action=self.S_ARG_IDE_ACTION, ) # add lang option self._parser.add_argument( self.S_ARG_LANG_OPTION, dest=self.S_ARG_LANG_DEST, help=self.S_ARG_LANG_HELP, metavar=self.S_ARG_LANG_METAVAR, ) # add version option self._parser.add_argument( self.S_ARG_VER_OPTION, dest=self.S_ARG_VER_DEST, help=self.S_ARG_VER_HELP, metavar=self.S_ARG_VER_METAVAR, ) # do setup super()._setup() # -------------------------------------------------------------------------- # Get project info # -------------------------------------------------------------------------- def _get_project_info(self): \"\"\" Get project info Raises: OSError if anything goes wrong Check that the PyPlate data is present and correct, so we don't crash looking for non-existent files. Also handles command line settings. \"\"\" # ---------------------------------------------------------------------- # handle -i self._handle_i() # ---------------------------------------------------------------------- # sanity checks # check if dir_prj has pyplate folder for a valid prj path_pyplate = self._dir_prj / P.C.S_PRJ_PP_DIR if not path_pyplate.exists(): print(P.C.S_ERR_NOT_PRJ) P.sys.exit(-1) # check if data files exist path_prv = self._dir_prj / P.C.S_PRJ_PRV_CFG path_pub = self._dir_prj / P.C.S_PRJ_PUB_CFG if not path_prv.exists() or not path_pub.exists(): print(P.C.S_ERR_PP_MISSING) P.sys.exit(-1) # ---------------------------------------------------------------------- # make dicts from files # check if files are valid json try: # get settings dicts in private.json self._dict_prv = F.load_paths_into_dict(path_prv) # get settings dicts in project.json # NB: may contain dunders self._dict_pub = F.load_paths_into_dict(path_pub) # if there was a problem except OSError as e: # from load_dicts # exit gracefully print(self.S_ERR_ERR, e) P.sys.exit(-1) # ---------------------------------------------------------------------- # fix dicts self._fix_dicts() # ---------------------------------------------------------------------- # handle -d # NB: do after _fix_dicts if self._cmd_debug: self._dict_dbg = dict(P.C.D_DBG_PB) # ---------------------------------------------------------------------- # handle -v self._handle_v() # ---------------------------------------------------------------------- # handle -l self._handle_l() # ---------------------------------------------------------------------- # print some info print() print(self.S_MSG_BAKE.format(self._dir_prj.name)) # blank line before printing progress print() # -------------------------------------------------------------------------- # Do any work before making dist # -------------------------------------------------------------------------- def _do_before_dist(self): \"\"\" Do any work before making dist Do any work on the dist folder before it is created. This method is called after _do_after_fix, and before _do_dist. \"\"\" P.C.do_before_dist( self._dir_prj, self._dict_prv, self._dict_pub, self._dict_dbg ) # -------------------------------------------------------------------------- # Copy fixed files to final location # -------------------------------------------------------------------------- def _do_dist(self): \"\"\" Copy fixed files to final location Gets dirs/files from project and copies them to the dist/assets dir. \"\"\" # print info print(P.C.S_ACTION_DIST, end=\"\", flush=True) # ---------------------------------------------------------------------- # do common dist stuff # find old dist? nuke it from orbit! it's the only way to be sure! a_dist = self._dir_prj / P.C.S_DIR_DIST if a_dist.is_dir(): shutil.rmtree(a_dist) # make child dir in case we nuked name_fmt = self._dict_prv_prj[\"__PP_FMT_DIST__\"] p_dist = a_dist / name_fmt p_dist.mkdir(parents=True) # for each key, val (type, dict) for key, val in self._dict_pub_dist.items(): # get src/dst rel to prj dir/dist dir src = self._dir_prj / key dst = p_dist / str(val) if not dst.exists(): dst.mkdir(parents=True) dst = dst / src.name # do the copy if src.exists() and src.is_dir(): shutil.copytree(src, dst, dirs_exist_ok=True) elif src.exists() and src.is_file(): shutil.copy2(src, dst) # ---------------------------------------------------------------------- # done copying project files F.printc(P.C.S_ACTION_DONE, fg=F.C_FG_GREEN, bold=True) # -------------------------------------------------------------------------- # Do any work after making dist # -------------------------------------------------------------------------- def _do_after_dist(self): \"\"\" Do any work after making dist Do any work on the dist folder after it is created. This method is called after _do_dist. Currently, this method purges any \"ABOUT\" file used as placeholders for github syncing. It also tars the source folder if it is a package, making for one (or two) less steps in the user's install process. \"\"\" P.C.do_after_dist( self._dir_prj, self._dict_prv, self._dict_pub, self._dict_dbg ) # -------------------------------------------------------------------------- # Handle the -i option # -------------------------------------------------------------------------- def _handle_i(self): \"\"\" Docstring for _handle_i :param self: Description \"\"\" ide = self._dict_args.get(self.S_ARG_IDE_DEST, False) if not ide: return # ask for prj name rel to cwd in_str = P.C.S_ASK_IDE.format(self._dir_prj) while True: prj_name = input(in_str) if prj_name == \"\": continue # if running in ide, cwd is pyplate prj dir, so move up + down tmp_dir = P.Path(self._dir_prj / prj_name).resolve() # check if project exists if not tmp_dir.exists(): e_str = P.C.S_ERR_NOT_EXIST.format(tmp_dir) print(e_str) continue # set project dir and exit loop self._dir_prj = tmp_dir # print() break # -------------------------------------------------------------------------- # Handle the -v option # -------------------------------------------------------------------------- def _handle_v(self): \"\"\" Docstring for _handle_v :param self: Description \"\"\" # first check if passed on cmd line ver = self._dict_args.get(self.S_ARG_VER_DEST, None) if ver: # check version before we start fixing pattern = P.C.S_SEM_VER_VALID version = ver ver_ok = P.re.search(pattern, version) is not None # ask if user wants to keep invalid version or quit if not ver_ok: res = F.dialog( P.C.S_ERR_SEM_VER, [F.S_ASK_YES, F.S_ASK_NO], default=F.S_ASK_NO, loop=True, ) if res != F.S_ASK_YES: P.sys.exit(-1) # not passed, ask question else: # format and ask question old_ver = self._dict_pub_meta[P.C.S_KEY_META_VERSION] ask_ver = P.C.S_ASK_VER.format(old_ver) # loop until condition while True: # ask for new version new_ver = input(ask_ver) # user pressed Enter, return original if new_ver == \"\": # set the same version, and we are done ver = old_ver break # check version before we start fixing pattern = P.C.S_SEM_VER_VALID version = new_ver ver_ok = P.re.search(pattern, version) is not None # ask if user wants to keep invalid version or quit if ver_ok: # set the new version, and we are done ver = new_ver break # print version error print(P.C.S_ERR_SEM_VER) # change in project.json self._dict_pub_meta[P.C.S_KEY_META_VERSION] = ver # set version in install dict prj_type = self._dict_prv_prj[\"__PP_TYPE_PRJ__\"] if prj_type in P.C.L_APP_INSTALL: self._dict_pub_inst[P.C.S_KEY_INST_VER] = ver # -------------------------------------------------------------------------- # Handle the -l option # -------------------------------------------------------------------------- def _handle_l(self): \"\"\" Docstring for _handle_l :param self: Description \"\"\" # if no lang, no go lang_file = self._dict_args.get(self.S_ARG_LANG_DEST, None) if not lang_file: return print(self.S_MSG_LANG_ADD.format(lang_file), flush=True, end=\"\") # default lang code lang_code = \"\" # get code from file p_lang = self._dir_prj / lang_file # in case of typo -) if not p_lang.exists(): F.printc(P.C.S_ACTION_FAIL, fg=F.C_FG_RED, bold=True) return # find the line with open(p_lang, \"r\", encoding=P.C.S_ENCODING) as a_file: string = a_file.read() # find the lang res = re.search(P.C.S_PO_LANG_SCH, string) if res: lang_code = res.group(2) # make sure it worked before doing api if lang_code == \"\": F.printc(P.C.S_ACTION_FAIL, fg=F.C_FG_RED, bold=True) return # get lang dict from props dict_lang = self._dict_pub_i18n[P.C.S_KEY_PUB_I18N_WLANGS] # only add once (might be old) if not lang_code in dict_lang: dict_lang.append(lang_code) # check file exists dst = self._dir_prj / P.C.S_DIR_I18N / P.C.S_DIR_PO / lang_code dst_file = dst / lang_file if dst_file.exists(): print() # ask to overwrite msg = self.S_ASK_OVER.format(lang_file) ask = F.dialog( msg, [F.S_ASK_YES, F.S_ASK_NO], default=F.S_ASK_NO ) if ask != F.S_ASK_YES: F.printc(P.C.S_ACTION_FAIL, fg=F.C_FG_RED, bold=True) return # copy file to dest dst.mkdir(parents=True, exist_ok=True) shutil.copy(p_lang, dst_file) F.printc(P.C.S_ACTION_DONE, fg=F.C_FG_GREEN, bold=True) main() The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. Source code in src/pybaker.py def main(self): \"\"\" The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. \"\"\" # call boilerplate code self._setup() # ---------------------------------------------------------------------- # main stuff # get project info self._get_project_info() # do any fixing up of dicts (like meta keywords, etc) self._do_before_fix() # do replacements in final project location self._do_fix() # do extra stuff to final dir after fix self._do_after_fix() # do any fixing up of dicts (like meta keywords, etc) self._do_before_dist() # copy project files into dist folder self._do_dist() # do any fixing up of dicts (like meta keywords, etc) self._do_after_dist() # ---------------------------------------------------------------------- # teardown # call boilerplate code self._teardown()","title":"pybaker.py"},{"location":"API/src/pybaker/#pybakerpy","text":"A program to change the metadata of a PyPlate project and create a dist This module sets the project metadata in each of the files, according to the data present in the conf files. It then sets up the dist folder with all necessary files to create a complete distribution of the project. Run pybaker -h for more options.","title":"pybaker.py"},{"location":"API/src/pybaker/#src.pybaker.PyBaker","text":"Bases: PyPlate The main class, responsible for the operation of the program Public methods main: The main method of the program This class implements all the needed functionality of PyBaker, to create a distribution from a PyPlate project. Source code in src/pybaker.py class PyBaker(PyPlate): \"\"\" The main class, responsible for the operation of the program Public methods: main: The main method of the program This class implements all the needed functionality of PyBaker, to create a distribution from a PyPlate project. \"\"\" # -------------------------------------------------------------------------- # Class constants # -------------------------------------------------------------------------- # ide option strings S_ARG_IDE_OPTION = \"-i\" S_ARG_IDE_ACTION = \"store_true\" S_ARG_IDE_DEST = \"IDE_DEST\" # I18N help string for ide cmd line option S_ARG_IDE_HELP = _(\"ask for project folder when running in IDE\") # lang option strings S_ARG_LANG_OPTION = \"-l\" S_ARG_LANG_DEST = \"LANG_DEST\" # I18N: lang option help S_ARG_LANG_HELP = _(\"add a language (*.po) file\") # I18N: lang file source S_ARG_LANG_METAVAR = _(\"FILE\") # ide option strings S_ARG_VER_OPTION = \"-v\" S_ARG_VER_DEST = \"VER_DEST\" # I18N help string for version cmd line option S_ARG_VER_HELP = _( \"set the new version of the project\\n(if used, -l is ignored)\" ) # I18N: config file dest S_ARG_VER_METAVAR = _(\"VERSION\") # about string S_ABOUT = ( \"\\n\" f\"{'PyPlate/PyBaker'}\\n\" f\"{PyPlate.S_PP_SHORT_DESC}\\n\" f\"{PyPlate.S_PP_VERSION}\\n\" f\"https://github.com/cyclopticnerve/PyPlate\\n\" ) # I18N cmd line instructions string S_EPILOG = _( \"Run this program from the directory of the project you want to build.\" ) # error strings # I18N: language already exists in project.json and i18n folder S_ERR_LANG_EXIST = _(\"Language file {} already exists\") S_ERR_NO_LANG = _(\"Could not get language code from {}\") # messages # bake msg # NB: param is name of project folder S_MSG_BAKE = _(\"Baking {}\") # NB: format param is file name # I18N: add language at cmd line S_MSG_LANG_ADD = _(\"Adding language file {}...\") # questions # # I18N: answer yes # S_ASK_YES = _(\"y\") # # I18N: answer no # S_ASK_NO = _(\"N\") # NB: format param is file name # I18N: ask to overwrite S_ASK_OVER = _(\"The file {} already exists. Do you want to overwrite it?\") # -------------------------------------------------------------------------- # Instance methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Initialize the new object # -------------------------------------------------------------------------- # def __init__(self): # \"\"\" # Initialize the new object # Initializes a new instance of the class, setting the default values # of its properties, and any other code that needs to run to create a # new object. # \"\"\" # # do super init # super().__init__() # -------------------------------------------------------------------------- # Public methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # The main method of the program # -------------------------------------------------------------------------- def main(self): \"\"\" The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. \"\"\" # call boilerplate code self._setup() # ---------------------------------------------------------------------- # main stuff # get project info self._get_project_info() # do any fixing up of dicts (like meta keywords, etc) self._do_before_fix() # do replacements in final project location self._do_fix() # do extra stuff to final dir after fix self._do_after_fix() # do any fixing up of dicts (like meta keywords, etc) self._do_before_dist() # copy project files into dist folder self._do_dist() # do any fixing up of dicts (like meta keywords, etc) self._do_after_dist() # ---------------------------------------------------------------------- # teardown # call boilerplate code self._teardown() # -------------------------------------------------------------------------- # Private methods # -------------------------------------------------------------------------- # NB: these are the main steps, called in order from main # -------------------------------------------------------------------------- # Boilerplate to use at the start of main # -------------------------------------------------------------------------- def _setup(self): \"\"\" Boilerplate to use at the start of main Perform some mundane stuff like setting properties. \"\"\" # add ide option self._parser.add_argument( self.S_ARG_IDE_OPTION, dest=self.S_ARG_IDE_DEST, help=self.S_ARG_IDE_HELP, action=self.S_ARG_IDE_ACTION, ) # add lang option self._parser.add_argument( self.S_ARG_LANG_OPTION, dest=self.S_ARG_LANG_DEST, help=self.S_ARG_LANG_HELP, metavar=self.S_ARG_LANG_METAVAR, ) # add version option self._parser.add_argument( self.S_ARG_VER_OPTION, dest=self.S_ARG_VER_DEST, help=self.S_ARG_VER_HELP, metavar=self.S_ARG_VER_METAVAR, ) # do setup super()._setup() # -------------------------------------------------------------------------- # Get project info # -------------------------------------------------------------------------- def _get_project_info(self): \"\"\" Get project info Raises: OSError if anything goes wrong Check that the PyPlate data is present and correct, so we don't crash looking for non-existent files. Also handles command line settings. \"\"\" # ---------------------------------------------------------------------- # handle -i self._handle_i() # ---------------------------------------------------------------------- # sanity checks # check if dir_prj has pyplate folder for a valid prj path_pyplate = self._dir_prj / P.C.S_PRJ_PP_DIR if not path_pyplate.exists(): print(P.C.S_ERR_NOT_PRJ) P.sys.exit(-1) # check if data files exist path_prv = self._dir_prj / P.C.S_PRJ_PRV_CFG path_pub = self._dir_prj / P.C.S_PRJ_PUB_CFG if not path_prv.exists() or not path_pub.exists(): print(P.C.S_ERR_PP_MISSING) P.sys.exit(-1) # ---------------------------------------------------------------------- # make dicts from files # check if files are valid json try: # get settings dicts in private.json self._dict_prv = F.load_paths_into_dict(path_prv) # get settings dicts in project.json # NB: may contain dunders self._dict_pub = F.load_paths_into_dict(path_pub) # if there was a problem except OSError as e: # from load_dicts # exit gracefully print(self.S_ERR_ERR, e) P.sys.exit(-1) # ---------------------------------------------------------------------- # fix dicts self._fix_dicts() # ---------------------------------------------------------------------- # handle -d # NB: do after _fix_dicts if self._cmd_debug: self._dict_dbg = dict(P.C.D_DBG_PB) # ---------------------------------------------------------------------- # handle -v self._handle_v() # ---------------------------------------------------------------------- # handle -l self._handle_l() # ---------------------------------------------------------------------- # print some info print() print(self.S_MSG_BAKE.format(self._dir_prj.name)) # blank line before printing progress print() # -------------------------------------------------------------------------- # Do any work before making dist # -------------------------------------------------------------------------- def _do_before_dist(self): \"\"\" Do any work before making dist Do any work on the dist folder before it is created. This method is called after _do_after_fix, and before _do_dist. \"\"\" P.C.do_before_dist( self._dir_prj, self._dict_prv, self._dict_pub, self._dict_dbg ) # -------------------------------------------------------------------------- # Copy fixed files to final location # -------------------------------------------------------------------------- def _do_dist(self): \"\"\" Copy fixed files to final location Gets dirs/files from project and copies them to the dist/assets dir. \"\"\" # print info print(P.C.S_ACTION_DIST, end=\"\", flush=True) # ---------------------------------------------------------------------- # do common dist stuff # find old dist? nuke it from orbit! it's the only way to be sure! a_dist = self._dir_prj / P.C.S_DIR_DIST if a_dist.is_dir(): shutil.rmtree(a_dist) # make child dir in case we nuked name_fmt = self._dict_prv_prj[\"__PP_FMT_DIST__\"] p_dist = a_dist / name_fmt p_dist.mkdir(parents=True) # for each key, val (type, dict) for key, val in self._dict_pub_dist.items(): # get src/dst rel to prj dir/dist dir src = self._dir_prj / key dst = p_dist / str(val) if not dst.exists(): dst.mkdir(parents=True) dst = dst / src.name # do the copy if src.exists() and src.is_dir(): shutil.copytree(src, dst, dirs_exist_ok=True) elif src.exists() and src.is_file(): shutil.copy2(src, dst) # ---------------------------------------------------------------------- # done copying project files F.printc(P.C.S_ACTION_DONE, fg=F.C_FG_GREEN, bold=True) # -------------------------------------------------------------------------- # Do any work after making dist # -------------------------------------------------------------------------- def _do_after_dist(self): \"\"\" Do any work after making dist Do any work on the dist folder after it is created. This method is called after _do_dist. Currently, this method purges any \"ABOUT\" file used as placeholders for github syncing. It also tars the source folder if it is a package, making for one (or two) less steps in the user's install process. \"\"\" P.C.do_after_dist( self._dir_prj, self._dict_prv, self._dict_pub, self._dict_dbg ) # -------------------------------------------------------------------------- # Handle the -i option # -------------------------------------------------------------------------- def _handle_i(self): \"\"\" Docstring for _handle_i :param self: Description \"\"\" ide = self._dict_args.get(self.S_ARG_IDE_DEST, False) if not ide: return # ask for prj name rel to cwd in_str = P.C.S_ASK_IDE.format(self._dir_prj) while True: prj_name = input(in_str) if prj_name == \"\": continue # if running in ide, cwd is pyplate prj dir, so move up + down tmp_dir = P.Path(self._dir_prj / prj_name).resolve() # check if project exists if not tmp_dir.exists(): e_str = P.C.S_ERR_NOT_EXIST.format(tmp_dir) print(e_str) continue # set project dir and exit loop self._dir_prj = tmp_dir # print() break # -------------------------------------------------------------------------- # Handle the -v option # -------------------------------------------------------------------------- def _handle_v(self): \"\"\" Docstring for _handle_v :param self: Description \"\"\" # first check if passed on cmd line ver = self._dict_args.get(self.S_ARG_VER_DEST, None) if ver: # check version before we start fixing pattern = P.C.S_SEM_VER_VALID version = ver ver_ok = P.re.search(pattern, version) is not None # ask if user wants to keep invalid version or quit if not ver_ok: res = F.dialog( P.C.S_ERR_SEM_VER, [F.S_ASK_YES, F.S_ASK_NO], default=F.S_ASK_NO, loop=True, ) if res != F.S_ASK_YES: P.sys.exit(-1) # not passed, ask question else: # format and ask question old_ver = self._dict_pub_meta[P.C.S_KEY_META_VERSION] ask_ver = P.C.S_ASK_VER.format(old_ver) # loop until condition while True: # ask for new version new_ver = input(ask_ver) # user pressed Enter, return original if new_ver == \"\": # set the same version, and we are done ver = old_ver break # check version before we start fixing pattern = P.C.S_SEM_VER_VALID version = new_ver ver_ok = P.re.search(pattern, version) is not None # ask if user wants to keep invalid version or quit if ver_ok: # set the new version, and we are done ver = new_ver break # print version error print(P.C.S_ERR_SEM_VER) # change in project.json self._dict_pub_meta[P.C.S_KEY_META_VERSION] = ver # set version in install dict prj_type = self._dict_prv_prj[\"__PP_TYPE_PRJ__\"] if prj_type in P.C.L_APP_INSTALL: self._dict_pub_inst[P.C.S_KEY_INST_VER] = ver # -------------------------------------------------------------------------- # Handle the -l option # -------------------------------------------------------------------------- def _handle_l(self): \"\"\" Docstring for _handle_l :param self: Description \"\"\" # if no lang, no go lang_file = self._dict_args.get(self.S_ARG_LANG_DEST, None) if not lang_file: return print(self.S_MSG_LANG_ADD.format(lang_file), flush=True, end=\"\") # default lang code lang_code = \"\" # get code from file p_lang = self._dir_prj / lang_file # in case of typo -) if not p_lang.exists(): F.printc(P.C.S_ACTION_FAIL, fg=F.C_FG_RED, bold=True) return # find the line with open(p_lang, \"r\", encoding=P.C.S_ENCODING) as a_file: string = a_file.read() # find the lang res = re.search(P.C.S_PO_LANG_SCH, string) if res: lang_code = res.group(2) # make sure it worked before doing api if lang_code == \"\": F.printc(P.C.S_ACTION_FAIL, fg=F.C_FG_RED, bold=True) return # get lang dict from props dict_lang = self._dict_pub_i18n[P.C.S_KEY_PUB_I18N_WLANGS] # only add once (might be old) if not lang_code in dict_lang: dict_lang.append(lang_code) # check file exists dst = self._dir_prj / P.C.S_DIR_I18N / P.C.S_DIR_PO / lang_code dst_file = dst / lang_file if dst_file.exists(): print() # ask to overwrite msg = self.S_ASK_OVER.format(lang_file) ask = F.dialog( msg, [F.S_ASK_YES, F.S_ASK_NO], default=F.S_ASK_NO ) if ask != F.S_ASK_YES: F.printc(P.C.S_ACTION_FAIL, fg=F.C_FG_RED, bold=True) return # copy file to dest dst.mkdir(parents=True, exist_ok=True) shutil.copy(p_lang, dst_file) F.printc(P.C.S_ACTION_DONE, fg=F.C_FG_GREEN, bold=True)","title":"PyBaker"},{"location":"API/src/pybaker/#src.pybaker.PyBaker.main","text":"The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. Source code in src/pybaker.py def main(self): \"\"\" The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. \"\"\" # call boilerplate code self._setup() # ---------------------------------------------------------------------- # main stuff # get project info self._get_project_info() # do any fixing up of dicts (like meta keywords, etc) self._do_before_fix() # do replacements in final project location self._do_fix() # do extra stuff to final dir after fix self._do_after_fix() # do any fixing up of dicts (like meta keywords, etc) self._do_before_dist() # copy project files into dist folder self._do_dist() # do any fixing up of dicts (like meta keywords, etc) self._do_after_dist() # ---------------------------------------------------------------------- # teardown # call boilerplate code self._teardown()","title":"main"},{"location":"API/src/pymaker/","text":"pymaker.py A program to create a PyPlate project from a few variables This module gets the project type, the project's destination dir, copies the required dirs/files for the project type from the template to the specified destination, and performs some initial fixes/replacements of text and path names in the resulting files. Run pymaker -h for more options. PyMaker Bases: PyPlate The main class, responsible for the operation of the program Public methods main: The main method of the program This class implements all the needed functionality of PyMaker, to create a PyPlate project from a template. Source code in src/pymaker.py class PyMaker(PyPlate): \"\"\" The main class, responsible for the operation of the program Public methods: main: The main method of the program This class implements all the needed functionality of PyMaker, to create a PyPlate project from a template. \"\"\" # -------------------------------------------------------------------------- # Class constants # -------------------------------------------------------------------------- # about string S_ABOUT = ( \"\\n\" f\"{'PyPlate/PyMaker'}\\n\" f\"{PyPlate.S_PP_SHORT_DESC}\\n\" f\"{PyPlate.S_PP_VERSION}\\n\" f\"https://github.com/cyclopticnerve/PyPlate\\n\" ) # I18N cmd line instructions string S_EPILOG = _( \"Run this program from the directory where you want to create \" \"a project.\" ) # messages # make msg # NB: param is name of project folder S_MSG_MAKE = _(\"Making {}\") # -------------------------------------------------------------------------- # Public methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # The main method of the program # -------------------------------------------------------------------------- def main(self): \"\"\" The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. \"\"\" # call boilerplate code self._setup() # ---------------------------------------------------------------------- # main stuff # get project info self._get_project_info() # do before template self._do_before_template() # copy template self._do_template() # do before template self._do_after_template() # do any fixing up of dicts (like meta keywords, etc) self._do_before_fix() # do replacements in final project location self._do_fix() # do extra stuff to final dir after fix self._do_after_fix() # ---------------------------------------------------------------------- # teardown # call boilerplate code self._teardown() # -------------------------------------------------------------------------- # Private methods # -------------------------------------------------------------------------- # NB: these are the main steps, called in order from main # -------------------------------------------------------------------------- # Boilerplate to use at the start of main # -------------------------------------------------------------------------- def _setup(self): \"\"\" Boilerplate to use at the start of main Perform some mundane stuff like setting properties. \"\"\" # do parent setup super()._setup() # do not run pymaker in pyplate dir if self._dir_prj.is_relative_to(P.P_DIR_PRJ): print(P.C.S_ERR_PRJ_DIR_IS_PP) P.sys.exit(-1) # -------------------------------------------------------------------------- # Get project info # -------------------------------------------------------------------------- def _get_project_info(self): \"\"\" Get project info Asks the user for project info, such as type and name, to be saved to self._dict_prv_prj. \"\"\" # check version from conf pattern = P.C.S_SEM_VER_VALID version = P.C.D_PUB_META[P.C.S_KEY_META_VERSION] ver_ok = P.re.search(pattern, version) is not None # ask if user wants to keep invalid version or quit if not ver_ok: res = F.dialog( P.C.S_ERR_SEM_VER, [F.S_ASK_YES, F.S_ASK_NO], default=F.S_ASK_NO, # loop=True ) if res != F.S_ASK_YES: P.sys.exit(-1) # ---------------------------------------------------------------------- # first question is type # NB: this makes the string to display in terminal # sanity check prj_type = \"\" # build the input question types = [] for item in P.C.L_TYPES: s = P.C.S_ASK_TYPE_FMT.format(item[0], item[1]) types.append(s) str_types = P.C.S_ASK_TYPE_JOIN.join(types) # format the question in_type = P.C.S_ASK_TYPE.format(str_types) # loop forever until we get a valid type while True: # ask for type of project (single letter) prj_type = input(in_type) # check for valid type if self._check_type(prj_type): prj_type = prj_type[0].lower() # at this point, type is valid so exit loop break # ---------------------------------------------------------------------- # next question is name # if in debug mode if self._cmd_debug: # get long name for item in P.C.L_TYPES: if item[0] == prj_type: # get debug name of project name_prj = f\"{item[1]} DEBUG\" break # dir name, no spaces name_prj_big = name_prj.replace(\" \", \"_\") # set up for existence check tmp_dir = self._dir_prj / name_prj_big # check if project already exists if tmp_dir.exists(): # if it does exist, \"nuke it from orbit! it's the only way to # be sure!\" # NB: yes i know ive used this joke more than once... FUCK YOU # ITS FUNNY shutil.rmtree(tmp_dir) # not debug else: # loop forever until we get a valid name that does not exist while True: # ask for name of project name_prj = input(P.C.S_ASK_NAME) name_prj = name_prj.strip(\" \") # check for valid name if self._check_name(name_prj): # dir name, no spaces name_prj_big = name_prj.replace(\" \", \"_\") # set up for existence check tmp_dir = self._dir_prj / name_prj_big # check if project already exists if tmp_dir.exists(): # tell the user that the old name exists print(P.C.S_ERR_EXIST.format(name_prj_big)) else: break # save global property self._dir_prj = tmp_dir # save other names name_prj_small = name_prj_big.lower() name_prj_pascal = F.pascal_case(name_prj_small) # ---------------------------------------------------------------------- # here we figure out the binary/package/window name for a project # NB: for a cli, the binary name is the project name lowercased # for a gui we should ask for the main window class name # for a package we should ask for the module name name_sec = \"\" name_sec_big = \"\" name_sec_small = \"\" name_sec_pascal = \"\" # do we need a second name? if prj_type in P.C.D_NAME_SEC: # dup prj names if debug if self._cmd_debug: name_sec = name_prj name_sec_big = name_prj_big name_sec_small = name_prj_small name_sec_pascal = name_prj_pascal # if not debug, if need second name, ask for it else: # format question for second name s_sec_ask = P.C.D_NAME_SEC[prj_type] s_sec_ask_fmt = s_sec_ask.format(name_prj_small) # loop forever until we get a valid name or empty string while True: # ask for second name name_sec = input(s_sec_ask_fmt) name_sec = name_sec.strip(\" \") # empty, keep default if name_sec == \"\": name_sec = name_prj_small # check for valid name if self._check_name(name_sec): name_sec_big = name_sec.replace(\" \", \"_\") break # save other names name_sec_small = name_sec_big.lower() name_sec_pascal = F.pascal_case(name_sec_small) # ---------------------------------------------------------------------- # make dicts from conf defaults # create global settings dicts in private.json self._dict_prv = { P.C.S_KEY_PRV_ALL: dict(P.C.D_PRV_ALL), P.C.S_KEY_PRV_PRJ: dict(P.C.D_PRV_PRJ), } # create individual dicts in project.json self._dict_pub = { P.C.S_KEY_PUB_META: dict(P.C.D_PUB_META), P.C.S_KEY_PUB_BL: dict(P.C.D_PUB_BL), P.C.S_KEY_PUB_DBG: dict(P.C.D_PUB_DBG), P.C.S_KEY_PUB_DIST: dict(P.C.D_PUB_DIST), P.C.S_KEY_PUB_DOCS: dict(P.C.D_PUB_DOCS), P.C.S_KEY_PUB_I18N: dict(P.C.D_PUB_I18N), P.C.S_KEY_PUB_INST: dict(P.C.D_PUB_INST), # P.C.S_KEY_PUB_UNINST: dict(P.C.D_PUB_UNINST), } # ---------------------------------------------------------------------- # fill dicts # get prv subs self._dict_prv_all = self._dict_prv[P.C.S_KEY_PRV_ALL] self._dict_prv_prj = self._dict_prv[P.C.S_KEY_PRV_PRJ] # save project stuff self._dict_prv_prj[\"__PP_TYPE_PRJ__\"] = prj_type self._dict_prv_prj[\"__PP_NAME_PRJ__\"] = name_prj self._dict_prv_prj[\"__PP_NAME_PRJ_BIG__\"] = name_prj_big self._dict_prv_prj[\"__PP_NAME_PRJ_SMALL__\"] = name_prj_small self._dict_prv_prj[\"__PP_NAME_PRJ_PASCAL__\"] = name_prj_pascal self._dict_prv_prj[\"__PP_NAME_SEC_BIG__\"] = name_sec_big self._dict_prv_prj[\"__PP_NAME_SEC_SMALL__\"] = name_sec_small self._dict_prv_prj[\"__PP_NAME_SEC_PASCAL__\"] = name_sec_pascal self._dict_prv_prj[\"__PP_NAME_VENV__\"] = P.C.S_VENV_FMT_NAME.format( name_prj_small ) self._dict_prv_prj[\"__PP_FILE_APP__\"] = P.C.S_APP_FILE_FMT.format( name_prj_small ) self._dict_prv_prj[\"__PP_CLASS_APP__\"] = name_prj_pascal self._dict_prv_prj[\"__PP_FILE_WIN__\"] = P.C.S_WIN_FILE_FMT.format( name_sec_small ) self._dict_prv_prj[\"__PP_CLASS_WIN__\"] = name_sec_pascal # ---------------------------------------------------------------------- # get reps to fix public self._fix_dicts() # ---------------------------------------------------------------------- # handle -d # NB: do after _fix dicts if self._cmd_debug: self._dict_dbg = dict(P.C.D_DBG_PM) # ---------------------------------------------------------------------- # print some info print() print(self.S_MSG_MAKE.format(name_prj_big)) # blank line before printing progress print() # -------------------------------------------------------------------------- # Do any work before template copy # -------------------------------------------------------------------------- def _do_before_template(self): \"\"\" Do any work before template copy Do any work before copying the template. This method is called just before _do_template, before any files have been copied.\\n It is mostly used to make final adjustments to the 'dict_prv' and 'dict_pub' dicts before any copying occurs. \"\"\" P.C.do_before_template( self._dir_prj, self._dict_prv, self._dict_pub, self._dict_dbg ) # -------------------------------------------------------------------------- # Copy template files to final location # -------------------------------------------------------------------------- def _do_template(self): \"\"\" Copy template files to final location Gets dirs/files from template and copies them to the project dir. \"\"\" # show info print(P.C.S_ACTION_COPY, end=\"\", flush=True) # ---------------------------------------------------------------------- # do template/all # copy template/all src = P.P_DIR_PRJ / P.C.S_DIR_TEMPLATE / P.C.S_DIR_ALL dst = self._dir_prj shutil.copytree(src, dst, dirs_exist_ok=True) # ---------------------------------------------------------------------- # copy template/type # get some paths prj_type_short = self._dict_prv_prj[\"__PP_TYPE_PRJ__\"] prj_type_long = \"\" # get long type of project for item in P.C.L_TYPES: if item[0] == prj_type_short: prj_type_long = item[2] break # get the src dir in the template dir src = P.P_DIR_PRJ / P.C.S_DIR_TEMPLATE / prj_type_long dst = self._dir_prj shutil.copytree(src, dst, dirs_exist_ok=True) # ---------------------------------------------------------------------- # do stuff outside template all/type # copy linked files for key, val in P.C.D_COPY.items(): # get src/dst src = P.P_DIR_PRJ / key dst = self._dir_prj / val # copy dir/file if src.is_dir(): shutil.copytree(src, dst) elif src.is_file(): shutil.copy2(src, dst) # ---------------------------------------------------------------------- # merge reqs # merge reqs files from all and prj self._merge_reqs(prj_type_long) # ---------------------------------------------------------------------- # done F.printc(P.C.S_ACTION_DONE, fg=F.C_FG_GREEN, bold=True) # -------------------------------------------------------------------------- # Do any work after template copy # -------------------------------------------------------------------------- def _do_after_template(self): \"\"\" Do any work after template copy Do any work after copying the template. This method is called after _do_template, and before _do_before_fix. \"\"\" P.C.do_after_template( self._dir_prj, self._dict_prv, self._dict_pub, self._dict_dbg ) main() The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. Source code in src/pymaker.py def main(self): \"\"\" The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. \"\"\" # call boilerplate code self._setup() # ---------------------------------------------------------------------- # main stuff # get project info self._get_project_info() # do before template self._do_before_template() # copy template self._do_template() # do before template self._do_after_template() # do any fixing up of dicts (like meta keywords, etc) self._do_before_fix() # do replacements in final project location self._do_fix() # do extra stuff to final dir after fix self._do_after_fix() # ---------------------------------------------------------------------- # teardown # call boilerplate code self._teardown()","title":"pymaker.py"},{"location":"API/src/pymaker/#pymakerpy","text":"A program to create a PyPlate project from a few variables This module gets the project type, the project's destination dir, copies the required dirs/files for the project type from the template to the specified destination, and performs some initial fixes/replacements of text and path names in the resulting files. Run pymaker -h for more options.","title":"pymaker.py"},{"location":"API/src/pymaker/#src.pymaker.PyMaker","text":"Bases: PyPlate The main class, responsible for the operation of the program Public methods main: The main method of the program This class implements all the needed functionality of PyMaker, to create a PyPlate project from a template. Source code in src/pymaker.py class PyMaker(PyPlate): \"\"\" The main class, responsible for the operation of the program Public methods: main: The main method of the program This class implements all the needed functionality of PyMaker, to create a PyPlate project from a template. \"\"\" # -------------------------------------------------------------------------- # Class constants # -------------------------------------------------------------------------- # about string S_ABOUT = ( \"\\n\" f\"{'PyPlate/PyMaker'}\\n\" f\"{PyPlate.S_PP_SHORT_DESC}\\n\" f\"{PyPlate.S_PP_VERSION}\\n\" f\"https://github.com/cyclopticnerve/PyPlate\\n\" ) # I18N cmd line instructions string S_EPILOG = _( \"Run this program from the directory where you want to create \" \"a project.\" ) # messages # make msg # NB: param is name of project folder S_MSG_MAKE = _(\"Making {}\") # -------------------------------------------------------------------------- # Public methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # The main method of the program # -------------------------------------------------------------------------- def main(self): \"\"\" The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. \"\"\" # call boilerplate code self._setup() # ---------------------------------------------------------------------- # main stuff # get project info self._get_project_info() # do before template self._do_before_template() # copy template self._do_template() # do before template self._do_after_template() # do any fixing up of dicts (like meta keywords, etc) self._do_before_fix() # do replacements in final project location self._do_fix() # do extra stuff to final dir after fix self._do_after_fix() # ---------------------------------------------------------------------- # teardown # call boilerplate code self._teardown() # -------------------------------------------------------------------------- # Private methods # -------------------------------------------------------------------------- # NB: these are the main steps, called in order from main # -------------------------------------------------------------------------- # Boilerplate to use at the start of main # -------------------------------------------------------------------------- def _setup(self): \"\"\" Boilerplate to use at the start of main Perform some mundane stuff like setting properties. \"\"\" # do parent setup super()._setup() # do not run pymaker in pyplate dir if self._dir_prj.is_relative_to(P.P_DIR_PRJ): print(P.C.S_ERR_PRJ_DIR_IS_PP) P.sys.exit(-1) # -------------------------------------------------------------------------- # Get project info # -------------------------------------------------------------------------- def _get_project_info(self): \"\"\" Get project info Asks the user for project info, such as type and name, to be saved to self._dict_prv_prj. \"\"\" # check version from conf pattern = P.C.S_SEM_VER_VALID version = P.C.D_PUB_META[P.C.S_KEY_META_VERSION] ver_ok = P.re.search(pattern, version) is not None # ask if user wants to keep invalid version or quit if not ver_ok: res = F.dialog( P.C.S_ERR_SEM_VER, [F.S_ASK_YES, F.S_ASK_NO], default=F.S_ASK_NO, # loop=True ) if res != F.S_ASK_YES: P.sys.exit(-1) # ---------------------------------------------------------------------- # first question is type # NB: this makes the string to display in terminal # sanity check prj_type = \"\" # build the input question types = [] for item in P.C.L_TYPES: s = P.C.S_ASK_TYPE_FMT.format(item[0], item[1]) types.append(s) str_types = P.C.S_ASK_TYPE_JOIN.join(types) # format the question in_type = P.C.S_ASK_TYPE.format(str_types) # loop forever until we get a valid type while True: # ask for type of project (single letter) prj_type = input(in_type) # check for valid type if self._check_type(prj_type): prj_type = prj_type[0].lower() # at this point, type is valid so exit loop break # ---------------------------------------------------------------------- # next question is name # if in debug mode if self._cmd_debug: # get long name for item in P.C.L_TYPES: if item[0] == prj_type: # get debug name of project name_prj = f\"{item[1]} DEBUG\" break # dir name, no spaces name_prj_big = name_prj.replace(\" \", \"_\") # set up for existence check tmp_dir = self._dir_prj / name_prj_big # check if project already exists if tmp_dir.exists(): # if it does exist, \"nuke it from orbit! it's the only way to # be sure!\" # NB: yes i know ive used this joke more than once... FUCK YOU # ITS FUNNY shutil.rmtree(tmp_dir) # not debug else: # loop forever until we get a valid name that does not exist while True: # ask for name of project name_prj = input(P.C.S_ASK_NAME) name_prj = name_prj.strip(\" \") # check for valid name if self._check_name(name_prj): # dir name, no spaces name_prj_big = name_prj.replace(\" \", \"_\") # set up for existence check tmp_dir = self._dir_prj / name_prj_big # check if project already exists if tmp_dir.exists(): # tell the user that the old name exists print(P.C.S_ERR_EXIST.format(name_prj_big)) else: break # save global property self._dir_prj = tmp_dir # save other names name_prj_small = name_prj_big.lower() name_prj_pascal = F.pascal_case(name_prj_small) # ---------------------------------------------------------------------- # here we figure out the binary/package/window name for a project # NB: for a cli, the binary name is the project name lowercased # for a gui we should ask for the main window class name # for a package we should ask for the module name name_sec = \"\" name_sec_big = \"\" name_sec_small = \"\" name_sec_pascal = \"\" # do we need a second name? if prj_type in P.C.D_NAME_SEC: # dup prj names if debug if self._cmd_debug: name_sec = name_prj name_sec_big = name_prj_big name_sec_small = name_prj_small name_sec_pascal = name_prj_pascal # if not debug, if need second name, ask for it else: # format question for second name s_sec_ask = P.C.D_NAME_SEC[prj_type] s_sec_ask_fmt = s_sec_ask.format(name_prj_small) # loop forever until we get a valid name or empty string while True: # ask for second name name_sec = input(s_sec_ask_fmt) name_sec = name_sec.strip(\" \") # empty, keep default if name_sec == \"\": name_sec = name_prj_small # check for valid name if self._check_name(name_sec): name_sec_big = name_sec.replace(\" \", \"_\") break # save other names name_sec_small = name_sec_big.lower() name_sec_pascal = F.pascal_case(name_sec_small) # ---------------------------------------------------------------------- # make dicts from conf defaults # create global settings dicts in private.json self._dict_prv = { P.C.S_KEY_PRV_ALL: dict(P.C.D_PRV_ALL), P.C.S_KEY_PRV_PRJ: dict(P.C.D_PRV_PRJ), } # create individual dicts in project.json self._dict_pub = { P.C.S_KEY_PUB_META: dict(P.C.D_PUB_META), P.C.S_KEY_PUB_BL: dict(P.C.D_PUB_BL), P.C.S_KEY_PUB_DBG: dict(P.C.D_PUB_DBG), P.C.S_KEY_PUB_DIST: dict(P.C.D_PUB_DIST), P.C.S_KEY_PUB_DOCS: dict(P.C.D_PUB_DOCS), P.C.S_KEY_PUB_I18N: dict(P.C.D_PUB_I18N), P.C.S_KEY_PUB_INST: dict(P.C.D_PUB_INST), # P.C.S_KEY_PUB_UNINST: dict(P.C.D_PUB_UNINST), } # ---------------------------------------------------------------------- # fill dicts # get prv subs self._dict_prv_all = self._dict_prv[P.C.S_KEY_PRV_ALL] self._dict_prv_prj = self._dict_prv[P.C.S_KEY_PRV_PRJ] # save project stuff self._dict_prv_prj[\"__PP_TYPE_PRJ__\"] = prj_type self._dict_prv_prj[\"__PP_NAME_PRJ__\"] = name_prj self._dict_prv_prj[\"__PP_NAME_PRJ_BIG__\"] = name_prj_big self._dict_prv_prj[\"__PP_NAME_PRJ_SMALL__\"] = name_prj_small self._dict_prv_prj[\"__PP_NAME_PRJ_PASCAL__\"] = name_prj_pascal self._dict_prv_prj[\"__PP_NAME_SEC_BIG__\"] = name_sec_big self._dict_prv_prj[\"__PP_NAME_SEC_SMALL__\"] = name_sec_small self._dict_prv_prj[\"__PP_NAME_SEC_PASCAL__\"] = name_sec_pascal self._dict_prv_prj[\"__PP_NAME_VENV__\"] = P.C.S_VENV_FMT_NAME.format( name_prj_small ) self._dict_prv_prj[\"__PP_FILE_APP__\"] = P.C.S_APP_FILE_FMT.format( name_prj_small ) self._dict_prv_prj[\"__PP_CLASS_APP__\"] = name_prj_pascal self._dict_prv_prj[\"__PP_FILE_WIN__\"] = P.C.S_WIN_FILE_FMT.format( name_sec_small ) self._dict_prv_prj[\"__PP_CLASS_WIN__\"] = name_sec_pascal # ---------------------------------------------------------------------- # get reps to fix public self._fix_dicts() # ---------------------------------------------------------------------- # handle -d # NB: do after _fix dicts if self._cmd_debug: self._dict_dbg = dict(P.C.D_DBG_PM) # ---------------------------------------------------------------------- # print some info print() print(self.S_MSG_MAKE.format(name_prj_big)) # blank line before printing progress print() # -------------------------------------------------------------------------- # Do any work before template copy # -------------------------------------------------------------------------- def _do_before_template(self): \"\"\" Do any work before template copy Do any work before copying the template. This method is called just before _do_template, before any files have been copied.\\n It is mostly used to make final adjustments to the 'dict_prv' and 'dict_pub' dicts before any copying occurs. \"\"\" P.C.do_before_template( self._dir_prj, self._dict_prv, self._dict_pub, self._dict_dbg ) # -------------------------------------------------------------------------- # Copy template files to final location # -------------------------------------------------------------------------- def _do_template(self): \"\"\" Copy template files to final location Gets dirs/files from template and copies them to the project dir. \"\"\" # show info print(P.C.S_ACTION_COPY, end=\"\", flush=True) # ---------------------------------------------------------------------- # do template/all # copy template/all src = P.P_DIR_PRJ / P.C.S_DIR_TEMPLATE / P.C.S_DIR_ALL dst = self._dir_prj shutil.copytree(src, dst, dirs_exist_ok=True) # ---------------------------------------------------------------------- # copy template/type # get some paths prj_type_short = self._dict_prv_prj[\"__PP_TYPE_PRJ__\"] prj_type_long = \"\" # get long type of project for item in P.C.L_TYPES: if item[0] == prj_type_short: prj_type_long = item[2] break # get the src dir in the template dir src = P.P_DIR_PRJ / P.C.S_DIR_TEMPLATE / prj_type_long dst = self._dir_prj shutil.copytree(src, dst, dirs_exist_ok=True) # ---------------------------------------------------------------------- # do stuff outside template all/type # copy linked files for key, val in P.C.D_COPY.items(): # get src/dst src = P.P_DIR_PRJ / key dst = self._dir_prj / val # copy dir/file if src.is_dir(): shutil.copytree(src, dst) elif src.is_file(): shutil.copy2(src, dst) # ---------------------------------------------------------------------- # merge reqs # merge reqs files from all and prj self._merge_reqs(prj_type_long) # ---------------------------------------------------------------------- # done F.printc(P.C.S_ACTION_DONE, fg=F.C_FG_GREEN, bold=True) # -------------------------------------------------------------------------- # Do any work after template copy # -------------------------------------------------------------------------- def _do_after_template(self): \"\"\" Do any work after template copy Do any work after copying the template. This method is called after _do_template, and before _do_before_fix. \"\"\" P.C.do_after_template( self._dir_prj, self._dict_prv, self._dict_pub, self._dict_dbg )","title":"PyMaker"},{"location":"API/src/pymaker/#src.pymaker.PyMaker.main","text":"The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. Source code in src/pymaker.py def main(self): \"\"\" The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. \"\"\" # call boilerplate code self._setup() # ---------------------------------------------------------------------- # main stuff # get project info self._get_project_info() # do before template self._do_before_template() # copy template self._do_template() # do before template self._do_after_template() # do any fixing up of dicts (like meta keywords, etc) self._do_before_fix() # do replacements in final project location self._do_fix() # do extra stuff to final dir after fix self._do_after_fix() # ---------------------------------------------------------------------- # teardown # call boilerplate code self._teardown()","title":"main"},{"location":"API/src/pyplate/","text":"pyplate.py A class to be the base for pymaker/pybaker This is the base class that contains code common to both PyMaker and PyBaker. PyPlate The main class, responsible for the operation of the program Public methods main: The main method of the program This class implements all the needed functionality of PyMaker, to create a PyPlate project from a template. Source code in src/pyplate.py class PyPlate: \"\"\" The main class, responsible for the operation of the program Public methods: main: The main method of the program This class implements all the needed functionality of PyMaker, to create a PyPlate project from a template. \"\"\" # -------------------------------------------------------------------------- # Class constants # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # strings # pyplate: replace=True # short description # pylint: disable=line-too-long # NB: need to keep on one line for replacement S_PP_SHORT_DESC = \"A program for creating and building CLI/GUI/Packages in Python from a template\" # pylint: enable=line-too-long # version string S_PP_VERSION = \"Version 1.1.1\" # pyplate: replace=False # debug option strings S_ARG_DBG_OPTION = \"-d\" S_ARG_DBG_ACTION = \"store_true\" S_ARG_DBG_DEST = \"DBG_DEST\" # I18N: debug mode help S_ARG_DBG_HELP = _(\"enable debugging mode\") # config option strings S_ARG_HLP_OPTION = \"-h\" S_ARG_HLP_ACTION = \"store_true\" S_ARG_HLP_DEST = \"HLP_DEST\" # I18N: help option help S_ARG_HLP_HELP = _(\"show this help message and exit\") # config option strings S_ARG_UNINST_OPTION = \"--uninstall\" S_ARG_UNINST_ACTION = \"store_true\" S_ARG_UNINST_DEST = \"UNINST_DEST\" # I18N: uninstall option help S_ARG_UNINST_HELP = _(\"uninstall this program\") # about string (to be set by subclass) S_ABOUT = \"\" # I18N if using argparse, add help at end of about S_ABOUT_HELP = _(\"Use -h for help\") + \"\\n\" # cmd line instructions string (to be set by subclass) S_EPILOG = \"\" # default format af log files S_LOG_FMT = \"%(asctime)s [%(levelname)-7s] %(message)s\" S_LOG_DATE_FMT = \"%Y-%m-%d %I:%M:%S %p\" # -------------------------------------------------------------------------- # questions # I18N: answer yes # S_ASK_YES = _(\"y\") # # I18N: answer no # S_ASK_NO = _(\"N\") # NB: format param is prog name # I18N: ask to uninstall S_ASK_UNINST = _(\"This will uninstall {}.\\nDo you want to continue?\") # -------------------------------------------------------------------------- # messages # I18N: process aborted S_MSG_ABORT = _(\"Aborted\") # -------------------------------------------------------------------------- # error messages # I18N: an error occurred S_ERR_ERR = _(\"Error:\") # I18N: uninstall not found S_ERR_NO_UNINST = _(\"Uninstall files not found\") # NB: format param is file path # I18N: could not find -c file S_ERR_NO_CFG = _(\"Config file {} not found\") # -------------------------------------------------------------------------- # Instance methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Initialize the new object # -------------------------------------------------------------------------- def __init__(self): \"\"\" Initialize the new object Initializes a new instance of the class, setting the default values of its properties, and any other code that needs to run to create a new object. \"\"\" # set the initial values of properties # internal props self._dir_prj = Path() self._dict_rep = {} self._dict_type_rules = {} self._dict_sw_block = {} self._dict_sw_line = {} # private.json dicts self._dict_prv = {} self._dict_prv_all = {} self._dict_prv_prj = {} # project.json dicts self._dict_pub = {} self._dict_pub_bl = {} self._dict_pub_dbg = {} self._dict_pub_dist = {} self._dict_pub_docs = {} self._dict_pub_i18n = {} self._dict_pub_meta = {} self._dict_pub_inst = {} # self._dict_pub_uninst = {} # dictionary to hold current pm/pb debug settings self._dict_dbg = {} # log stuff self._logger = logging.getLogger(__name__) logging.basicConfig( filename=P_LOG_DEF, level=logging.INFO, format=self.S_LOG_FMT, datefmt=self.S_LOG_DATE_FMT, ) # cmd line stuff self._parser = argparse.ArgumentParser( formatter_class=CNFormatter, add_help=False ) # set arg defaults self._dict_args = {} self._cmd_debug = False # ---------------------------------------------------------------------- # set self._dir_prj # assume we are running in the project dir # this is used in a lot of places, so just shorthand it self._dir_prj = Path.cwd() # ---------------------------------------------------------------------- # set switch dicts to defaults self._dict_sw_block = dict(C.D_SWITCH_DEF) self._dict_sw_line = dict(C.D_SWITCH_DEF) # -------------------------------------------------------------------------- # Private methods # -------------------------------------------------------------------------- # NB: these are the main steps, called in order from main() # -------------------------------------------------------------------------- # Boilerplate to use at the start of main # -------------------------------------------------------------------------- def _setup(self): \"\"\" Boilerplate to use at the start of main Perform some mundane stuff like running the arg parser and loading config files. \"\"\" # ---------------------------------------------------------------------- # use cmd line # add debug option self._parser.add_argument( self.S_ARG_DBG_OPTION, dest=self.S_ARG_DBG_DEST, help=self.S_ARG_DBG_HELP, action=self.S_ARG_DBG_ACTION, ) # always add help option self._parser.add_argument( self.S_ARG_HLP_OPTION, action=self.S_ARG_HLP_ACTION, dest=self.S_ARG_HLP_DEST, help=self.S_ARG_HLP_HELP, ) # add uninstall option self._parser.add_argument( self.S_ARG_UNINST_OPTION, action=self.S_ARG_UNINST_ACTION, dest=self.S_ARG_UNINST_DEST, help=self.S_ARG_UNINST_HELP, ) # run the parser args = self._parser.parse_args() # convert namespace to dict self._dict_args = vars(args) # print default about text print(self.S_ABOUT) print(self.S_EPILOG) # ---------------------------------------------------------------------- # check for one-shot args # if -h passed, this will print and exit if self._dict_args.get(self.S_ARG_HLP_DEST, False): # print usage and arg info and exit print() self._parser.print_help() print() sys.exit(0) # no -h, print epilog print() print(self.S_ABOUT_HELP) print() # ---------------------------------------------------------------------- # set props from args # set self and lib debug self._cmd_debug = self._dict_args.get( self.S_ARG_DBG_DEST, self._cmd_debug ) F.B_DEBUG = self._cmd_debug C.B_DEBUG = self._cmd_debug # punt to uninstall func if self._dict_args.get(self.S_ARG_UNINST_DEST, False): # uninstall and exit self._do_uninstall() # maybe yell if self._cmd_debug: # yup, yell F.printc(C.S_MSG_DEBUG, bg=F.C_BG_RED, fg=F.C_FG_WHITE, bold=True) print() # ------------------------------------------------------------------------------ # Boilerplate to use at the start of main # ------------------------------------------------------------------------------ def _teardown(self): \"\"\" Boilerplate to use at the end of main Perform some mundane stuff like saving properties. \"\"\" # ---------------------------------------------------------------------- # save private try: # save private settings path_prv = self._dir_prj / C.S_PRJ_PRV_CFG F.save_dict_into_paths(self._dict_prv, [path_prv]) except OSError as e: # from save_dict F.printd(self.S_ERR_ERR, str(e)) # ---------------------------------------------------------------------- # save public try: # save public settings path_pub = self._dir_prj / C.S_PRJ_PUB_CFG F.save_dict_into_paths(self._dict_pub, [path_pub]) except OSError as e: # from save_dict F.printd(self.S_ERR_ERR, str(e)) # -------------------------------------------------------------------------- # Handle the --uninstall cmd line op # -------------------------------------------------------------------------- def _do_uninstall(self): \"\"\" Handle the --uninstall cmd line op \"\"\" # ask to uninstall str_ask = F.dialog( self.S_ASK_UNINST.format(\"PyPlate\"), [F.S_ASK_YES, F.S_ASK_NO], default=F.S_ASK_NO, ) # user hit enter or typed \"n/N\" if str_ask != F.S_ASK_YES: print(self.S_MSG_ABORT) sys.exit(0) # ------------------------------------------------------------------------------ # if path exists path_uninst = P_UNINST if not path_uninst.exists(): path_uninst = P_UNINST_DIST # format cmd line cmd = str(path_uninst) + \" -f -q\" if self._cmd_debug: cmd += \" -d\" # ------------------------------------------------------------------------------ try: cp = F.run(cmd, shell=True) print(cp.stdout) print(cp.stderr) sys.exit(0) except F.CNRunError as e: print(e.output) sys.exit(e.returncode) # -------------------------------------------------------------------------- # Do any work before fix # -------------------------------------------------------------------------- def _do_before_fix(self): \"\"\" Do any work before fix Do any work before fix. This method is called just before _do_fix, after all dunders have been configured, but before any files have been modified.\\n It is mostly used to make final adjustments to the 'dict_prv' and 'dict_pub' dicts before any replacement occurs. \"\"\" C.do_before_fix( self._dir_prj, self._dict_prv, self._dict_pub, self._dict_dbg, ) # -------------------------------------------------------------------------- # Scan dirs/files in the project for replacing text # -------------------------------------------------------------------------- def _do_fix(self): \"\"\" Scan dirs/files in the project for replacing text Scans for dirs/files under the project's location. For each dir/file it encounters, it passes the path to a filter to determine if the file needs fixing based on its appearance in the blacklist. \"\"\" # print info print(C.S_ACTION_FIX, end=\"\", flush=True) # last chance to do shit w/ dicts self._fix_dicts() # ---------------------------------------------------------------------- # fix up blacklist and convert relative or glob paths to absolute Path # objects # get a read-only copy of the blacklist dict_bl = dict(self._dict_pub_bl) # for each section of blacklist for key, val in dict_bl.items(): # convert all items in list to Path objects list_res = [] for item in val: res = list(self._dir_prj.glob(item)) list_res.extend(res) dict_bl[key] = list_res # just shorten the names skip_all = dict_bl[C.S_KEY_SKIP_ALL] skip_contents = dict_bl[C.S_KEY_SKIP_CONTENTS] skip_header = dict_bl[C.S_KEY_SKIP_HEADER] skip_code = dict_bl[C.S_KEY_SKIP_CODE] # ---------------------------------------------------------------------- # do the fixes # NB: root is a full path, dirs and files are relative to root for root, root_dirs, root_files in self._dir_prj.walk(): # handle dirs in skip_all if root in skip_all: # NB: don't recurse into subfolders root_dirs.clear() continue # convert files into Paths files = [root / f for f in root_files] # for each file item for item in files: # for each new file, reset block and line switches to def # NB: line switches always default to current block switches self._dict_sw_block = dict(C.D_SWITCH_DEF) self._dict_sw_line = dict(self._dict_sw_block) # handle files in skip_all if item in skip_all: continue # handle dirs/files in skip_contents if not root in skip_contents and not item in skip_contents: # handle dirs/files in skip_header bl_hdr = root in skip_header or item in skip_header # handle dirs/files in skip_code bl_code = root in skip_code or item in skip_code # fix content with appropriate dict self._fix_contents(item, bl_hdr, bl_code) # handle file paths with dunders self._fix_path(item) # handle dirs with dunders self._fix_path(root) # done F.printc(C.S_ACTION_DONE, fg=F.C_FG_GREEN, bold=True) # -------------------------------------------------------------------------- # Do any work after fix # -------------------------------------------------------------------------- def _do_after_fix(self): \"\"\" Do any work after fix Do any work after fix. This method is called just after _do_after_fix, after all files have been modified.\\n It is mostly used to tweak files once all the normal fixes have been applied. \"\"\" C.do_after_fix( self._dir_prj, self._dict_prv, self._dict_pub, self._dict_dbg, ) # -------------------------------------------------------------------------- # These are minor steps called from the main steps # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Fix header or code for each line in a file # -------------------------------------------------------------------------- def _fix_contents(self, path, bl_hdr=False, bl_code=False): \"\"\" Fix header or code for each line in a file Args: path: Path for replacing text bl_hdr: Whether the file is blacklisted for header lines (default: False) bl_code: Whether the file is blacklisted for code lines (default: False) For the given file, loop through each line, checking to see if it is a header line or a code line. Ignore blank lines and comment-only lines. \"\"\" # check for unknown file types self._dict_type_rules = get_type_rules(path) if not self._dict_type_rules or len(self._dict_type_rules) == 0: # do the basic replace (file got here after skip_all/skip_contents # BUT NOT skip_hdr/skip_code) self._fix_text(path) return # default lines lines = [] # open and read file with open(path, \"r\", encoding=C.S_ENCODING) as a_file: lines = a_file.readlines() # for each line in array for index, line in enumerate(lines): # ------------------------------------------------------------------ # skip blank lines if line.strip() == \"\": continue # ------------------------------------------------------------------ # split the line into code and comm # we will split the line into two parts # NB: assume code is whole line (i.e. no trailing comment) split_pos = 0 code = line comm = \"\" # find split sequence split_sch = self._dict_type_rules.get(C.S_KEY_SPLIT, None) split_grp = self._dict_type_rules.get(C.S_KEY_SPLIT_COMM, None) # only process files with split if split_sch and split_grp: # there may be multiple matches per line (ignore quoted markers) matches = re.finditer(split_sch, line) # only use matches that have the right group matches = [ match for match in matches if match.group(split_grp) ] for match in matches: # split the line into code and comment (include delimiter) split_pos = match.start(split_grp) code = line[:split_pos] comm = line[split_pos:] # ------------------------------------------------------------------ # check for switches # reset line switch values to block switch values self._dict_sw_line = dict(self._dict_sw_block) # check switches check_switches( code, comm, self._dict_type_rules, self._dict_sw_block, self._dict_sw_line, ) # check for block or line replace switch repl = False if ( self._dict_sw_block[C.S_SW_REPLACE] is True and self._dict_sw_line[C.S_SW_REPLACE] is True ) or self._dict_sw_line[C.S_SW_REPLACE] is True: repl = True # switch says no, gtfo if not repl: continue # ------------------------------------------------------------------ # check for header # check if blacklisted for headers if not bl_hdr: # check if it matches header pattern str_pattern = self._dict_type_rules[C.S_KEY_HDR_SCH] res = re.search(str_pattern, line) if res: # fix it lines[index] = self._fix_header(line) # no more processing for header line continue # ------------------------------------------------------------------ # not a blank, header or switch, must be code # check if blacklisted for code if not bl_code: # fix dunders in real code lines code = self._fix_code(code) # -------------------------------------------------------------- # put the line back together lines[index] = code + comm # open and write file with open(path, \"w\", encoding=C.S_ENCODING) as a_file: a_file.writelines(lines) # -------------------------------------------------------------------------- # Replace dunders inside a file header # -------------------------------------------------------------------------- def _fix_header(self, line): \"\"\" Replace dunders inside a file header Args: line: The header line of the file in which to replace text Returns: The new header line Replaces text inside a header line, using a regex to match specific lines. Given a line, it replaces the found pattern with the replacement as it goes. \"\"\" # break apart header line # NB: gotta do this again, can't pass res param str_pattern = self._dict_type_rules[C.S_KEY_HDR_SCH] res = re.search(str_pattern, line) if not res: return line # pull out lead, val, and pad using group match values from M lead = res.group(self._dict_type_rules[C.S_KEY_LEAD]) val = res.group(self._dict_type_rules[C.S_KEY_VAL]) pad = res.group(self._dict_type_rules[C.S_KEY_PAD]) # this is a complicated function to get the length of the spaces # between the key/val pair and the RAT (right-aligned text) tmp_val = str(val) old_val_len = len(tmp_val) for key2, val2 in self._dict_rep.items(): if isinstance(val2, str): tmp_val = tmp_val.replace(key2, val2) new_val_len = len(tmp_val) val_diff = new_val_len - old_val_len # get new padding value based in diff key/val length tmp_pad = str(pad) tmp_rat = tmp_pad.lstrip() len_pad = len(tmp_pad) - len(tmp_rat) - val_diff pad = \" \" * len_pad # put the header line back together, adjusting for the pad len line = lead + tmp_val + pad + tmp_rat + \"\\n\" # return return line # -------------------------------------------------------------------------- # Replace dunders inside a file's contents # -------------------------------------------------------------------------- def _fix_code(self, code): \"\"\" Replace dunders inside a file's contents Args: code: The code portion of the line to replace text in Returns: The new line of code Replaces text inside the code portion of a line. Given a line, replaces dunders as it goes. When it is done, it returns the new line. This replaces the __PP dunders inside the file, excluding blank lines, headers, and flag switches (all of which are previously handled in _fix_contents). \"\"\" # replace content using current flag setting for key, val in self._dict_rep.items(): if isinstance(val, str): code = code.replace(key, val) # return the (maybe replaced) line return code # -------------------------------------------------------------------------- # Replace dunders inside a file's contents # -------------------------------------------------------------------------- def _fix_text(self, path): \"\"\" Replace dunders inside a file's contents Args: path: The path to the file to fix text Returns: The new line of code Replaces text inside a file. This is a qnd function to replace any dunder in any file, regardless of D_TYPE_RULES. Think of it as an oubliette for files you just want to 'undunderize'. \"\"\" # default lines lines = [] # open and read file with open(path, \"r\", encoding=C.S_ENCODING) as a_file: lines = a_file.readlines() # for each line in array for index, line in enumerate(lines): # ------------------------------------------------------------------ # skip blank lines if line.strip() == \"\": continue # replace content using current flag setting for key, val in self._dict_rep.items(): if isinstance(val, str): line = line.replace(key, val) # put new line back in file lines[index] = line # open and write file with open(path, \"w\", encoding=C.S_ENCODING) as a_file: a_file.writelines(lines) # -------------------------------------------------------------------------- # Rename dirs/files in the project # -------------------------------------------------------------------------- def _fix_path(self, path): \"\"\" Rename dirs/files in the project Args: path: Path for dir/file to be renamed Rename dirs/files. Given a path, it renames the dir/file by replacing dunders in the path with their appropriate replacements from self._dict_rep. \"\"\" # sanity check path = Path(path) # first get the path name (we only want to change the last component) last_part = path.name # # replace dunders in last path component for key, val in self._dict_rep.items(): if isinstance(val, str): last_part = last_part.replace(key, val) # replace the name path_new = path.parent / last_part # if it hasn't changed, skip to avoid overhead if path_new == path: return # do rename path.rename(path_new) # -------------------------------------------------------------------------- # Make reps, save public, fix public dunders, reload sub dicts # -------------------------------------------------------------------------- def _fix_dicts(self): \"\"\" Make reps, save/fix public dunders, reload sub dicts Make reps, save/fix public dunders, reload sub dicts \"\"\" # ---------------------------------------------------------------------- # get prv subs self._dict_prv_all = self._dict_prv[C.S_KEY_PRV_ALL] self._dict_prv_prj = self._dict_prv[C.S_KEY_PRV_PRJ] # ---------------------------------------------------------------------- # get prv subs self._dict_rep = self._dict_prv_all | self._dict_prv_prj # ---------------------------------------------------------------------- # save/fix/load public try: # save public settings path_pub = self._dir_prj / C.S_PRJ_PUB_CFG F.save_dict_into_paths(self._dict_pub, [path_pub]) except OSError as e: # from save_dict F.printd(self.S_ERR_ERR, str(e)) # fix dunders in dict_pub self._fix_contents(path_pub) try: # load public settings path_pub = self._dir_prj / C.S_PRJ_PUB_CFG self._dict_pub = F.load_paths_into_dict([path_pub]) except OSError as e: # from load dict F.printd(self.S_ERR_ERR, str(e)) # ---------------------------------------------------------------------- # get pub subs self._dict_pub_bl = self._dict_pub[C.S_KEY_PUB_BL] self._dict_pub_dbg = self._dict_pub[C.S_KEY_PUB_DBG] self._dict_pub_dist = self._dict_pub[C.S_KEY_PUB_DIST] self._dict_pub_docs = self._dict_pub[C.S_KEY_PUB_DOCS] self._dict_pub_i18n = self._dict_pub[C.S_KEY_PUB_I18N] self._dict_pub_meta = self._dict_pub[C.S_KEY_PUB_META] self._dict_pub_inst = self._dict_pub[C.S_KEY_PUB_INST] # self._dict_pub_uninst = self._dict_pub[C.S_KEY_PUB_UNINST] # set initial debug self._dict_dbg = dict(self._dict_pub_dbg) # -------------------------------------------------------------------------- # Check project type for allowed characters # -------------------------------------------------------------------------- def _check_type(self, prj_type): \"\"\" Check project type for allowed characters Args: prj_type: Type to check for allowed characters Returns: Whether the type is valid to use Checks the passed type to see if it is one of the allowed project types. \"\"\" # sanity check if len(prj_type) == 1: # get first char and lower case it first_char = prj_type[0].lower() # check if it's one of ours first_char_test = [item[0].lower() for item in C.L_TYPES] if first_char in first_char_test: return True # nope, fail types = [] s = \"\" for item in C.L_TYPES: types.append(item[0]) s = \", \".join(types) print(C.S_ERR_TYPE.format(s)) return False # -------------------------------------------------------------------------- # Check project name for allowed characters # -------------------------------------------------------------------------- def _check_name(self, name_prj): \"\"\" Check project name for allowed characters Args: name_prj: Name to check for allowed characters Returns: Whether the name is valid to use Checks the passed name for these criteria: 1. longer than 1 char 2. starts with an alpha char 3. ends with an alphanumeric char 4. contains only alphanumeric chars and/or dash(-) or underscore(_) \"\"\" # NB: there is an easier way to do this with regex: # ^([a-zA-Z]+[a-zA-Z\\d\\-_ ]*[a-zA-Z\\d]+)$ AND OMG DID IT TAKE A LONG # TIME TO FIND IT! in case you were looking for it. It will give you a # quick yes-no answer. I don't use it here because I want to give the # user as much feedback as possible, so I break down the regex into # steps where each step explains which part of the name is wrong. # check for name length if len(name_prj.strip(\" \")) < 2: print(C.S_ERR_LEN) return False # match start or return false pattern = C.D_NAME[C.S_KEY_NAME_START] res = re.search(pattern, name_prj) if not res: print(C.S_ERR_START) return False # match end or return false pattern = C.D_NAME[C.S_KEY_NAME_END] res = re.search(pattern, name_prj) if not res: print(C.S_ERR_END) return False # match middle or return false pattern = C.D_NAME[C.S_KEY_NAME_MID] res = re.search(pattern, name_prj) if not res: print(C.S_ERR_MID) return False # if we made it this far, return true return True # -------------------------------------------------------------------------- # Combine reqs from template/all and template/prj_type # -------------------------------------------------------------------------- def _merge_reqs(self, prj_type_long): \"\"\" Combine reqs from template/all and template/prj_type Args: prj_type_long: the folder in template for the current project type This method combines reqs from the all dir used by all projects, and those used by specific project type (gui needs pygobject, etc). \"\"\" # get sources and filter out sources that don't exist reqs_prj = P_DIR_PRJ / C.S_FILE_REQS_TYPE.format(prj_type_long) # get src src = [ P_DIR_PRJ / C.S_FILE_REQS_ALL, P_DIR_PRJ / reqs_prj, ] src = [str(item) for item in src if item.exists()] # get dst to put file lines dst = self._dir_prj / C.S_FILE_REQS # ---------------------------------------------------------------------- # the new set of lines for requirements.txt new_file = [] # read reqs files and put in result for item in src: with open(item, \"r\", encoding=C.S_ENCODING) as a_file: old_file = a_file.readlines() old_file = [line.rstrip() for line in old_file] uniq = set(new_file + old_file) new_file = list(uniq) # put combined reqs into final file joint = \"\\n\".join(new_file) with open(dst, \"w\", encoding=C.S_ENCODING) as a_file: a_file.writelines(joint) __init__() Initialize the new object Initializes a new instance of the class, setting the default values of its properties, and any other code that needs to run to create a new object. Source code in src/pyplate.py def __init__(self): \"\"\" Initialize the new object Initializes a new instance of the class, setting the default values of its properties, and any other code that needs to run to create a new object. \"\"\" # set the initial values of properties # internal props self._dir_prj = Path() self._dict_rep = {} self._dict_type_rules = {} self._dict_sw_block = {} self._dict_sw_line = {} # private.json dicts self._dict_prv = {} self._dict_prv_all = {} self._dict_prv_prj = {} # project.json dicts self._dict_pub = {} self._dict_pub_bl = {} self._dict_pub_dbg = {} self._dict_pub_dist = {} self._dict_pub_docs = {} self._dict_pub_i18n = {} self._dict_pub_meta = {} self._dict_pub_inst = {} # self._dict_pub_uninst = {} # dictionary to hold current pm/pb debug settings self._dict_dbg = {} # log stuff self._logger = logging.getLogger(__name__) logging.basicConfig( filename=P_LOG_DEF, level=logging.INFO, format=self.S_LOG_FMT, datefmt=self.S_LOG_DATE_FMT, ) # cmd line stuff self._parser = argparse.ArgumentParser( formatter_class=CNFormatter, add_help=False ) # set arg defaults self._dict_args = {} self._cmd_debug = False # ---------------------------------------------------------------------- # set self._dir_prj # assume we are running in the project dir # this is used in a lot of places, so just shorthand it self._dir_prj = Path.cwd() # ---------------------------------------------------------------------- # set switch dicts to defaults self._dict_sw_block = dict(C.D_SWITCH_DEF) self._dict_sw_line = dict(C.D_SWITCH_DEF) check_switches(code, comm, dict_type_rules, dict_sw_block, dict_sw_line) Check if line or trailing comment is a switch Parameters: Name Type Description Default comm The comment part of a line to check for switches required dict_type_rules Dictionary containing the regex to look for required dict_sw Dictionary of switch values for either block or line required This method checks to see if a line or trailing comment contains a valid switch for the values in dict_type_rules. If a valid switch is found, it sets the appropriate flag in either dict_sw_block or dict_sw_line. Source code in src/pyplate.py def check_switches(code, comm, dict_type_rules, dict_sw_block, dict_sw_line): \"\"\" Check if line or trailing comment is a switch Args: comm: The comment part of a line to check for switches dict_type_rules: Dictionary containing the regex to look for dict_sw: Dictionary of switch values for either block or line switches This method checks to see if a line or trailing comment contains a valid switch for the values in dict_type_rules. If a valid switch is found, it sets the appropriate flag in either dict_sw_block or dict_sw_line. \"\"\" # switch does not appear anywhere in line res = re.search(dict_type_rules[C.S_KEY_SW_SCH], comm) if not res: return # find all matches (case insensitive) matches = re.finditer(dict_type_rules[C.S_KEY_SW_SCH], comm, flags=re.I) # for each match for match in matches: # get key/val of switch key = match.group(dict_type_rules[C.S_KEY_SW_KEY]) val = match.group(dict_type_rules[C.S_KEY_SW_VAL]) # try a bool conversion # NB: in honor of John Valby (ddg him!) val_b = val.lower() if val_b == \"true\": val = True elif val_b == \"false\": val = False # pick a dict based on if there is preceding code if code.strip() == \"\": dict_sw_block[key] = val else: dict_sw_line[key] = val get_type_rules(path) Get the filetype-specific regexes (headers, comments. switches) Parameters: Name Type Description Default path Path of the file to get the dict of regexes for required Returns: Type Description The dict of regexes for this file type Source code in src/pyplate.py def get_type_rules(path): \"\"\" Get the filetype-specific regexes (headers, comments. switches) Args: path: Path of the file to get the dict of regexes for Returns: The dict of regexes for this file type \"\"\" # iterate over reps for _key, val in C.D_TYPE_RULES.items(): # fix ets if necessary exts = val[C.S_KEY_RULES_EXT] # lower case all exts l_exts = [item.lower() for item in exts] # add dots l_exts = [ f\".{item}\" if not item.startswith(\".\") else item for item in l_exts ] # check if the suffix or the filename (for dot files) matches # NB: also checks for dot files if path.suffix.lower() in l_exts or path.name.lower() in l_exts: return val[C.S_KEY_RULES_REP] # default result is py rep return {}","title":"pyplate.py"},{"location":"API/src/pyplate/#pyplatepy","text":"A class to be the base for pymaker/pybaker This is the base class that contains code common to both PyMaker and PyBaker.","title":"pyplate.py"},{"location":"API/src/pyplate/#src.pyplate.PyPlate","text":"The main class, responsible for the operation of the program Public methods main: The main method of the program This class implements all the needed functionality of PyMaker, to create a PyPlate project from a template. Source code in src/pyplate.py class PyPlate: \"\"\" The main class, responsible for the operation of the program Public methods: main: The main method of the program This class implements all the needed functionality of PyMaker, to create a PyPlate project from a template. \"\"\" # -------------------------------------------------------------------------- # Class constants # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # strings # pyplate: replace=True # short description # pylint: disable=line-too-long # NB: need to keep on one line for replacement S_PP_SHORT_DESC = \"A program for creating and building CLI/GUI/Packages in Python from a template\" # pylint: enable=line-too-long # version string S_PP_VERSION = \"Version 1.1.1\" # pyplate: replace=False # debug option strings S_ARG_DBG_OPTION = \"-d\" S_ARG_DBG_ACTION = \"store_true\" S_ARG_DBG_DEST = \"DBG_DEST\" # I18N: debug mode help S_ARG_DBG_HELP = _(\"enable debugging mode\") # config option strings S_ARG_HLP_OPTION = \"-h\" S_ARG_HLP_ACTION = \"store_true\" S_ARG_HLP_DEST = \"HLP_DEST\" # I18N: help option help S_ARG_HLP_HELP = _(\"show this help message and exit\") # config option strings S_ARG_UNINST_OPTION = \"--uninstall\" S_ARG_UNINST_ACTION = \"store_true\" S_ARG_UNINST_DEST = \"UNINST_DEST\" # I18N: uninstall option help S_ARG_UNINST_HELP = _(\"uninstall this program\") # about string (to be set by subclass) S_ABOUT = \"\" # I18N if using argparse, add help at end of about S_ABOUT_HELP = _(\"Use -h for help\") + \"\\n\" # cmd line instructions string (to be set by subclass) S_EPILOG = \"\" # default format af log files S_LOG_FMT = \"%(asctime)s [%(levelname)-7s] %(message)s\" S_LOG_DATE_FMT = \"%Y-%m-%d %I:%M:%S %p\" # -------------------------------------------------------------------------- # questions # I18N: answer yes # S_ASK_YES = _(\"y\") # # I18N: answer no # S_ASK_NO = _(\"N\") # NB: format param is prog name # I18N: ask to uninstall S_ASK_UNINST = _(\"This will uninstall {}.\\nDo you want to continue?\") # -------------------------------------------------------------------------- # messages # I18N: process aborted S_MSG_ABORT = _(\"Aborted\") # -------------------------------------------------------------------------- # error messages # I18N: an error occurred S_ERR_ERR = _(\"Error:\") # I18N: uninstall not found S_ERR_NO_UNINST = _(\"Uninstall files not found\") # NB: format param is file path # I18N: could not find -c file S_ERR_NO_CFG = _(\"Config file {} not found\") # -------------------------------------------------------------------------- # Instance methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Initialize the new object # -------------------------------------------------------------------------- def __init__(self): \"\"\" Initialize the new object Initializes a new instance of the class, setting the default values of its properties, and any other code that needs to run to create a new object. \"\"\" # set the initial values of properties # internal props self._dir_prj = Path() self._dict_rep = {} self._dict_type_rules = {} self._dict_sw_block = {} self._dict_sw_line = {} # private.json dicts self._dict_prv = {} self._dict_prv_all = {} self._dict_prv_prj = {} # project.json dicts self._dict_pub = {} self._dict_pub_bl = {} self._dict_pub_dbg = {} self._dict_pub_dist = {} self._dict_pub_docs = {} self._dict_pub_i18n = {} self._dict_pub_meta = {} self._dict_pub_inst = {} # self._dict_pub_uninst = {} # dictionary to hold current pm/pb debug settings self._dict_dbg = {} # log stuff self._logger = logging.getLogger(__name__) logging.basicConfig( filename=P_LOG_DEF, level=logging.INFO, format=self.S_LOG_FMT, datefmt=self.S_LOG_DATE_FMT, ) # cmd line stuff self._parser = argparse.ArgumentParser( formatter_class=CNFormatter, add_help=False ) # set arg defaults self._dict_args = {} self._cmd_debug = False # ---------------------------------------------------------------------- # set self._dir_prj # assume we are running in the project dir # this is used in a lot of places, so just shorthand it self._dir_prj = Path.cwd() # ---------------------------------------------------------------------- # set switch dicts to defaults self._dict_sw_block = dict(C.D_SWITCH_DEF) self._dict_sw_line = dict(C.D_SWITCH_DEF) # -------------------------------------------------------------------------- # Private methods # -------------------------------------------------------------------------- # NB: these are the main steps, called in order from main() # -------------------------------------------------------------------------- # Boilerplate to use at the start of main # -------------------------------------------------------------------------- def _setup(self): \"\"\" Boilerplate to use at the start of main Perform some mundane stuff like running the arg parser and loading config files. \"\"\" # ---------------------------------------------------------------------- # use cmd line # add debug option self._parser.add_argument( self.S_ARG_DBG_OPTION, dest=self.S_ARG_DBG_DEST, help=self.S_ARG_DBG_HELP, action=self.S_ARG_DBG_ACTION, ) # always add help option self._parser.add_argument( self.S_ARG_HLP_OPTION, action=self.S_ARG_HLP_ACTION, dest=self.S_ARG_HLP_DEST, help=self.S_ARG_HLP_HELP, ) # add uninstall option self._parser.add_argument( self.S_ARG_UNINST_OPTION, action=self.S_ARG_UNINST_ACTION, dest=self.S_ARG_UNINST_DEST, help=self.S_ARG_UNINST_HELP, ) # run the parser args = self._parser.parse_args() # convert namespace to dict self._dict_args = vars(args) # print default about text print(self.S_ABOUT) print(self.S_EPILOG) # ---------------------------------------------------------------------- # check for one-shot args # if -h passed, this will print and exit if self._dict_args.get(self.S_ARG_HLP_DEST, False): # print usage and arg info and exit print() self._parser.print_help() print() sys.exit(0) # no -h, print epilog print() print(self.S_ABOUT_HELP) print() # ---------------------------------------------------------------------- # set props from args # set self and lib debug self._cmd_debug = self._dict_args.get( self.S_ARG_DBG_DEST, self._cmd_debug ) F.B_DEBUG = self._cmd_debug C.B_DEBUG = self._cmd_debug # punt to uninstall func if self._dict_args.get(self.S_ARG_UNINST_DEST, False): # uninstall and exit self._do_uninstall() # maybe yell if self._cmd_debug: # yup, yell F.printc(C.S_MSG_DEBUG, bg=F.C_BG_RED, fg=F.C_FG_WHITE, bold=True) print() # ------------------------------------------------------------------------------ # Boilerplate to use at the start of main # ------------------------------------------------------------------------------ def _teardown(self): \"\"\" Boilerplate to use at the end of main Perform some mundane stuff like saving properties. \"\"\" # ---------------------------------------------------------------------- # save private try: # save private settings path_prv = self._dir_prj / C.S_PRJ_PRV_CFG F.save_dict_into_paths(self._dict_prv, [path_prv]) except OSError as e: # from save_dict F.printd(self.S_ERR_ERR, str(e)) # ---------------------------------------------------------------------- # save public try: # save public settings path_pub = self._dir_prj / C.S_PRJ_PUB_CFG F.save_dict_into_paths(self._dict_pub, [path_pub]) except OSError as e: # from save_dict F.printd(self.S_ERR_ERR, str(e)) # -------------------------------------------------------------------------- # Handle the --uninstall cmd line op # -------------------------------------------------------------------------- def _do_uninstall(self): \"\"\" Handle the --uninstall cmd line op \"\"\" # ask to uninstall str_ask = F.dialog( self.S_ASK_UNINST.format(\"PyPlate\"), [F.S_ASK_YES, F.S_ASK_NO], default=F.S_ASK_NO, ) # user hit enter or typed \"n/N\" if str_ask != F.S_ASK_YES: print(self.S_MSG_ABORT) sys.exit(0) # ------------------------------------------------------------------------------ # if path exists path_uninst = P_UNINST if not path_uninst.exists(): path_uninst = P_UNINST_DIST # format cmd line cmd = str(path_uninst) + \" -f -q\" if self._cmd_debug: cmd += \" -d\" # ------------------------------------------------------------------------------ try: cp = F.run(cmd, shell=True) print(cp.stdout) print(cp.stderr) sys.exit(0) except F.CNRunError as e: print(e.output) sys.exit(e.returncode) # -------------------------------------------------------------------------- # Do any work before fix # -------------------------------------------------------------------------- def _do_before_fix(self): \"\"\" Do any work before fix Do any work before fix. This method is called just before _do_fix, after all dunders have been configured, but before any files have been modified.\\n It is mostly used to make final adjustments to the 'dict_prv' and 'dict_pub' dicts before any replacement occurs. \"\"\" C.do_before_fix( self._dir_prj, self._dict_prv, self._dict_pub, self._dict_dbg, ) # -------------------------------------------------------------------------- # Scan dirs/files in the project for replacing text # -------------------------------------------------------------------------- def _do_fix(self): \"\"\" Scan dirs/files in the project for replacing text Scans for dirs/files under the project's location. For each dir/file it encounters, it passes the path to a filter to determine if the file needs fixing based on its appearance in the blacklist. \"\"\" # print info print(C.S_ACTION_FIX, end=\"\", flush=True) # last chance to do shit w/ dicts self._fix_dicts() # ---------------------------------------------------------------------- # fix up blacklist and convert relative or glob paths to absolute Path # objects # get a read-only copy of the blacklist dict_bl = dict(self._dict_pub_bl) # for each section of blacklist for key, val in dict_bl.items(): # convert all items in list to Path objects list_res = [] for item in val: res = list(self._dir_prj.glob(item)) list_res.extend(res) dict_bl[key] = list_res # just shorten the names skip_all = dict_bl[C.S_KEY_SKIP_ALL] skip_contents = dict_bl[C.S_KEY_SKIP_CONTENTS] skip_header = dict_bl[C.S_KEY_SKIP_HEADER] skip_code = dict_bl[C.S_KEY_SKIP_CODE] # ---------------------------------------------------------------------- # do the fixes # NB: root is a full path, dirs and files are relative to root for root, root_dirs, root_files in self._dir_prj.walk(): # handle dirs in skip_all if root in skip_all: # NB: don't recurse into subfolders root_dirs.clear() continue # convert files into Paths files = [root / f for f in root_files] # for each file item for item in files: # for each new file, reset block and line switches to def # NB: line switches always default to current block switches self._dict_sw_block = dict(C.D_SWITCH_DEF) self._dict_sw_line = dict(self._dict_sw_block) # handle files in skip_all if item in skip_all: continue # handle dirs/files in skip_contents if not root in skip_contents and not item in skip_contents: # handle dirs/files in skip_header bl_hdr = root in skip_header or item in skip_header # handle dirs/files in skip_code bl_code = root in skip_code or item in skip_code # fix content with appropriate dict self._fix_contents(item, bl_hdr, bl_code) # handle file paths with dunders self._fix_path(item) # handle dirs with dunders self._fix_path(root) # done F.printc(C.S_ACTION_DONE, fg=F.C_FG_GREEN, bold=True) # -------------------------------------------------------------------------- # Do any work after fix # -------------------------------------------------------------------------- def _do_after_fix(self): \"\"\" Do any work after fix Do any work after fix. This method is called just after _do_after_fix, after all files have been modified.\\n It is mostly used to tweak files once all the normal fixes have been applied. \"\"\" C.do_after_fix( self._dir_prj, self._dict_prv, self._dict_pub, self._dict_dbg, ) # -------------------------------------------------------------------------- # These are minor steps called from the main steps # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Fix header or code for each line in a file # -------------------------------------------------------------------------- def _fix_contents(self, path, bl_hdr=False, bl_code=False): \"\"\" Fix header or code for each line in a file Args: path: Path for replacing text bl_hdr: Whether the file is blacklisted for header lines (default: False) bl_code: Whether the file is blacklisted for code lines (default: False) For the given file, loop through each line, checking to see if it is a header line or a code line. Ignore blank lines and comment-only lines. \"\"\" # check for unknown file types self._dict_type_rules = get_type_rules(path) if not self._dict_type_rules or len(self._dict_type_rules) == 0: # do the basic replace (file got here after skip_all/skip_contents # BUT NOT skip_hdr/skip_code) self._fix_text(path) return # default lines lines = [] # open and read file with open(path, \"r\", encoding=C.S_ENCODING) as a_file: lines = a_file.readlines() # for each line in array for index, line in enumerate(lines): # ------------------------------------------------------------------ # skip blank lines if line.strip() == \"\": continue # ------------------------------------------------------------------ # split the line into code and comm # we will split the line into two parts # NB: assume code is whole line (i.e. no trailing comment) split_pos = 0 code = line comm = \"\" # find split sequence split_sch = self._dict_type_rules.get(C.S_KEY_SPLIT, None) split_grp = self._dict_type_rules.get(C.S_KEY_SPLIT_COMM, None) # only process files with split if split_sch and split_grp: # there may be multiple matches per line (ignore quoted markers) matches = re.finditer(split_sch, line) # only use matches that have the right group matches = [ match for match in matches if match.group(split_grp) ] for match in matches: # split the line into code and comment (include delimiter) split_pos = match.start(split_grp) code = line[:split_pos] comm = line[split_pos:] # ------------------------------------------------------------------ # check for switches # reset line switch values to block switch values self._dict_sw_line = dict(self._dict_sw_block) # check switches check_switches( code, comm, self._dict_type_rules, self._dict_sw_block, self._dict_sw_line, ) # check for block or line replace switch repl = False if ( self._dict_sw_block[C.S_SW_REPLACE] is True and self._dict_sw_line[C.S_SW_REPLACE] is True ) or self._dict_sw_line[C.S_SW_REPLACE] is True: repl = True # switch says no, gtfo if not repl: continue # ------------------------------------------------------------------ # check for header # check if blacklisted for headers if not bl_hdr: # check if it matches header pattern str_pattern = self._dict_type_rules[C.S_KEY_HDR_SCH] res = re.search(str_pattern, line) if res: # fix it lines[index] = self._fix_header(line) # no more processing for header line continue # ------------------------------------------------------------------ # not a blank, header or switch, must be code # check if blacklisted for code if not bl_code: # fix dunders in real code lines code = self._fix_code(code) # -------------------------------------------------------------- # put the line back together lines[index] = code + comm # open and write file with open(path, \"w\", encoding=C.S_ENCODING) as a_file: a_file.writelines(lines) # -------------------------------------------------------------------------- # Replace dunders inside a file header # -------------------------------------------------------------------------- def _fix_header(self, line): \"\"\" Replace dunders inside a file header Args: line: The header line of the file in which to replace text Returns: The new header line Replaces text inside a header line, using a regex to match specific lines. Given a line, it replaces the found pattern with the replacement as it goes. \"\"\" # break apart header line # NB: gotta do this again, can't pass res param str_pattern = self._dict_type_rules[C.S_KEY_HDR_SCH] res = re.search(str_pattern, line) if not res: return line # pull out lead, val, and pad using group match values from M lead = res.group(self._dict_type_rules[C.S_KEY_LEAD]) val = res.group(self._dict_type_rules[C.S_KEY_VAL]) pad = res.group(self._dict_type_rules[C.S_KEY_PAD]) # this is a complicated function to get the length of the spaces # between the key/val pair and the RAT (right-aligned text) tmp_val = str(val) old_val_len = len(tmp_val) for key2, val2 in self._dict_rep.items(): if isinstance(val2, str): tmp_val = tmp_val.replace(key2, val2) new_val_len = len(tmp_val) val_diff = new_val_len - old_val_len # get new padding value based in diff key/val length tmp_pad = str(pad) tmp_rat = tmp_pad.lstrip() len_pad = len(tmp_pad) - len(tmp_rat) - val_diff pad = \" \" * len_pad # put the header line back together, adjusting for the pad len line = lead + tmp_val + pad + tmp_rat + \"\\n\" # return return line # -------------------------------------------------------------------------- # Replace dunders inside a file's contents # -------------------------------------------------------------------------- def _fix_code(self, code): \"\"\" Replace dunders inside a file's contents Args: code: The code portion of the line to replace text in Returns: The new line of code Replaces text inside the code portion of a line. Given a line, replaces dunders as it goes. When it is done, it returns the new line. This replaces the __PP dunders inside the file, excluding blank lines, headers, and flag switches (all of which are previously handled in _fix_contents). \"\"\" # replace content using current flag setting for key, val in self._dict_rep.items(): if isinstance(val, str): code = code.replace(key, val) # return the (maybe replaced) line return code # -------------------------------------------------------------------------- # Replace dunders inside a file's contents # -------------------------------------------------------------------------- def _fix_text(self, path): \"\"\" Replace dunders inside a file's contents Args: path: The path to the file to fix text Returns: The new line of code Replaces text inside a file. This is a qnd function to replace any dunder in any file, regardless of D_TYPE_RULES. Think of it as an oubliette for files you just want to 'undunderize'. \"\"\" # default lines lines = [] # open and read file with open(path, \"r\", encoding=C.S_ENCODING) as a_file: lines = a_file.readlines() # for each line in array for index, line in enumerate(lines): # ------------------------------------------------------------------ # skip blank lines if line.strip() == \"\": continue # replace content using current flag setting for key, val in self._dict_rep.items(): if isinstance(val, str): line = line.replace(key, val) # put new line back in file lines[index] = line # open and write file with open(path, \"w\", encoding=C.S_ENCODING) as a_file: a_file.writelines(lines) # -------------------------------------------------------------------------- # Rename dirs/files in the project # -------------------------------------------------------------------------- def _fix_path(self, path): \"\"\" Rename dirs/files in the project Args: path: Path for dir/file to be renamed Rename dirs/files. Given a path, it renames the dir/file by replacing dunders in the path with their appropriate replacements from self._dict_rep. \"\"\" # sanity check path = Path(path) # first get the path name (we only want to change the last component) last_part = path.name # # replace dunders in last path component for key, val in self._dict_rep.items(): if isinstance(val, str): last_part = last_part.replace(key, val) # replace the name path_new = path.parent / last_part # if it hasn't changed, skip to avoid overhead if path_new == path: return # do rename path.rename(path_new) # -------------------------------------------------------------------------- # Make reps, save public, fix public dunders, reload sub dicts # -------------------------------------------------------------------------- def _fix_dicts(self): \"\"\" Make reps, save/fix public dunders, reload sub dicts Make reps, save/fix public dunders, reload sub dicts \"\"\" # ---------------------------------------------------------------------- # get prv subs self._dict_prv_all = self._dict_prv[C.S_KEY_PRV_ALL] self._dict_prv_prj = self._dict_prv[C.S_KEY_PRV_PRJ] # ---------------------------------------------------------------------- # get prv subs self._dict_rep = self._dict_prv_all | self._dict_prv_prj # ---------------------------------------------------------------------- # save/fix/load public try: # save public settings path_pub = self._dir_prj / C.S_PRJ_PUB_CFG F.save_dict_into_paths(self._dict_pub, [path_pub]) except OSError as e: # from save_dict F.printd(self.S_ERR_ERR, str(e)) # fix dunders in dict_pub self._fix_contents(path_pub) try: # load public settings path_pub = self._dir_prj / C.S_PRJ_PUB_CFG self._dict_pub = F.load_paths_into_dict([path_pub]) except OSError as e: # from load dict F.printd(self.S_ERR_ERR, str(e)) # ---------------------------------------------------------------------- # get pub subs self._dict_pub_bl = self._dict_pub[C.S_KEY_PUB_BL] self._dict_pub_dbg = self._dict_pub[C.S_KEY_PUB_DBG] self._dict_pub_dist = self._dict_pub[C.S_KEY_PUB_DIST] self._dict_pub_docs = self._dict_pub[C.S_KEY_PUB_DOCS] self._dict_pub_i18n = self._dict_pub[C.S_KEY_PUB_I18N] self._dict_pub_meta = self._dict_pub[C.S_KEY_PUB_META] self._dict_pub_inst = self._dict_pub[C.S_KEY_PUB_INST] # self._dict_pub_uninst = self._dict_pub[C.S_KEY_PUB_UNINST] # set initial debug self._dict_dbg = dict(self._dict_pub_dbg) # -------------------------------------------------------------------------- # Check project type for allowed characters # -------------------------------------------------------------------------- def _check_type(self, prj_type): \"\"\" Check project type for allowed characters Args: prj_type: Type to check for allowed characters Returns: Whether the type is valid to use Checks the passed type to see if it is one of the allowed project types. \"\"\" # sanity check if len(prj_type) == 1: # get first char and lower case it first_char = prj_type[0].lower() # check if it's one of ours first_char_test = [item[0].lower() for item in C.L_TYPES] if first_char in first_char_test: return True # nope, fail types = [] s = \"\" for item in C.L_TYPES: types.append(item[0]) s = \", \".join(types) print(C.S_ERR_TYPE.format(s)) return False # -------------------------------------------------------------------------- # Check project name for allowed characters # -------------------------------------------------------------------------- def _check_name(self, name_prj): \"\"\" Check project name for allowed characters Args: name_prj: Name to check for allowed characters Returns: Whether the name is valid to use Checks the passed name for these criteria: 1. longer than 1 char 2. starts with an alpha char 3. ends with an alphanumeric char 4. contains only alphanumeric chars and/or dash(-) or underscore(_) \"\"\" # NB: there is an easier way to do this with regex: # ^([a-zA-Z]+[a-zA-Z\\d\\-_ ]*[a-zA-Z\\d]+)$ AND OMG DID IT TAKE A LONG # TIME TO FIND IT! in case you were looking for it. It will give you a # quick yes-no answer. I don't use it here because I want to give the # user as much feedback as possible, so I break down the regex into # steps where each step explains which part of the name is wrong. # check for name length if len(name_prj.strip(\" \")) < 2: print(C.S_ERR_LEN) return False # match start or return false pattern = C.D_NAME[C.S_KEY_NAME_START] res = re.search(pattern, name_prj) if not res: print(C.S_ERR_START) return False # match end or return false pattern = C.D_NAME[C.S_KEY_NAME_END] res = re.search(pattern, name_prj) if not res: print(C.S_ERR_END) return False # match middle or return false pattern = C.D_NAME[C.S_KEY_NAME_MID] res = re.search(pattern, name_prj) if not res: print(C.S_ERR_MID) return False # if we made it this far, return true return True # -------------------------------------------------------------------------- # Combine reqs from template/all and template/prj_type # -------------------------------------------------------------------------- def _merge_reqs(self, prj_type_long): \"\"\" Combine reqs from template/all and template/prj_type Args: prj_type_long: the folder in template for the current project type This method combines reqs from the all dir used by all projects, and those used by specific project type (gui needs pygobject, etc). \"\"\" # get sources and filter out sources that don't exist reqs_prj = P_DIR_PRJ / C.S_FILE_REQS_TYPE.format(prj_type_long) # get src src = [ P_DIR_PRJ / C.S_FILE_REQS_ALL, P_DIR_PRJ / reqs_prj, ] src = [str(item) for item in src if item.exists()] # get dst to put file lines dst = self._dir_prj / C.S_FILE_REQS # ---------------------------------------------------------------------- # the new set of lines for requirements.txt new_file = [] # read reqs files and put in result for item in src: with open(item, \"r\", encoding=C.S_ENCODING) as a_file: old_file = a_file.readlines() old_file = [line.rstrip() for line in old_file] uniq = set(new_file + old_file) new_file = list(uniq) # put combined reqs into final file joint = \"\\n\".join(new_file) with open(dst, \"w\", encoding=C.S_ENCODING) as a_file: a_file.writelines(joint)","title":"PyPlate"},{"location":"API/src/pyplate/#src.pyplate.PyPlate.__init__","text":"Initialize the new object Initializes a new instance of the class, setting the default values of its properties, and any other code that needs to run to create a new object. Source code in src/pyplate.py def __init__(self): \"\"\" Initialize the new object Initializes a new instance of the class, setting the default values of its properties, and any other code that needs to run to create a new object. \"\"\" # set the initial values of properties # internal props self._dir_prj = Path() self._dict_rep = {} self._dict_type_rules = {} self._dict_sw_block = {} self._dict_sw_line = {} # private.json dicts self._dict_prv = {} self._dict_prv_all = {} self._dict_prv_prj = {} # project.json dicts self._dict_pub = {} self._dict_pub_bl = {} self._dict_pub_dbg = {} self._dict_pub_dist = {} self._dict_pub_docs = {} self._dict_pub_i18n = {} self._dict_pub_meta = {} self._dict_pub_inst = {} # self._dict_pub_uninst = {} # dictionary to hold current pm/pb debug settings self._dict_dbg = {} # log stuff self._logger = logging.getLogger(__name__) logging.basicConfig( filename=P_LOG_DEF, level=logging.INFO, format=self.S_LOG_FMT, datefmt=self.S_LOG_DATE_FMT, ) # cmd line stuff self._parser = argparse.ArgumentParser( formatter_class=CNFormatter, add_help=False ) # set arg defaults self._dict_args = {} self._cmd_debug = False # ---------------------------------------------------------------------- # set self._dir_prj # assume we are running in the project dir # this is used in a lot of places, so just shorthand it self._dir_prj = Path.cwd() # ---------------------------------------------------------------------- # set switch dicts to defaults self._dict_sw_block = dict(C.D_SWITCH_DEF) self._dict_sw_line = dict(C.D_SWITCH_DEF)","title":"__init__"},{"location":"API/src/pyplate/#src.pyplate.check_switches","text":"Check if line or trailing comment is a switch Parameters: Name Type Description Default comm The comment part of a line to check for switches required dict_type_rules Dictionary containing the regex to look for required dict_sw Dictionary of switch values for either block or line required This method checks to see if a line or trailing comment contains a valid switch for the values in dict_type_rules. If a valid switch is found, it sets the appropriate flag in either dict_sw_block or dict_sw_line. Source code in src/pyplate.py def check_switches(code, comm, dict_type_rules, dict_sw_block, dict_sw_line): \"\"\" Check if line or trailing comment is a switch Args: comm: The comment part of a line to check for switches dict_type_rules: Dictionary containing the regex to look for dict_sw: Dictionary of switch values for either block or line switches This method checks to see if a line or trailing comment contains a valid switch for the values in dict_type_rules. If a valid switch is found, it sets the appropriate flag in either dict_sw_block or dict_sw_line. \"\"\" # switch does not appear anywhere in line res = re.search(dict_type_rules[C.S_KEY_SW_SCH], comm) if not res: return # find all matches (case insensitive) matches = re.finditer(dict_type_rules[C.S_KEY_SW_SCH], comm, flags=re.I) # for each match for match in matches: # get key/val of switch key = match.group(dict_type_rules[C.S_KEY_SW_KEY]) val = match.group(dict_type_rules[C.S_KEY_SW_VAL]) # try a bool conversion # NB: in honor of John Valby (ddg him!) val_b = val.lower() if val_b == \"true\": val = True elif val_b == \"false\": val = False # pick a dict based on if there is preceding code if code.strip() == \"\": dict_sw_block[key] = val else: dict_sw_line[key] = val","title":"check_switches"},{"location":"API/src/pyplate/#src.pyplate.get_type_rules","text":"Get the filetype-specific regexes (headers, comments. switches) Parameters: Name Type Description Default path Path of the file to get the dict of regexes for required Returns: Type Description The dict of regexes for this file type Source code in src/pyplate.py def get_type_rules(path): \"\"\" Get the filetype-specific regexes (headers, comments. switches) Args: path: Path of the file to get the dict of regexes for Returns: The dict of regexes for this file type \"\"\" # iterate over reps for _key, val in C.D_TYPE_RULES.items(): # fix ets if necessary exts = val[C.S_KEY_RULES_EXT] # lower case all exts l_exts = [item.lower() for item in exts] # add dots l_exts = [ f\".{item}\" if not item.startswith(\".\") else item for item in l_exts ] # check if the suffix or the filename (for dot files) matches # NB: also checks for dot files if path.suffix.lower() in l_exts or path.name.lower() in l_exts: return val[C.S_KEY_RULES_REP] # default result is py rep return {}","title":"get_type_rules"}]}